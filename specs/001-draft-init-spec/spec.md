# 機能仕様書: spec-kit-docs - AI駆動型ドキュメント生成システム

**機能ブランチ**: `001-draft-init-spec`
**作成日**: 2025-10-12
**ステータス**: ドラフト
**入力**: ユーザー記述: "draft/init-spec.md を確認し、日本語で要件定義を行ってください"

## Clarifications

### Session 2025-10-12

- Q: `/speckit.doc-init` で初期化されるドキュメント構造は、どのディレクトリ階層を生成すべきですか？ → A: 包括的な構造（`docs/features/`（機能ページ）+ `docs/guides/`（ガイド）+ `docs/api/`（API リファレンス）+ `docs/architecture/`（アーキテクチャ））、ただし5機能以下の小規模プロジェクトはフラット構造も可能
- Q: `/speckit.doc-update` のインクリメンタル更新で、「変更されたファイル」をどのように検出しますか？ → A: Git の変更履歴を使用（git diff で前回のコミットから変更されたファイルを検出）
- Q: plan.md や tasks.md が欠落している場合、生成されるドキュメントにどのような形式で注記を表示しますか？ → A: 視覚的に明確なアドモニション（MyST構文の ` ```{note}` や MkDocs の `!!! note` を使用）
- Q: `docs/features/` 内の機能ページファイルは、どのような命名規則にしますか？ → A: 説明的な名前のみ（`user-auth.md`, `api-integration.md`、番号なし）
- Q: 「小規模プロジェクト」としてフラット構造を使用する判定基準は、機能数がいくつ以下ですか？ → A: 5機能以下
- Q: SphinxでreStructuredText (.rst) とMarkdown (.md) のどちらをデフォルト形式にしますか？ → A: Markdown (.md) + myst-parser をデフォルトにする。理由：(1) spec-kitのすべてのソースファイル（spec.md、plan.md、tasks.md）がMarkdownであり、フォーマット統一により変換ロジックが不要、(2) ユーザーの学習コストを削減（reStructuredText構文の習得が不要）、(3) 生成後のドキュメントをユーザーが手動編集する際の利便性向上、(4) MyST Markdownは業界標準となりつつあり、Sphinxのほぼ全機能をサポート

### Session 2025-10-12 (Correction)

- **修正1**: spec-kit の公式仕様に基づき、機能仕様ディレクトリの場所を `.specify/specs/` から `specs/` (ルート直下) に修正しました。spec-kit の `scripts/bash/create-new-feature.sh` は `SPECS_DIR="$REPO_ROOT/specs"` を使用しており、`.specify/` は spec-kit 自身の内部ディレクトリ（scripts, templates, memory）であり、ユーザーの機能仕様を配置する場所ではありません。
- **修正2**: Sphinx のデフォルトファイル形式の不整合を解消しました。Session 2025-10-12 の決定（「Markdown (.md) + myst-parser をデフォルトにする」）に基づき、`index.rst` への参照をすべて `index.md` に変更し、Sphinx で生成されるすべてのファイルが Markdown 形式（.md）であることを明確化しました。これにより、spec-kit のソースファイル（spec.md、plan.md、tasks.md）との形式統一が実現されます。

### Session 2025-10-12 (Architecture Clarifications)

- Q: 対話的設定収集（プロジェクト名、著者名等）の責務は、AI エージェント（Claude Code）と Python スクリプト（doc_init.py）のどちらが担うべきか？ → A: オプション A - AI エージェント（Claude Code）が対話的に設定を収集し、スクリプト（doc_init.py）は引数のみを受け取る非対話的実行。理由：(1) Python スクリプトの input() は CI/CD などの非対話的環境で EOFError を起こす、(2) spec-kit の他のコマンド（/speckit.specify, /speckit.plan）と一貫性が保たれる、(3) 拡張性とテスト容易性が向上する
- Q: `.claude/commands/speckit.doc-init.md` コマンド定義の具体的な役割は？ → A: オプション A - コマンド定義は、対話的質問→情報収集→引数構築→スクリプト呼び出し→結果フィードバックの一連のプロンプトを記述。理由：(1) spec-kit の他のコマンド定義と一貫したパターン、(2) Claude Code が自然言語プロンプトからタスクを実行できる、(3) エラーハンドリングとユーザーフィードバックを AI エージェントが担当
- Q: 既存 `docs/` ディレクトリの上書き確認は、AI エージェントとスクリプトのどちらが担うべきか？ → A: オプション A - AI エージェントが事前に `docs/` の存在を確認し、存在する場合はユーザーに上書き確認を取り、確認が取れた場合のみ `--force` フラグ付きでスクリプトを実行。理由：(1) 非対話的環境でスクリプトが動作可能、(2) ユーザーとの対話は AI エージェントが担当するアーキテクチャに一貫、(3) スクリプトは `--force` の有無で動作を制御できテスト容易
- Q: MkDocs 初期化時のデフォルト値（サイト名、リポジトリURL）は？ → A: オプション A - サイト名：プロジェクト名と同じ、リポジトリURL：Git remote origin URL（取得できない場合は空文字列）。理由：(1) Sphinx との一貫性、(2) Git から自動取得可能な情報を活用、(3) 必須でない項目（リポジトリURL）は空でも問題なし
- Q: ディレクトリ構造決定（フラット vs 包括的）の機能数検出タイミングは？ → A: オプション A（自動移行付き）- 初期化時に現在の機能数を検出して構造を決定し、さらに `/doc-update` 実行時にも機能数を再チェックして、フラット構造から包括的構造への移行が必要な場合（機能数が6以上になった場合）は自動的に移行する。理由：(1) プロジェクトの成長に自動的に適応、(2) 小規模プロジェクトは常にシンプルなフラット構造で開始、(3) 逆方向の移行（包括的→フラット）は行わず、破壊的変更を避ける

### Session 2025-10-13 (Install Command Clarifications)

- Q: pyproject.tomlでのspecify-cliの依存関係指定方法は？ → A: オプション A - Git URL直接指定（`dependencies = ["specify-cli @ git+https://github.com/github/spec-kit.git"]`）。理由：specify-cliは公開リポジトリであり、Git URL直接指定で問題なくインストール可能

### Session 2025-10-13 (CLI Design Clarifications)

- Q: CLIツールの設計：どのようなコマンド構造にすべきか（独立したCLIツール vs spec-kitとの統合）？ → A: オプション B - `speckit-docs`コマンドを`specify`コマンドと統合し、`specify add-docs`のようなサブコマンドとして実装する。理由：(1) spec-kitエコシステムの一貫性を最大化、(2) ユーザーの学習コストを削減（新しいCLIツールを覚える必要がない）、(3) `/speckit.doc-init`と`/speckit.doc-update`のスラッシュコマンドは完全に維持される（インストール方法のみが統合され、使用方法は変わらない）
- Q: 配布方法：PyPIへの公開も検討すべきか、それともGitHubのみで十分か？ → A: オプション A - GitHubのみで配布（`uv tool install speckit-docs --from git+https://github.com/drillan/spec-kit-docs.git`）、PyPI公開は将来のフェーズで検討。理由：(1) MVP段階では開発とリリースプロセスをシンプルに保つ、(2) spec-kit自体もGitHubから配布されており、ユーザーは既にこのパターンに慣れている、(3) PyPI公開は追加の保守負担（バージョン管理、リリースプロセス、パッケージメタデータ）があり初期段階では不要
- Q: spec-kitとの統合方法：spec-kitリポジトリに統合すべきか、独立したリポジトリで開発すべきか？ → A: オプション A - 独立したCLIツールとして実装し、spec-kitの`specify`コマンドとは別に`speckit-docs install`を提供（spec-kitとの統合は名目上のみ）。理由：(1) spec-kitリポジトリへのPRは承認が必要で開発スピードが遅くなる可能性がある、(2) 独立したリポジトリで開発することで、spec-kit-docs固有の機能やリリースサイクルを柔軟に管理できる、(3) コマンド体系はspec-kitと一貫性を保ちながら（`specify add-docs`のようなパターン）、実装は独立して進められる
- Q: スラッシュコマンドの生成：CLIツールがどのようにして.claude/commands/にスラッシュコマンドを配置すべきか？ → A: オプション A - `speckit-docs install`コマンドがPythonパッケージ内のテンプレートファイル（`src/speckit_docs/commands/speckit.doc-init.md`, `speckit.doc-update.md`）をユーザープロジェクトの`.claude/commands/`にコピーする。理由：(1) spec-kitの`specify init`と同じパターンに従い実装がシンプル、(2) ユーザーにとって透明性が高く、コピー後のファイルをカスタマイズ可能、(3) importlib.resourcesでパッケージ内テンプレートにアクセスするためオフライン環境でも動作、(4) `--force`オプションで上書き更新が可能、(5) `/speckit.doc-init`と`/speckit.doc-update`としてClaude Codeに認識され、spec-kitの他のコマンドとの命名規則の一貫性を保つ
- Q: 既存プロジェクトへのインストール：`--here`フラグのようなオプションは必要か？ → A: オプション A - カレントディレクトリに自動的にインストール（`cd my-project && speckit-docs install`）、明示的なディレクトリ指定は不要。理由：(1) spec-kit-docsは既存のspec-kitプロジェクトに拡張機能を追加するツールであり、ユーザーは既にプロジェクトルートにいることが前提、(2) 新しいディレクトリを作成することはなく常に既存プロジェクトへの追加なので`--here`フラグも不要、(3) コマンドがシンプルになり使いやすさが向上
- Q: 既存ファイル（.claude/commands/や.specify/scripts/）が存在する場合の動作は？ → A: オプション C - インタラクティブ確認（全体）+ --forceで確認スキップ。理由：(1) spec-kitの本家`specify init --here`パターンと一貫性がある、(2) デフォルトは安全（確認を求める）だが、自動化時は`--force`で対応可能、(3) ユーザーの学習コストを削減
- Q: コマンドテンプレート（doc-init.md, doc-update.md）の配置場所とインストール方法は？ → A: オプション A - `src/speckit_docs/commands/` に配置し、importlib.resourcesでアクセス。理由：(1) 少数のファイル（2つのコマンド定義 + スクリプト）なので、Pythonパッケージに含めるのが適切、(2) オフライン環境でも動作（pip install後にネットワーク不要）、(3) Python標準のパッケージングベストプラクティスに準拠、(4) spec-kitのGitHubダウンロード方式は大量ファイル配布向けでspec-kit-docsには過剰
- Q: インストール失敗時の動作は？ → A: オプション B - ベストエフォート（エラー発生時もそこまでのファイルは残す）。理由：(1) spec-kitの`specify init --here`パターンと一貫性がある（既存ディレクトリへの追加時は部分的な状態を残す）、(2) spec-kit-docsは既存プロジェクトにファイルを追加するだけなので、プロジェクト全体を壊すリスクは低い、(3) ユーザーが手動で修正可能（失敗したファイルを削除して再実行）、(4) トランザクション機構は複雑でMVP範囲を超える
- Q: アンインストール・アップグレード機能は必要か？ → A: オプション D - 機能は提供しない（MVP範囲外）。理由：(1) 本家spec-kitもuninstall/upgrade機能を提供していない（一貫性）、(2) MVPの焦点は「ドキュメント生成」であり、ライフサイクル管理は二次的、(3) 少数のファイルなので手動削除も容易、(4) アップグレードは`speckit-docs install --force`で代替可能、(5) 将来必要になれば追加可能

### Session 2025-10-13 (CLI Framework Re-evaluation)

- Q: CLIフレームワーク選択の再検討：本家spec-kitが**typer**を使用しており、spec-kit-docsも`specify-cli`に依存するため既にtyperが依存ツリーに存在している。Constitution（憲章）のCore Principle I「spec-kit Integration First」に基づき、argparseからtyperに変更すべきか？ → A: **Option B (typerに変更)** - 本家spec-kitとの一貫性を最優先する。既にtyperに間接依存しており、追加の依存関係はない。ユーザーは一貫したCLI体験を得られ、型ヒントのネイティブサポートも得られる（C006: 堅牢コード品質に準拠）。エラーハンドリングの制御は、本家spec-kitが既に実現しているように、typerでも可能。理由：(1) **Core Principle I (spec-kit Integration First)への準拠** - 「spec-kitの標準パターンと完全に一貫していなければならない」という憲章要件を満たす、(2) **実質的な追加依存なし** - specify-cli経由で既にtyperに間接依存しているため、新しい外部依存は増えない、(3) **型ヒントのネイティブサポート** - Python 3.11+の型ヒント（`int`, `str`, `bool`等）を直接使用でき、mypy互換（C006準拠）、(4) **DRY原則** - 本家spec-kitのtyperパターン（`typer.confirm()`、`typer.Option()`等）を再利用できる（C012準拠）、(5) **Phase 2計画との整合** - research.mdでPhase 2に計画されている「specify-cliからStepTracker/console再利用」がtyper前提であり、一貫性が保たれる

### Session 2025-10-13 (Command Naming & Installation Method)

- Q: コマンド名の標準化：仕様では `/speckit.doc-init` だが README.md では `/doc-init` となっている不整合を解決すべきか？ → A: **Option A (長い形式)** - `/speckit.doc-init`, `/speckit.doc-update` に統一する。理由：spec-kitの付属物という扱いをコマンド名に含めることで、spec-kit エコシステムとの統合を明確にし、他のspec-kitコマンド（`/speckit.specify`, `/speckit.plan`）との命名規則の一貫性を保つ
- Q: インストールコマンドの推奨方法：README.mdに両方（CLIコマンドとPython API呼び出し）が記載されているが、どちらを推奨すべきか？ → A: **Option A (CLIコマンド)** - `speckit-docs install` を推奨する。理由：(1) 仕様（FR-021a, FR-022, FR-023）が前提としている標準的な方法、(2) ユーザーにとってシンプルで覚えやすい、(3) spec-kitの`specify init`パターンと一貫性がある、(4) Python API呼び出しはアドバンスドユーザー向けのフォールバックとして残す

### Session 2025-10-13 (Code Quality & Architecture Details)

- Q: ruffの設定：デフォルト設定のみ vs 一貫性のあるプリセット vs 厳格なルールセット？ → A: **Option B (一貫性のあるプリセット)** - `pyproject.toml`で`select = ["E", "F", "W", "I"]` + `line-length = 100` + `target-version = "py311"`を指定。理由：(1) エラー（E）、致命的エラー（F）、警告（W）、import順序（I）の基本ルールでツールプロジェクトには十分、(2) line-length=100はPython標準（PEP 8の88-100推奨）に準拠、(3) target-version指定により型ヒント構文の互換性を保証、(4) 過度に厳格なルール（docstring必須等）は開発速度を低下させる可能性を回避
- Q: CI/CD環境でのruffエラー処理：Fail-fast vs Warning-only vs ブランチ別動作？ → A: **CI/CDパイプラインは構築しない** - ローカル開発環境でのみruffを手動実行する。理由：MVP段階ではCI/CD構築はスコープ外、開発者がローカルで`uv run ruff check .`を実行して品質を維持
- Q: BaseGenerator抽象クラスのインターフェース：最小（1メソッド）vs 段階的（4メソッド）vs 詳細（7-8メソッド）？ → A: **Option B (段階的インターフェース)** - `initialize()`, `generate_feature_page(feature)`, `update_navigation()`, `validate()`の4メソッド。理由：(1) 単一責任原則に従い各メソッドが明確な役割を持つ、(2) initialize→個別ページ生成→ナビゲーション更新→検証と処理が分離されテスト容易、(3) 将来のDocusaurus等追加時も同じパターンを適用可能、(4) 最小インターフェースより構造化され、詳細インターフェースより保守しやすい
- Q: specify-cli（本家spec-kit）からの再利用範囲：MVP段階でStepTracker/consoleも再利用 vs typerパターンのみ？ → A: **Option A (MVP範囲は最小限)** - typerの基本パターン（`typer.confirm()`, `typer.Option()`等）のみ再利用、StepTracker/consoleは将来フェーズ。理由：(1) MVPの焦点は「ドキュメント生成」でありCLI体験の高度化は二次的、(2) specify-cliコード調査コストをMVPで回避し開発スピード優先、(3) Phase 2でStepTracker再利用を計画済み（research.md記載）なので段階的アプローチが適切、(4) typerパターン再利用だけでもDRY原則とC012（一貫性）を満たす
- Q: ログレベルとエラー出力の戦略：エラーのみ vs 構造化ログ（INFO/DEBUG/ERROR） vs 詳細ログ（常にDEBUG）？ → A: **Option B (構造化ログ)** - 標準出力にINFO以上、`--verbose`でDEBUG、`--quiet`でERRORのみ。理由：(1) ユーザーは通常実行で適切な進捗情報を得られる（「3機能を処理中...」等）、(2) `--verbose`フラグでトラブルシューティング時に詳細情報取得可能、(3) `--quiet`でCIやスクリプト組み込み時にエラーのみ出力、(4) Pythonの標準logging模块を使用し保守性が高い、(5) 本家spec-kitの他コマンドとの一貫性

## アーキテクチャと責務分担

spec-kit-docs は、AI エージェント（Claude Code）とバックエンドスクリプトの協調によって動作します。このアーキテクチャは spec-kit の標準パターンに従います。

### AI エージェント（Claude Code）の責務

- ユーザーとの対話的な情報収集（プロジェクト名、著者名、バージョン、言語、ドキュメントツール選択など）
- 入力値の検証とユーザーへのフィードバック
- 既存ファイル（docs/ ディレクトリ）の上書き確認
- 収集した情報をコマンドライン引数としてスクリプトに渡す
- エラーメッセージの解釈とユーザーへの提示

### バックエンドスクリプトの責務

- コマンドライン引数から設定を受け取る
- 非対話的にドキュメントプロジェクトを生成
- エラーを構造化された形式で返す（終了コードとメッセージ）
- **標準入力（stdin）を使用しない** - すべての設定はコマンドライン引数またはデフォルト値から取得
- ファイルシステム操作（ディレクトリ作成、ファイル生成）
- テンプレートの展開と設定ファイルの生成

### 設計根拠

この責務分担により以下が実現されます：

1. **非対話的環境での実行可能性**: Python スクリプトは CI/CD、バックグラウンドジョブ、自動化ワークフローで EOFError を起こさずに実行可能
2. **テスト容易性**: スクリプトは決定的な入力（コマンドライン引数）を受け取り、単体テストが容易
3. **spec-kit との一貫性**: `/speckit.specify`、`/speckit.plan` などの他のコマンドと同じパターンに従う
4. **拡張性**: 将来的に他の AI エージェント（GitHub Copilot、Gemini など）をサポートする際も、スクリプト側の変更は不要

## ユーザーシナリオとテスト *(必須)*

### ユーザーストーリー1: ドキュメントプロジェクトの初期化 (優先度: P1) 🎯 MVP

**目的**: spec-kitユーザーが、単一コマンドでドキュメントプロジェクトを初期化し、Sphinx または MkDocs のいずれかを選択し、インタラクティブに設定を構成できるようにすることで、手動でディレクトリを作成したり設定ファイルを編集したりすることなく、プロジェクトに適したドキュメント基盤を確立できるようにします。

**この優先度の理由**: ドキュメント生成の前提条件です。初期化がなければ、更新するドキュメント構造が存在しません。これはワークフローの最初のステップです。

**独立テスト**: ユーザーが spec-kit プロジェクトで `/speckit.doc-init --type sphinx` を実行します。システムはプロジェクト名、著者名、バージョンを対話的に尋ねます。完了後、`docs/` ディレクトリが作成され、Sphinx の設定ファイル（`conf.py`、`index.md`）と基本構造が含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: 有効な spec-kit プロジェクト（`.specify/` ディレクトリを持つ）、**実行**: ユーザーが `/speckit.doc-init --type sphinx` を実行、**期待結果**: システムが対話的にプロジェクト名、著者名、バージョン、言語を尋ね、回答に基づいて `docs/` に Sphinx プロジェクトを作成し、`conf.py`、`index.md`、`Makefile`、必要なディレクトリ構造を含む

2. **前提条件**: 有効な spec-kit プロジェクト、**実行**: ユーザーが `/speckit.doc-init --type mkdocs` を実行、**期待結果**: システムが対話的に設定を尋ね、`docs/` に MkDocs プロジェクトを作成し、`mkdocs.yml`、`docs/index.md`、必要なディレクトリ構造を含む

3. **前提条件**: spec-kit プロジェクト、**実行**: ユーザーが type 引数なしで `/speckit.doc-init` を実行、**期待結果**: システムが「どのドキュメントツールを使用しますか？ (sphinx/mkdocs)」と尋ね、ユーザーの選択に基づいて初期化を続行

4. **前提条件**: 既に `docs/` ディレクトリが存在するプロジェクト、**実行**: ユーザーが初期化を試みる、**期待結果**: システムが警告を表示:「docs/ ディレクトリは既に存在します。上書きしますか？ (yes/no)」、拒否された場合は既存の構造を保持

5. **前提条件**: spec-kit プロジェクトではないディレクトリ（`.specify/` なし）、**実行**: ユーザーが初期化を試みる、**期待結果**: システムがエラーを表示:「spec-kit プロジェクトではありません。最初に 'specify init' を実行してください。」

6. **前提条件**: 初期化が完了したプロジェクト、**実行**: ユーザーが `docs/` ディレクトリを確認、**期待結果**: 選択したドキュメントツールに応じた標準的なディレクトリ構造、設定ファイル、プレースホルダーコンテンツが含まれ、すぐにビルド可能な状態

---

### ユーザーストーリー2: spec-kit 仕様からのドキュメント更新 (優先度: P1) 🎯 MVP

**目的**: ドキュメントプロジェクトを初期化した spec-kit ユーザーが、`specs/` ディレクトリから最新の仕様情報を明示的にドキュメントに統合できるようにすることで、spec.md、plan.md、tasks.md の変更を手動でコピー＆ペーストすることなく、ドキュメントを最新の状態に保つことができるようにします。

**この優先度の理由**: これは初期化の直接的な続きです。初期化後、ユーザーは実際のコンテンツでドキュメントを埋める必要があります。自動化はせず、ユーザーが制御できるようにします。

**独立テスト**: 3つの機能（001-user-auth、002-api-integration、003-notifications）を持つ spec-kit プロジェクトで `/speckit.doc-init` を実行後、`/speckit.doc-update` を実行します。システムは各機能の spec.md、plan.md、tasks.md から情報を抽出し、ドキュメント構造に統合します。生成されたドキュメントをビルドして、3つの機能すべての情報が含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: `/speckit.doc-init` で初期化された Sphinx プロジェクト、3つの機能（各ディレクトリに spec.md と plan.md を含む）、**実行**: ユーザーが `/speckit.doc-update` を実行、**期待結果**: システムが `docs/features/` に各機能のページを作成し、spec.md からのユーザーストーリーと要件、plan.md からのアーキテクチャ情報を含み、`index.md` の toctree に機能リストを追加

2. **前提条件**: 初期化された MkDocs プロジェクト、機能仕様、**実行**: `/speckit.doc-update` を実行、**期待結果**: システムが `docs/features/*.md` ファイルを作成し、`mkdocs.yml` の nav セクションを更新して新しいページを含める

3. **前提条件**: spec.md のみを持つ機能（plan.md や tasks.md がない）、**実行**: 更新を実行、**期待結果**: システムが利用可能な情報から機能ページを生成し、欠落しているセクションについて「[このセクションはまだ利用できません]」などの注記を表示

4. **前提条件**: `specs/` ディレクトリが空または存在しない、**実行**: ユーザーが更新を試みる、**期待結果**: システムがエラーを表示:「仕様が見つかりません。最初に /speckit.specify を実行して機能仕様を作成してください。」

5. **前提条件**: `docs/` ディレクトリが初期化されていない、**実行**: ユーザーが `/speckit.doc-update` を実行、**期待結果**: システムがエラーを表示:「ドキュメントプロジェクトが見つかりません。最初に /speckit.doc-init を実行してください。」

6. **前提条件**: 前回の更新以降に変更された機能仕様、**実行**: `/speckit.doc-update` を再実行、**期待結果**: システムが変更された機能のページのみを更新し、変更されていないページは保持し、「3つの機能が更新されました、2つは変更なし」などの更新サマリーを表示

---

### ユーザーストーリー3: spec-kit 拡張機能としてのインストール (優先度: P1) 🎯 MVP

**目的**: spec-kit ユーザーが、既存の spec-kit プロジェクトに spec-kit-docs を拡張機能として簡単なコマンドでインストールできるようにすることで、複雑な設定なしに AI エージェント（Claude Code）で `/speckit.doc-init` と `/speckit.doc-update` コマンドにアクセスできるようにします。

**この優先度の理由**: ユーザーはツールを使用する前にインストールできる必要があります。これは他のすべての機能の前提条件です。

**独立テスト**: 既存の spec-kit プロジェクトを持つユーザーが、まず`uv tool install speckit-docs --from git+https://github.com/drillan/spec-kit-docs.git`でCLIツールをインストールし、次にプロジェクトルートで`speckit-docs install`を実行します。インストール後、Claude Code で `/speckit.doc-init` と `/speckit.doc-update` を実行でき、エラーなくコマンドが実行されることを確認します。

**受け入れシナリオ**:

1. **前提条件**: spec-kit プロジェクトとして初期化されたディレクトリ（`.specify/` と `.claude/` ディレクトリを持つ）、**実行**: ユーザーがプロジェクトルートで`speckit-docs install`を実行、**期待結果**: システムが`.claude/commands/`にドキュメントコマンド定義（`doc-init.md`と`doc-update.md`、Pythonパッケージ内の`src/speckit_docs/commands/`からコピー）を追加し、必要なスクリプトを`.specify/scripts/docs/`にコピーし、インストール成功を確認

2. **前提条件**: spec-kit-docs をインストールしたユーザー、**実行**: プロジェクトディレクトリで Claude Code を開き、`/speckit` と入力、**期待結果**: `/speckit.specify`、`/speckit.plan` などと並んで、利用可能なコマンドリストに `/speckit.doc-init` と `/speckit.doc-update` が表示される

3. **前提条件**: spec-kit プロジェクトではないディレクトリ（`.specify/` ディレクトリなし）、**実行**: ユーザーがインストールを試みる、**期待結果**: システムがエラーを表示:「spec-kit プロジェクトではありません。最初に 'specify init' を実行してください。」

4. **前提条件**: 既にインストールされている spec-kit-docs 拡張機能、**実行**: ユーザーが再度インストールを実行、**期待結果**: システムが既存のインストールを検出し、上書き前に確認を求め（spec-kitの`specify init --here`パターンと同様）、拒否された場合はユーザーのカスタマイズを保持。`--force`フラグ指定時は確認をスキップして上書き

---

### ユーザーストーリー4: インテリジェントな複数機能の統合 (優先度: P2)

**目的**: 複数の進化する機能を持つspec-kitユーザーが、エンティティとAPIが時間とともにどのように進化するかを追跡しながら、システムが機能間の情報を自動的に統合できるようにすることで、ドキュメントが機能ごとの断片的なスナップショットではなく、プロダクトの現在の統一された状態を反映するようにします。

**この優先度の理由**: これは単純なファイル連結とこのツールを差別化するものです。AI駆動の統合の真の価値を提供しますが、基本的なドキュメント生成には必須ではありません。

**独立テスト**: 001-coreでUser{id, name, email}を定義し、003-profilesでUser.profile_pictureを追加するプロジェクトを作成します。生成されたドキュメントは、導入バージョンでマークされたすべてのフィールドを持つ単一の統合Userエンティティを示します。ドキュメントに2つの別々の矛盾するUser定義が表示されないことを確認します。

**受け入れシナリオ**:

1. **前提条件**: 001/data-model.mdがUserエンティティをフィールド[id, name, email]で定義し、003/data-model.mdがUserに[profile_picture, bio]を追加、**実行**: 統合を有効にしてドキュメントが生成される、**期待結果**: データモデルセクションに5つすべてのフィールドを持つ単一の統合Userエンティティが表示され、各フィールドを導入した機能で注釈が付けられる

2. **前提条件**: 001/contracts/api.jsonがエンドポイント[POST /users, GET /users/{id}]を定義し、003/contracts/extended-api.jsonが[PUT /users/{id}/profile, GET /users/{id}/activity]を追加、**実行**: 統合が実行される、**期待結果**: APIリファレンスセクションが4つすべてのエンドポイントをリソースごとにグループ化してリストし、各エンドポイントを導入した機能を示すメモが含まれる

3. **前提条件**: 001がTaskStatus列挙型を[todo, done]と定義し、003が[todo, in_progress, review, done]に拡張、**実行**: 統合がこの進化を検出、**期待結果**: ドキュメントが4つすべての値を持つ現在の列挙型を示し、メモが含まれる:「機能003でin_progressとreview状態を追加するために拡張されました。」

4. **前提条件**: 同じエンティティを互換性のない方法で変更する2つの機能(例:フィールドタイプがstringからenumに変更)、**実行**: 統合がそれらをマージしようとする、**期待結果**: システムが競合を検出し、時間ベースの解決(後の機能が優先)を適用し、ドキュメントに「Breaking Change」注釈を追加

---

### ユーザーストーリー5: 対象者別ドキュメント (優先度: P3)

**目的**: 異なるステークホルダー向けのドキュメントを準備するspec-kitユーザーが、エンドユーザー、外部開発者、コントリビューター向けに別々のドキュメントバージョンを生成できるようにすることで、各対象者が無関係な技術的詳細や内部実装メモに圧倒されることなく、ニーズに適した情報を受け取れるようにします。

**この優先度の理由**: 価値はありますが、ユーザーは最初は手動でコンテンツをフィルタリングできます。これは使いやすさを向上させますが、基本機能には必須ではありません。

**独立テスト**: --audience=enduserフラグでドキュメントを生成します。plan.mdからの技術的アーキテクチャの詳細とtasks.mdからの内部タスクの内訳が除外され、spec.mdからの機能説明が含まれていることを確認します。次に--audience=developerで生成し、APIコントラクトとデータモデルが含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: spec.md、plan.md、tasks.md、data-model.md、contracts/を含む完全な機能仕様を持つプロジェクト、**実行**: ユーザーが--audience=enduserでドキュメントを生成、**期待結果**: 出力に機能説明とクイックスタートガイドが含まれるが、技術的アーキテクチャ、タスクの内訳、実装の詳細は除外される

2. **前提条件**: 同じプロジェクト、**実行**: ユーザーが--audience=developerでドキュメントを生成、**期待結果**: 出力に完全なAPI仕様、データモデルの詳細、アーキテクチャの決定、実装ステータスに関係なくすべての機能が含まれる(実装済み/進行中/計画済みとしてマーク)

3. **前提条件**: 同じプロジェクト、**実行**: ユーザーが--audience=contributorでドキュメントを生成、**期待結果**: 出力にすべてが含まれる:機能仕様、アーキテクチャ、データモデル、API、タスクの内訳、実装ガイドライン、開発セットアップ手順

4. **前提条件**: gitブランチステータスを介して「進行中」とマークされた機能、**実行**: --audience=enduserドキュメントの生成、**期待結果**: その機能が出力から除外されるが、--audience=developerドキュメントの生成時には、「(進行中)」ステータスバッジ付きで機能が含まれる

---

### ユーザーストーリー6: バージョン履歴とトレーサビリティ (優先度: P3)

**目的**: 成長するプロダクトを維持するspec-kitユーザーが、明確なバージョン履歴とともに、エンティティとAPIが機能間でどのように進化したかを確認できるようにすることで、プロダクトの進化を理解し、破壊的変更を伝え、コントリビューターがアーキテクチャの決定を理解するのを支援できるようにします。

**この優先度の理由**: これは基本的なドキュメントニーズには必須ではない、プロフェッショナルな仕上げを追加する便利な拡張機能です。

**独立テスト**: 3つの機能にわたってUserエンティティが変更されたプロジェクトのドキュメントを生成します。Userエンティティのドキュメントに、各機能で何が変更され、なぜ変更されたかを示す「バージョン履歴」セクションが含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: Userエンティティが3つの機能にわたって進化(001:基本フィールドで作成、002:profile_picture追加、003:privacy_settings追加)、**実行**: ドキュメントが生成される、**期待結果**: Userエンティティページに、何が変更されたかを示し、各変更を導入した機能仕様にリンクする3つのエントリを持つ「バージョン履歴」セクションが含まれる

2. **前提条件**: 003でオプションのクエリパラメータを追加するために変更されたAPIエンドポイント/users/{id}、**実行**: ドキュメントが生成される、**期待結果**: エンドポイントドキュメントに変更履歴メモが含まれる:「003で更新:オプションの?include=profile,activityクエリパラメータを追加。」

3. **前提条件**: spec.mdの「根拠」または「前提条件」セクションを参照する機能、**実行**: ドキュメントを統合、**期待結果**: システムがこれらのコンテキストメモを抽出して保持し、関連セクション(例:特定のエンティティ構造が選ばれた理由)に含める

4. **前提条件**: 機能003がTaskStatus列挙値を変更した破壊的変更、**実行**: ドキュメントが生成される、**期待結果**: 破壊的変更が「⚠️ Breaking Change (v003)」バッジと何が変更されたかの説明で明確にフラグ付けされる

---

### エッジケース

- **空の機能ディレクトリ**: 機能フォルダーは存在するがmarkdownファイルがない → 静かにスキップするかユーザーに警告
- **不正なmarkdown**: spec.mdファイルに無効なmarkdown構文がある → 他のファイルの処理を継続し、ファイルパスとともに警告をログ
- **依存関係の欠落**: 機能が以前のどの機能にも存在しないエンティティやAPIを参照している → ドキュメントで潜在的な問題としてフラグ
- **循環依存**: 機能Aが機能Bを参照し、機能Bが機能Aを参照 → サイクルを検出して切断し、関係をドキュメント化
- **非常に大きなプロジェクト**: 数百ページの仕様を持つ50以上の機能 → 段階的に処理し、進行状況を表示し、メモリ使用を最適化
- **非標準のファイル名**: ユーザーがspecs/に追加ファイルを手動で作成 → 予期されるパターンに一致する場合(機能ディレクトリ内の*.md)は含め、それ以外は無視
- **gitブランチの状態**: 機能ブランチが存在するがmainにマージされていない → 実装ステータスを決定し、ドキュメントで適切にマーク
- **複数のコントラクト形式**: 一部の機能はOpenAPI JSONを使用し、他はmarkdownテーブルを使用 → 両方の形式を解析し、統一された表現に正規化
- **部分的な機能仕様**: 機能にspec.mdはあるがplan.mdまたはdata-model.mdがない → 利用可能なファイルからドキュメントを生成し、欠落しているアーティファクトに注意
- **競合するタイムスタンプ**: gitが機能003が002の前にコミットされたことを示す → gitタイムスタンプではなく機能番号を真実の源として使用
- **カスタムテンプレート**: ユーザーがプロジェクト内のspec-template.mdを変更 → 解析時にカスタムセクションを尊重し、フォールバックとして標準セクションを使用

## 要件 *(必須)*

### 機能要件

#### /speckit.doc-init コマンド

- **FR-001**: システムは、プロジェクトルートに `.specify/` ディレクトリが存在することを確認し、spec-kit プロジェクトであることを検証しなければならない
- **FR-002**: システムは、`--type` 引数または対話的プロンプトを通じて、ドキュメントツールの選択（sphinx または mkdocs）をサポートしなければならない
- **FR-003**: AI エージェント（Claude Code）は、Sphinx 初期化の場合、プロジェクト名、著者名、バージョン、言語設定をユーザーから対話的に収集し、コマンドライン引数として doc_init.py に渡さなければならない
- **FR-003a**: doc_init.py は、以下のコマンドライン引数を受け取らなければならない: `--type`, `--project-name`, `--author`, `--version`, `--language`, `--force` (Sphinx の場合)、`--type`, `--project-name`, `--site-name`, `--repo-url`, `--force` (MkDocs の場合)。`--force` フラグが指定された場合、既存の `docs/` ディレクトリを上書きする
- **FR-003b**: doc_init.py は、引数が未指定の場合、合理的なデフォルト値を使用しなければならない。Sphinx の場合：（プロジェクト名：現在のディレクトリ名、著者：Git user.name または "Unknown Author"、バージョン："0.1.0"、言語："ja"）。MkDocs の場合：（プロジェクト名：現在のディレクトリ名、サイト名：プロジェクト名と同じ、リポジトリURL：Git remote origin URL または空文字列）
- **FR-003c**: doc_init.py は、標準入力（stdin）を使用してはならない。すべての設定はコマンドライン引数またはデフォルト値から取得する
- **FR-003d**: doc_init.py は、`docs/` ディレクトリが既に存在し `--force` フラグが指定されていない場合、エラー終了コード 1 とメッセージ "docs/ already exists. Use --force to overwrite." を返さなければならない
- **FR-004**: AI エージェント（Claude Code）は、MkDocs 初期化の場合、プロジェクト名、サイト名、リポジトリURLをユーザーから対話的に収集し、コマンドライン引数として doc_init.py に渡さなければならない
- **FR-005**: システムは、Sphinx の場合、`docs/` ディレクトリに `conf.py`（myst-parser設定を含む）、`index.md`（Markdown形式）、`Makefile`、`make.bat`、および以下のディレクトリ構造を生成しなければならない。すべてのファイルはMarkdown形式（.md）で、MyST Markdown構文をサポート。初期化時に `specs/` ディレクトリ内の機能数をカウントし、構造を決定する：
  - 5機能以下の小規模プロジェクト：フラット構造（`docs/` 直下に機能ページ）
  - 6機能以上のプロジェクト：包括的な構造（`docs/features/`、`docs/guides/`、`docs/api/`、`docs/architecture/`）
- **FR-005a**: システムは、Sphinx初期化時に`conf.py`でmyst-parserを有効化し、Markdown（.md）ファイルを解析できるように設定しなければならない。具体的には：
  - `extensions`に`'myst_parser'`を追加
  - `source_suffix`に`.md`を含める（`.rst`もサポート）
  - MyST Markdownの拡張機能（colon_fence、deflist、tasklist、attrs_inline等）を有効化
- **FR-006**: システムは、MkDocs の場合、`docs/` ディレクトリに `mkdocs.yml`、`docs/index.md`、および以下のディレクトリ構造を生成しなければならない。初期化時に `specs/` ディレクトリ内の機能数をカウントし、構造を決定する：
  - 5機能以下の小規模プロジェクト：フラット構造（`docs/` 直下に機能ページ）
  - 6機能以上のプロジェクト：包括的な構造（`docs/features/`、`docs/guides/`、`docs/api/`、`docs/architecture/`）
- **FR-007**: AI エージェント（Claude Code）は、`docs/` ディレクトリが既に存在する場合、ユーザーに上書き確認を求め、ユーザーが承認した場合のみ `--force` フラグ付きで doc_init.py を呼び出さなければならない。ユーザーが拒否した場合は既存の構造を保持し、処理を中断する
- **FR-008**: doc_init.py は、選択したツールに必要な Python パッケージ（Sphinxの場合：sphinx + myst-parser、MkDocsの場合：mkdocs）を標準出力（stdout）に人間が読みやすい形式で出力しなければならない。形式：「次のパッケージのインストールが必要です: {package_list}」+ 「インストールコマンド: uv add {package_list}」。この出力は、AI エージェント（Claude Code）がユーザーにインストール手順を提示するために使用する
- **FR-009**: システムは、初期化後すぐにビルド可能な最小限のドキュメント構造を作成しなければならない

#### /speckit.doc-update コマンド

- **FR-010**: システムは、`docs/` ディレクトリが存在し、有効なドキュメントプロジェクト（`conf.py` または `mkdocs.yml`）であることを検証しなければならない
- **FR-011**: システムは、少なくとも spec.md ファイルを含む `specs/` 配下のすべての機能ディレクトリを発見しなければならない
- **FR-012**: システムは、markdown ファイル（spec.md、plan.md、tasks.md、data-model.md）を解析し、見出し、リスト、テーブル、コードブロックを含む構造化されたコンテンツを抽出しなければならない
- **FR-013**: システムは、Sphinx プロジェクトの場合、各機能の `.md` ファイル（MyST Markdown形式）を生成し、`index.md` の toctree に追加しなければならない。ファイル命名規則：機能ディレクトリ名から番号を除いた説明的な名前（例：`001-user-auth` → `user-auth.md`）。小規模プロジェクト（5機能以下）は `docs/` 直下、大規模プロジェクトは `docs/features/` 内に配置
- **FR-014**: システムは、MkDocs プロジェクトの場合、各機能の `.md` ファイルを生成し、`mkdocs.yml` の nav セクションに追加しなければならない。ファイル命名規則：機能ディレクトリ名から番号を除いた説明的な名前（例：`001-user-auth` → `user-auth.md`）。小規模プロジェクト（5機能以下）は `docs/` 直下、大規模プロジェクトは `docs/features/` 内に配置
- **FR-015**: システムは、spec.md からのすべてのセクション（ユーザーシナリオ、要件、成功基準、エッジケース）を含む元のコンテンツを保持しなければならない
- **FR-016**: システムは、plan.md が存在する場合、アーキテクチャセクションと技術的決定をドキュメントに含めなければならない
- **FR-017**: システムは、tasks.md が存在する場合、実装タスクの概要をドキュメントに含めなければならない
- **FR-018**: システムは、欠落しているファイル（plan.md や tasks.md がない）がある機能について、利用可能なコンテンツからドキュメントを生成し、欠落セクションには視覚的に明確なアドモニション（Sphinx の `.. note::` や MkDocs の `!!! note`）形式で注記を追加しなければならない
- **FR-019**: システムは、Git の変更履歴（git diff）を使用して前回の更新以降に変更されたファイルのみを検出し、変更されたファイルのみを再処理し、変更されていないファイルは保持しなければならない
- **FR-019a**: システムは、`/speckit.doc-update` 実行時に現在の機能数をカウントし、現在フラット構造（`docs/` 直下に機能ページ）で機能数が6以上になった場合、自動的に包括的構造（`docs/features/`、`docs/guides/`、`docs/api/`、`docs/architecture/`）に移行しなければならない。移行時には既存の機能ページを `docs/features/` に移動し、インデックスとナビゲーションを更新する
- **FR-019b**: システムは、逆方向の移行（包括的構造からフラット構造への移行）を行ってはならない。一度包括的構造に移行したプロジェクトは、機能数が減少しても包括的構造を維持する
- **FR-020**: システムは、更新後に何個の機能が更新され、何個が変更なしだったかを示すサマリーを表示しなければならない。構造移行が発生した場合は「フラット構造から包括的構造に移行しました」というメッセージも含める

#### インストールとプロジェクト構造

- **FR-021**: `speckit-docs`CLIツールは、独立したPythonパッケージとしてGitHubから配布され（`uv tool install speckit-docs --from git+https://github.com/drillan/spec-kit-docs.git`）、spec-kitエコシステムと一貫したコマンド体系を提供しなければならない。PyPI公開は将来のフェーズで検討する
- **FR-021a**: `speckit-docs install`コマンドは、カレントディレクトリがspec-kitプロジェクトであることを確認し（`.specify/`ディレクトリと`.claude/`ディレクトリの存在確認）、そうでない場合は明確なエラーメッセージを表示しなければならない
- **FR-021b**: `speckit-docs install`コマンドは、カレントディレクトリに自動的にインストールし、明示的なディレクトリ指定引数を要求してはならない（`cd my-project && speckit-docs install`パターン）
- **FR-022**: `speckit-docs install`コマンドは、インストール時に `.claude/commands/speckit.doc-init.md` と `.claude/commands/speckit.doc-update.md` の2つのコマンド定義を作成しなければならない（Claude Codeが `/speckit.doc-init` と `/speckit.doc-update` として認識し、spec-kitの他のコマンドとの命名規則の一貫性を保つ）
- **FR-022a**: `.claude/commands/speckit.doc-init.md` は、以下のワークフローを実行するプロンプトを記述しなければならない：(1) ユーザーに対話的に質問（ドキュメントツール選択、プロジェクト名、著者名、バージョン、言語等）、(2) 収集した情報をコマンドライン引数に構築、(3) `uv run python .specify/scripts/docs/doc_init.py` を適切な引数で呼び出し、(4) スクリプトの結果をユーザーにフィードバック、(5) エラーが発生した場合は明確なメッセージと次のステップを提示
- **FR-022b**: `.claude/commands/speckit.doc-update.md` は、以下のワークフローを実行するプロンプトを記述しなければならない：(1) `docs/` ディレクトリの存在確認、(2) `uv run python .specify/scripts/docs/doc_update.py` の呼び出し、(3) 更新されたファイルのサマリー表示、(4) エラーハンドリングとユーザーフィードバック
- **FR-023**: `speckit-docs install`コマンドは、インストール時に必要なスクリプト（`doc_init.py`、`doc_update.py`）を `.specify/scripts/docs/` にコピーしなければならない
- **FR-023a**: コマンドテンプレートファイル（`speckit.doc-init.md`、`speckit.doc-update.md`）とスクリプトファイル（`doc_init.py`、`doc_update.py`）は `src/speckit_docs/commands/` および `src/speckit_docs/scripts/` ディレクトリに配置され、`importlib.resources`を使用してアクセスされなければならない。これにより、Pythonパッケージに含まれ、オフライン環境でも動作する
- **FR-023b**: `speckit-docs install` コマンドは、既存のコマンド定義ファイル（`.claude/commands/speckit.doc-*.md`）または スクリプトファイル（`.specify/scripts/docs/`）が存在する場合、ユーザーに上書き確認を求めなければならない。`--force` フラグが指定された場合は、確認をスキップして上書きする（spec-kitの`specify init --here`パターンと一貫）
- **FR-023c**: インストール中にエラーが発生した場合、システムはベストエフォート方式で動作し、エラー発生時点までにコピーされたファイルは残す。ユーザーは手動で修正するか、問題を解決してから再実行できる（spec-kitの既存ディレクトリへの追加パターンと一貫）
- **FR-024**: システムは、コンテンツを統合する際に時間的順序を決定するために、機能ディレクトリの番号付け（001、002、003）を使用しなければならない

#### 高度な機能（将来のフェーズ）

- **FR-025**: システムは、複数の data-model.md ファイルからエンティティ定義を統合し、現在の状態と進化を示す統一されたデータモデルを生成しなければならない（P2）。「進化を示す」とは、以下の情報を含むことを意味する：(a) 各フィールドを導入した機能番号（例：`profile_picture` (added in 003)）、(b) フィールドが変更された場合の変更履歴（例：`status: string → TaskStatus enum` (changed in 005)）、(c) 削除されたフィールドの記録（例：`~~old_field~~` (removed in 007)）。詳細な出力形式は、Phase 2実装時にdata-model.mdまたは専用の設計ドキュメントで定義される
- **FR-026**: システムは、複数の機能の contracts/ ディレクトリから API 仕様をマージし、統一された API リファレンスを生成しなければならない（P2）
- **FR-027**: システムは、競合する情報（例：同じエンティティの異なる定義）を検出し、最新優先戦略を使用して解決しなければならない（P2）
- **FR-028**: システムは、各要素を導入または変更した機能を示すために、統合されたコンテンツに注釈を付けなければならない（P2）
- **FR-029**: システムは、対象者パラメータに基づいてコンテンツをフィルタリングしなければならない：enduser（機能と使用法のみ）、developer（API とアーキテクチャ）、contributor（すべて）（P3）
- **FR-030**: システムは、機能の実装ステータスを決定するために git リポジトリの状態を確認しなければならない（main にマージ済み=実装済み、ブランチとして存在=進行中、ブランチなし=計画済み）（P3）
- **FR-031**: システムは、機能間での進化を示すエンティティと API のバージョン履歴セクションを生成しなければならない（P3）
- **FR-032**: システムは、破壊的変更（タイプの変更、削除されたフィールド、変更された列挙型）を警告バッジでフラグ付けしなければならない（P3）

#### エラーハンドリングと品質

- **FR-033**: システムは、一般的な問題に対して明確なエラーメッセージを提供しなければならない：spec-kit プロジェクトではない、ドキュメントプロジェクトが初期化されていない、機能が見つからない、不正なファイル
- **FR-034**: システムは、オフラインで表示でき、任意の Web サーバーでホストできる静的 HTML ファイルとしてドキュメントを生成しなければならない
- **FR-035**: システムは、不正な markdown を適切に処理し、他のファイルの処理を継続し、特定のエラーを報告しなければならない。すべてのエラーは `SpecKitDocsError` 例外として発生させ、エラーメッセージには「ファイルパス」「エラーの種類」「ユーザーへの推奨アクション」を含める。AI エージェント（Claude Code）は、この構造化されたエラーメッセージをユーザーにわかりやすく提示する
- **FR-036**: システムは、コードリント・フォーマットに**ruff**を使用しなければならない（blackは禁止）。`pyproject.toml`で以下の設定を指定する：`select = ["E", "F", "W", "I"]`（エラー、致命的エラー、警告、import順序）、`line-length = 100`、`target-version = "py311"`。開発者は`uv run ruff check .`でローカル実行する（CI/CDパイプラインは構築しない）
- **FR-037**: システムは、Pythonの標準logging模块を使用した構造化ログを実装しなければならない。デフォルトでINFOレベル以上を標準出力に出力し、`--verbose`フラグでDEBUGレベル、`--quiet`フラグでERRORレベルのみを出力する。ログメッセージは進捗情報（「3機能を処理中...」等）とエラー詳細を含む

### 主要エンティティ *(機能がデータを含む場合に含める)*

- **SpecKitProject**: spec-kitプロジェクトを表し、ルートディレクトリ、.specify/設定、specs/ディレクトリを含む
- **Feature**: 単一の機能仕様(例:001-user-auth)で、markdownファイルのコレクション、コントラクト、実装ステータスを含む
- **Entity**: data-model.mdファイルから抽出されたデータモデルエンティティ(例:User、Task)で、フィールド、タイプ、バージョン履歴を含む
- **APIEndpoint**: contracts/からのAPIエンドポイント定義で、メソッド、パス、パラメータ、バージョン履歴を含む
- **DocumentationSite**: ページ、ナビゲーション、アセットを含む生成された出力構造
- **Audience**: 関連するコンテンツフィルタリングルールを持つターゲットオーディエンス(enduser、developer、contributor)の列挙型
- **SynthesisResult**: 機能間でマージした後のエンティティとAPIの統合ビュー
- **FeatureStatus**: gitブランチステータスから派生した実装状態(implemented、in_progress、planned)の列挙型
- **BaseGenerator**: ドキュメントジェネレーターの抽象ベースクラス。以下の4つの必須メソッドを定義：(1) `initialize()` - ドキュメントプロジェクトの初期化と設定ファイル生成、(2) `generate_feature_page(feature: Feature) -> None` - 単一機能のページ生成、(3) `update_navigation() -> None` - 目次（toctree/nav）の更新、(4) `validate() -> bool` - ビルド前検証。SphinxGeneratorとMkDocsGeneratorがこのインターフェースを実装する

## 成功基準 *(必須)*

### 測定可能な成果

#### /speckit.doc-init コマンド

- **SC-001**: ユーザーは `/speckit.doc-init` を実行してから完了まで30秒以内にドキュメントプロジェクトを初期化できる（対話的な入力時間を除く）
- **SC-002**: 初期化されたドキュメントプロジェクトは、追加設定なしでビルドコマンド（`make html` または `mkdocs build`）が成功する
- **SC-003**: Sphinx と MkDocs の両方のドキュメントツールが正しくサポートされ、それぞれの標準的なプロジェクト構造が生成される
- **SC-004**: 既存の `docs/` ディレクトリを持つプロジェクトで初期化を試みた場合、100% のケースで上書き確認が表示される
- **SC-005**: インタラクティブプロンプトで収集された設定（プロジェクト名、著者名など）が生成された設定ファイルに正確に反映される

#### /speckit.doc-update コマンド

- **SC-006**: ユーザーは5機能のプロジェクトで `/speckit.doc-update` を実行してから45秒以内にドキュメントを更新できる（AI統合時間を除く）
- **SC-007**: 生成されたドキュメントサイトは、Web サーバーを必要とせずに任意のモダン Web ブラウザでナビゲート可能で読みやすい
- **SC-008**: spec.md からのすべてのセクション（ユーザーシナリオ、要件、成功基準、エッジケース）の95%以上が、生成されたドキュメントに正しく含まれる
- **SC-009**: plan.md と tasks.md が存在する機能について、それらのコンテンツの90%以上がドキュメントに統合される
- **SC-010**: 機能に欠落しているファイル（例：plan.md がない）がある場合でも、ドキュメント更新が成功し、利用可能なコンテンツを含み、欠落セクションに適切な注記が表示される
- **SC-011**: 前回の更新以降に変更されていない機能について、システムが再処理をスキップし、更新サマリーに正確な変更/未変更の件数が表示される

#### インストールと統合

- **SC-013**: 新しい spec-kit プロジェクトでのインストールが10秒以内に正常に完了する
- **SC-014**: ユーザーはインストール直後に追加設定なしで Claude Code で `/speckit.doc-init` と `/speckit.doc-update` を実行できる
- **SC-015**: インストールされた2つのコマンド定義が Claude Code のコマンドリストに正しく表示される

#### 高度な機能（将来のフェーズ）

- **SC-016**: すべての機能からのエンティティフィールドと API エンドポイントの95%が、統合されたドキュメントに正しく含まれる（P2）
- **SC-017**: エンティティの進化が少なくとも3つの機能にわたって正確に追跡され、何がいつ変更されたかを示す変更履歴が表示される（P2）
- **SC-018**: enduser ドキュメントは、技術的実装の詳細（plan.md のアーキテクチャセクション、tasks.md）を100%除外する（P3）
- **SC-019**: developer ドキュメントは、実装ステータスに関係なく、API エンドポイントとデータモデルエンティティを100%含む（P3）
- **SC-020**: 破壊的変更は、エンティティまたは API 定義が互換性のない方法で変更された場合の少なくとも90%で正しく識別され、フラグ付けされる（P3）
- **SC-021**: システムは、標準的なケース（マージ済み、ブランチが存在、ブランチなし）の100%で、git ブランチ状態から機能の実装ステータスを正しく決定する（P3）

## スコープ境界 *(オプション)*

**スコープ内（フェーズ1 - MVP）**:
- `/speckit.doc-init` コマンド：ドキュメントプロジェクトの初期化
  - Sphinx および MkDocs のサポート（`--type` 引数で選択）
  - インタラクティブな設定収集（プロジェクト名、著者、バージョン）
  - 標準的なディレクトリ構造とビルド可能な設定ファイルの生成
  - 既存 `docs/` ディレクトリの上書き確認
- `/speckit.doc-update` コマンド：spec-kit 仕様からのドキュメント更新
  - markdown ファイル解析（spec.md、plan.md、tasks.md）
  - Sphinx（.md with MyST）および MkDocs（.md）形式でのドキュメントページ生成
  - 機能ページの自動生成と目次への追加
  - インクリメンタル更新（変更されたファイルのみを再処理）
  - 欠落ファイルの適切な処理と注記
- 既存の spec-kit プロジェクトへの拡張機能としてのインストール
- Claude Code AI エージェントのサポート
- 機能ディレクトリの番号付け（001、002、003）による時系列順序の維持

**スコープ内（フェーズ2 - 高度な統合）**:
- エンティティ統合と競合解決のための LLM API を使用した AI 駆動の統合
- 複数の data-model.md ファイルからのエンティティ定義の統合
- 複数の機能の contracts/ ディレクトリからの API 仕様のマージ
- 統合されたコンテンツへの機能トレーサビリティ注釈
- 競合する情報の検出と解決（最新優先戦略）

**スコープ内（フェーズ3 - 高度な機能）**:
- 対象者別フィルタリング（enduser、developer、contributor）
- git ブランチステータスからの実装ステータス検出
- 機能間のバージョン履歴追跡
- 破壊的変更の自動検出とフラグ付け

**スコープ外（将来のフェーズ）**:
- アンインストールコマンド（`speckit-docs uninstall`） - MVP範囲外。少数のファイルなので手動削除で十分。本家spec-kitも提供していない
- 専用アップグレードコマンド - `speckit-docs install --force`で代替可能（本家spec-kitの`specify init --here --force`パターン）
- 他のドキュメントジェネレータ（Docusaurus、VitePress）のサポート - 将来検討
- 他の AI エージェント（GitHub Copilot、Gemini、Cursor）のサポート - 将来検討
- インタラクティブなドキュメント機能（検索、フィルタリング、ライブ例） - 将来検討
- 多言語ドキュメント生成（i18n） - 将来検討
- ホスティングとデプロイの自動化（GitHub Pages、Netlify） - 将来検討
- カスタムテーマとブランディング - 将来検討
- PDF と ePub エクスポート - 将来検討
- API ドキュメントテスト（実行中の API に対するコントラクトの検証） - 将来検討
- ドキュメントのバージョン管理（複数のプロダクトバージョンのドキュメントの維持） - 将来検討

## 前提条件 *(オプション)*

### フェーズ1（MVP）の前提条件

1. **spec-kit プロジェクト**: ユーザーは有効な spec-kit プロジェクト（`.specify/` と `.claude/` ディレクトリを持つ）を持っている
2. **仕様フォーマット**: ユーザーは、期待されるセクション見出しを持つ spec.md、plan.md、tasks.md の標準 spec-kit テンプレートに従う
3. **機能番号付け**: 機能は順番に番号付けされ（001、002、003）、番号は時系列順を反映する
4. **AI エージェントのコンテキスト**: Claude Code はコマンド定義の scripts: frontmatter 経由でシェルスクリプトを実行できる
5. **markdown 規則**: markdown ファイルは GitHub Flavored Markdown 拡張を含む標準 CommonMark 構文を使用する
6. **プロジェクト構造**: spec-kit プロジェクトは、機能ディレクトリを含む `specs/` を持つ標準構造に従う
7. **コマンドの可用性**: ユーザーは環境で必要な依存関係（Python 3.11+、Sphinxの場合：sphinx + myst-parser、MkDocsの場合：mkdocs）を利用可能、またはインストールできる
7a. **specify-cli依存関係**: spec-kit-docsは`specify-cli`に依存し、pyproject.tomlでGit URL直接指定（`specify-cli @ git+https://github.com/github/spec-kit.git`）を使用する。specify-cliは公開リポジトリであり、通常のpip/uvインストールで取得可能
8. **ファイルシステムアクセス**: ツールは `.specify/` ディレクトリへの読み取りアクセスと `docs/` ディレクトリへの書き込みアクセスを持つ
9. **ネットワークアクセス**: インストールは PyPI からパッケージをダウンロードできる
10. **合理的な規模**: ほとんどのプロジェクトは1-20機能を持つ；50以上の機能の最適化は便利な追加機能
11. **言語**: 仕様は主に日本語または英語で書かれる；多言語サポートは将来の作業
12. **Git 使用**: プロジェクトは git リポジトリである必要がある（インクリメンタル更新での変更検出に git diff を使用）

### フェーズ2以降の追加前提条件

13. **Git ブランチング**: プロジェクトは標準ブランチング（機能ブランチが main にマージ）で git を使用する（実装ステータス検出に必要）
14. **LLM アクセス**: ユーザーは、十分なレート制限を持つ統合機能用の LLM API（Claude、GPT-4）へのアクセスを持つ（AI 駆動の統合に必要）
15. **data-model.md と contracts/**: 高度な統合機能を使用する場合、機能は data-model.md や contracts/ ディレクトリを含む
16. **一貫したエンティティ命名**: 機能間で統合されるエンティティは一貫した命名を使用する（例：User、user_entity ではなく User）

## 非機能要件 *(オプション)*

### フェーズ1（MVP）

- **パフォーマンス**:
  - `/speckit.doc-init` は30秒以内に完了する（対話的入力時間を除く）
  - `/speckit.doc-update` は、最大10機能のプロジェクトで45秒以内に完了する（フル更新時）
  - インクリメンタル更新により、変更されていない機能の再処理を回避し、以下の基準を満たす：
    - 1機能のみ変更された場合、更新時間は5秒以内（フル更新比で約90%削減、SC-008）
    - 変更されていない機能のファイル読み取り・解析をスキップ
    - Git diff検出のオーバーヘッドは1秒以内
- **信頼性**:
  - システムは不正な markdown を適切に処理し、他のファイルの処理を継続し、特定のエラーを報告する
  - 欠落しているファイル（plan.md、tasks.md）がある場合でも処理を継続
  - `speckit-docs install` コマンドはベストエフォート方式で動作し、エラー発生時もそれまでにコピーされたファイルは残す（spec-kitの`specify init --here`パターンと一貫）。ユーザーは手動で修正するか、問題解決後に再実行可能
- **使いやすさ**:
  - インストールは手動設定なしで単一コマンドを必要とする
  - `/speckit.doc-init` はインタラクティブプロンプトで設定を収集し、手動での設定ファイル編集を不要にする
  - `/speckit.doc-update` は単一のコマンドですべての機能を更新する
  - 明確なエラーメッセージと次のステップの提案を提供
- **互換性**:
  - spec-kit 0.0.19+ および Python 3.11+ で動作する
  - Sphinx 7.0+ および myst-parser 2.0+（Sphinx使用時）
  - MkDocs 1.5+（MkDocs使用時）をサポート
- **保守性**:
  - プラグインアーキテクチャにより、spec-kit コアの変更を必要とせずに更新が可能
  - 2つの独立したコマンド（`doc-init` と `doc-update`）により、各機能を個別に保守可能
- **拡張性**:
  - アーキテクチャは、将来のリリースで新しいドキュメントジェネレータ（Docusaurus、VitePress）の追加をサポート
  - 各ドキュメントツール（Sphinx、MkDocs）は独立したモジュールとして実装され、新しいツールの追加が容易

### フェーズ2以降

- **パフォーマンス（高度な統合）**:
  - LLM API を使用したエンティティ統合は、5機能あたり追加30秒以内
  - 並列処理により複数機能の API 統合を高速化
- **拡張性（AI エージェント）**:
  - 他の AI エージェント（GitHub Copilot、Gemini、Cursor）のサポート追加が可能
