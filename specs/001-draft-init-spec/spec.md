# 機能仕様書: spec-kit-docs - AI駆動型ドキュメント生成システム

**機能ブランチ**: `001-draft-init-spec`
**作成日**: 2025-10-12
**ステータス**: ドラフト
**入力**: ユーザー記述: "draft/init-spec.md を確認し、日本語で要件定義を行ってください"

## Clarifications

### Session 2025-10-12

- Q: `/speckit.doc-init` で初期化されるドキュメント構造は、どのディレクトリ階層を生成すべきですか？ → A: 包括的な構造（`docs/features/`（機能ページ）+ `docs/guides/`（ガイド）+ `docs/api/`（API リファレンス）+ `docs/architecture/`（アーキテクチャ））、ただし5機能以下の小規模プロジェクトはフラット構造も可能
- Q: `/speckit.doc-update` のインクリメンタル更新で、「変更されたファイル」をどのように検出しますか？ → A: Git の変更履歴を使用（git diff で前回のコミットから変更されたファイルを検出）
- Q: plan.md や tasks.md が欠落している場合、生成されるドキュメントにどのような形式で注記を表示しますか？ → A: 視覚的に明確なアドモニション（MyST構文の ` ```{note}` や MkDocs の `!!! note` を使用）
- Q: `docs/features/` 内の機能ページファイルは、どのような命名規則にしますか？ → A: 説明的な名前のみ（`user-auth.md`, `api-integration.md`、番号なし）
- Q: 「小規模プロジェクト」としてフラット構造を使用する判定基準は、機能数がいくつ以下ですか？ → A: 5機能以下
- Q: SphinxでreStructuredText (.rst) とMarkdown (.md) のどちらをデフォルト形式にしますか？ → A: Markdown (.md) + myst-parser をデフォルトにする。理由：(1) spec-kitのすべてのソースファイル（spec.md、plan.md、tasks.md）がMarkdownであり、フォーマット統一により変換ロジックが不要、(2) ユーザーの学習コストを削減（reStructuredText構文の習得が不要）、(3) 生成後のドキュメントをユーザーが手動編集する際の利便性向上、(4) MyST Markdownは業界標準となりつつあり、Sphinxのほぼ全機能をサポート

### Session 2025-10-12 (Correction)

- **修正1**: spec-kit の公式仕様に基づき、機能仕様ディレクトリの場所を `.specify/specs/` から `specs/` (ルート直下) に修正しました。spec-kit の `scripts/bash/create-new-feature.sh` は `SPECS_DIR="$REPO_ROOT/specs"` を使用しており、`.specify/` は spec-kit 自身の内部ディレクトリ（scripts, templates, memory）であり、ユーザーの機能仕様を配置する場所ではありません。
- **修正2**: Sphinx のデフォルトファイル形式の不整合を解消しました。Session 2025-10-12 の決定（「Markdown (.md) + myst-parser をデフォルトにする」）に基づき、`index.rst` への参照をすべて `index.md` に変更し、Sphinx で生成されるすべてのファイルが Markdown 形式（.md）であることを明確化しました。これにより、spec-kit のソースファイル（spec.md、plan.md、tasks.md）との形式統一が実現されます。

### Session 2025-10-12 (Architecture Clarifications)

- Q: 対話的設定収集（プロジェクト名、著者名等）の責務は、AI エージェント（Claude Code）と Python スクリプト（doc_init.py）のどちらが担うべきか？ → A: オプション A - AI エージェント（Claude Code）が対話的に設定を収集し、スクリプト（doc_init.py）は引数のみを受け取る非対話的実行。理由：(1) Python スクリプトの input() は CI/CD などの非対話的環境で EOFError を起こす、(2) spec-kit の他のコマンド（/speckit.specify, /speckit.plan）と一貫性が保たれる、(3) 拡張性とテスト容易性が向上する
- Q: `.claude/commands/speckit.doc-init.md` コマンド定義の具体的な役割は？ → A: オプション A - コマンド定義は、対話的質問→情報収集→引数構築→スクリプト呼び出し→結果フィードバックの一連のプロンプトを記述。理由：(1) spec-kit の他のコマンド定義と一貫したパターン、(2) Claude Code が自然言語プロンプトからタスクを実行できる、(3) エラーハンドリングとユーザーフィードバックを AI エージェントが担当
- Q: 既存 `docs/` ディレクトリの上書き確認は、AI エージェントとスクリプトのどちらが担うべきか？ → A: オプション A - AI エージェントが事前に `docs/` の存在を確認し、存在する場合はユーザーに上書き確認を取り、確認が取れた場合のみ `--force` フラグ付きでスクリプトを実行。理由：(1) 非対話的環境でスクリプトが動作可能、(2) ユーザーとの対話は AI エージェントが担当するアーキテクチャに一貫、(3) スクリプトは `--force` の有無で動作を制御できテスト容易
- Q: MkDocs 初期化時のデフォルト値（サイト名、リポジトリURL）は？ → A: オプション A - サイト名：プロジェクト名と同じ、リポジトリURL：Git remote origin URL（取得できない場合は空文字列）。理由：(1) Sphinx との一貫性、(2) Git から自動取得可能な情報を活用、(3) 必須でない項目（リポジトリURL）は空でも問題なし
- Q: ディレクトリ構造決定（フラット vs 包括的）の機能数検出タイミングは？ → A: オプション A（自動移行付き）- 初期化時に現在の機能数を検出して構造を決定し、さらに `/doc-update` 実行時にも機能数を再チェックして、フラット構造から包括的構造への移行が必要な場合（機能数が6以上になった場合）は自動的に移行する。理由：(1) プロジェクトの成長に自動的に適応、(2) 小規模プロジェクトは常にシンプルなフラット構造で開始、(3) 逆方向の移行（包括的→フラット）は行わず、破壊的変更を避ける

### Session 2025-10-13 (Install Command Clarifications)

- Q: pyproject.tomlでのspecify-cliの依存関係指定方法は？ → A: オプション A - Git URL直接指定（`dependencies = ["specify-cli @ git+https://github.com/github/spec-kit.git"]`）。理由：specify-cliは公開リポジトリであり、Git URL直接指定で問題なくインストール可能

### Session 2025-10-13 (CLI Design Clarifications)

- Q: CLIツールの設計：どのようなコマンド構造にすべきか（独立したCLIツール vs spec-kitとの統合）？ → A: オプション B - `speckit-docs`コマンドを`specify`コマンドと統合し、`specify add-docs`のようなサブコマンドとして実装する。理由：(1) spec-kitエコシステムの一貫性を最大化、(2) ユーザーの学習コストを削減（新しいCLIツールを覚える必要がない）、(3) `/speckit.doc-init`と`/speckit.doc-update`のスラッシュコマンドは完全に維持される（インストール方法のみが統合され、使用方法は変わらない）
- Q: 配布方法：PyPIへの公開も検討すべきか、それともGitHubのみで十分か？ → A: オプション A - GitHubのみで配布（`uv tool install speckit-docs --from git+https://github.com/drillan/spec-kit-docs.git`）、PyPI公開は将来のフェーズで検討。理由：(1) MVP段階では開発とリリースプロセスをシンプルに保つ、(2) spec-kit自体もGitHubから配布されており、ユーザーは既にこのパターンに慣れている、(3) PyPI公開は追加の保守負担（バージョン管理、リリースプロセス、パッケージメタデータ）があり初期段階では不要
- Q: spec-kitとの統合方法：spec-kitリポジトリに統合すべきか、独立したリポジトリで開発すべきか？ → A: オプション A - 独立したCLIツールとして実装し、spec-kitの`specify`コマンドとは別に`speckit-docs install`を提供（spec-kitとの統合は名目上のみ）。理由：(1) spec-kitリポジトリへのPRは承認が必要で開発スピードが遅くなる可能性がある、(2) 独立したリポジトリで開発することで、spec-kit-docs固有の機能やリリースサイクルを柔軟に管理できる、(3) コマンド体系はspec-kitと一貫性を保ちながら（`specify add-docs`のようなパターン）、実装は独立して進められる
- Q: スラッシュコマンドの生成：CLIツールがどのようにして.claude/commands/にスラッシュコマンドを配置すべきか？ → A: オプション A - `speckit-docs install`コマンドがPythonパッケージ内のテンプレートファイル（`src/speckit_docs/commands/speckit.doc-init.md`, `speckit.doc-update.md`）をユーザープロジェクトの`.claude/commands/`にコピーする。理由：(1) spec-kitの`specify init`と同じパターンに従い実装がシンプル、(2) ユーザーにとって透明性が高く、コピー後のファイルをカスタマイズ可能、(3) importlib.resourcesでパッケージ内テンプレートにアクセスするためオフライン環境でも動作、(4) `--force`オプションで上書き更新が可能、(5) `/speckit.doc-init`と`/speckit.doc-update`としてClaude Codeに認識され、spec-kitの他のコマンドとの命名規則の一貫性を保つ
- Q: 既存プロジェクトへのインストール：`--here`フラグのようなオプションは必要か？ → A: オプション A - カレントディレクトリに自動的にインストール（`cd my-project && speckit-docs install`）、明示的なディレクトリ指定は不要。理由：(1) spec-kit-docsは既存のspec-kitプロジェクトに拡張機能を追加するツールであり、ユーザーは既にプロジェクトルートにいることが前提、(2) 新しいディレクトリを作成することはなく常に既存プロジェクトへの追加なので`--here`フラグも不要、(3) コマンドがシンプルになり使いやすさが向上
- Q: 既存ファイル（.claude/commands/や.specify/scripts/）が存在する場合の動作は？ → A: オプション C - インタラクティブ確認（全体）+ --forceで確認スキップ。理由：(1) spec-kitの本家`specify init --here`パターンと一貫性がある、(2) デフォルトは安全（確認を求める）だが、自動化時は`--force`で対応可能、(3) ユーザーの学習コストを削減
- Q: コマンドテンプレート（doc-init.md, doc-update.md）の配置場所とインストール方法は？ → A: オプション A - `src/speckit_docs/commands/` に配置し、importlib.resourcesでアクセス。理由：(1) 少数のファイル（2つのコマンド定義 + スクリプト）なので、Pythonパッケージに含めるのが適切、(2) オフライン環境でも動作（pip install後にネットワーク不要）、(3) Python標準のパッケージングベストプラクティスに準拠、(4) spec-kitのGitHubダウンロード方式は大量ファイル配布向けでspec-kit-docsには過剰
- Q: インストール失敗時の動作は？ → A: オプション B - ベストエフォート（エラー発生時もそこまでのファイルは残す）。理由：(1) spec-kitの`specify init --here`パターンと一貫性がある（既存ディレクトリへの追加時は部分的な状態を残す）、(2) spec-kit-docsは既存プロジェクトにファイルを追加するだけなので、プロジェクト全体を壊すリスクは低い、(3) ユーザーが手動で修正可能（失敗したファイルを削除して再実行）、(4) トランザクション機構は複雑でMVP範囲を超える
- Q: アンインストール・アップグレード機能は必要か？ → A: オプション D - 機能は提供しない（MVP範囲外）。理由：(1) 本家spec-kitもuninstall/upgrade機能を提供していない（一貫性）、(2) MVPの焦点は「ドキュメント生成」であり、ライフサイクル管理は二次的、(3) 少数のファイルなので手動削除も容易、(4) アップグレードは`speckit-docs install --force`で代替可能、(5) 将来必要になれば追加可能

### Session 2025-10-13 (CLI Framework Re-evaluation)

- Q: CLIフレームワーク選択の再検討：本家spec-kitが**typer**を使用しており、spec-kit-docsも`specify-cli`に依存するため既にtyperが依存ツリーに存在している。Constitution（憲章）のCore Principle I「spec-kit Integration First」に基づき、argparseからtyperに変更すべきか？ → A: **Option B (typerに変更)** - 本家spec-kitとの一貫性を最優先する。既にtyperに間接依存しており、追加の依存関係はない。ユーザーは一貫したCLI体験を得られ、型ヒントのネイティブサポートも得られる（C006: 堅牢コード品質に準拠）。エラーハンドリングの制御は、本家spec-kitが既に実現しているように、typerでも可能。理由：(1) **Core Principle I (spec-kit Integration First)への準拠** - 「spec-kitの標準パターンと完全に一貫していなければならない」という憲章要件を満たす、(2) **実質的な追加依存なし** - specify-cli経由で既にtyperに間接依存しているため、新しい外部依存は増えない、(3) **型ヒントのネイティブサポート** - Python 3.11+の型ヒント（`int`, `str`, `bool`等）を直接使用でき、mypy互換（C006準拠）、(4) **DRY原則** - 本家spec-kitのtyperパターン（`typer.confirm()`、`typer.Option()`等）を再利用できる（C012準拠）、(5) **Phase 2計画との整合** - research.mdでPhase 2に計画されている「specify-cliからStepTracker/console再利用」がtyper前提であり、一貫性が保たれる

### Session 2025-10-13 (Command Naming & Installation Method)

- Q: コマンド名の標準化：仕様では `/speckit.doc-init` だが README.md では `/doc-init` となっている不整合を解決すべきか？ → A: **Option A (長い形式)** - `/speckit.doc-init`, `/speckit.doc-update` に統一する。理由：spec-kitの付属物という扱いをコマンド名に含めることで、spec-kit エコシステムとの統合を明確にし、他のspec-kitコマンド（`/speckit.specify`, `/speckit.plan`）との命名規則の一貫性を保つ
- Q: インストールコマンドの推奨方法：README.mdに両方（CLIコマンドとPython API呼び出し）が記載されているが、どちらを推奨すべきか？ → A: **Option A (CLIコマンド)** - `speckit-docs install` を推奨する。理由：(1) 仕様（FR-021a, FR-022, FR-023）が前提としている標準的な方法、(2) ユーザーにとってシンプルで覚えやすい、(3) spec-kitの`specify init`パターンと一貫性がある、(4) Python API呼び出しはアドバンスドユーザー向けのフォールバックとして残す

### Session 2025-10-13 (Code Quality & Architecture Details)

- Q: ruffの設定：デフォルト設定のみ vs 一貫性のあるプリセット vs 厳格なルールセット？ → A: **Option B (一貫性のあるプリセット)** - `pyproject.toml`で`select = ["E", "F", "W", "I"]` + `line-length = 100` + `target-version = "py311"`を指定。理由：(1) エラー（E）、致命的エラー（F）、警告（W）、import順序（I）の基本ルールでツールプロジェクトには十分、(2) line-length=100はPython標準（PEP 8の88-100推奨）に準拠、(3) target-version指定により型ヒント構文の互換性を保証、(4) 過度に厳格なルール（docstring必須等）は開発速度を低下させる可能性を回避
- Q: CI/CD環境でのruffエラー処理：Fail-fast vs Warning-only vs ブランチ別動作？ → A: **CI/CDパイプラインは構築しない** - ローカル開発環境でのみruffを手動実行する。理由：MVP段階ではCI/CD構築はスコープ外、開発者がローカルで`uv run ruff check .`を実行して品質を維持
- Q: BaseGenerator抽象クラスのインターフェース：最小（1メソッド）vs 段階的（4メソッド）vs 詳細（7-8メソッド）？ → A: **Option B (段階的インターフェース)** - `initialize()`, `generate_feature_page(feature)`, `update_navigation()`, `validate()`の4メソッド。理由：(1) 単一責任原則に従い各メソッドが明確な役割を持つ、(2) initialize→個別ページ生成→ナビゲーション更新→検証と処理が分離されテスト容易、(3) 将来のDocusaurus等追加時も同じパターンを適用可能、(4) 最小インターフェースより構造化され、詳細インターフェースより保守しやすい
- Q: specify-cli（本家spec-kit）からの再利用範囲：MVP段階でStepTracker/consoleも再利用 vs typerパターンのみ？ → A: **Option A (MVP範囲は最小限)** - typerの基本パターン（`typer.confirm()`, `typer.Option()`等）のみ再利用、StepTracker/consoleは将来フェーズ。理由：(1) MVPの焦点は「ドキュメント生成」でありCLI体験の高度化は二次的、(2) specify-cliコード調査コストをMVPで回避し開発スピード優先、(3) Phase 2でStepTracker再利用を計画済み（research.md記載）なので段階的アプローチが適切、(4) typerパターン再利用だけでもDRY原則とC012（一貫性）を満たす
- Q: ログレベルとエラー出力の戦略：エラーのみ vs 構造化ログ（INFO/DEBUG/ERROR） vs 詳細ログ（常にDEBUG）？ → A: **Option B (構造化ログ)** - 標準出力にINFO以上、`--verbose`でDEBUG、`--quiet`でERRORのみ。理由：(1) ユーザーは通常実行で適切な進捗情報を得られる（「3機能を処理中...」等）、(2) `--verbose`フラグでトラブルシューティング時に詳細情報取得可能、(3) `--quiet`でCIやスクリプト組み込み時にエラーのみ出力、(4) Pythonの標準logging模块を使用し保守性が高い、(5) 本家spec-kitの他コマンドとの一貫性

### Session 2025-10-14 (Installation Method Standardization)

- Q: インストール方法の標準化：spec-kitと同様に`uv tool install`方式を推奨インストール方法とすべきか、それとも`uv pip install -e`(編集可能インストール)を維持すべきか？ → A: **Option A (uv tool install)** - `uv tool install speckit-docs --from git+https://github.com/drillan/spec-kit-docs.git`を標準インストール方法とする。理由：(1) **Core Principle I (spec-kit Integration First)への準拠** - spec-kitと同じインストールパターンでユーザー体験を統一、(2) **ツール分離** - `uv tool`は独立したCLIツールのインストール専用で、プロジェクト環境を汚染しない、(3) **シンプルな依存関係管理** - グローバルツールとして管理され、複数プロジェクトから利用可能、(4) **本家spec-kitとの対称性** - `uv tool install specify-cli`と`uv tool install speckit-docs`で対になる。開発者向けのコントリビューション時には`uv pip install -e .`も引き続きサポートするが、エンドユーザー向けドキュメント（README.md）では`uv tool install`を唯一の推奨方法として記載する

### Session 2025-10-15 (Dependency Auto-Installation)

- Q: 依存関係の自動インストールを実装すべきか？ → A: **条件付き自動インストール** - `pyproject.toml`が存在し`uv`コマンドが利用可能な場合、ユーザー承認後に`uv add`を実行する。条件が満たされない場合は、代替方法（手動インストールまたはspec-kitワークフロー）を明確に提示する。理由：(1) 95%以上のspec-kitユーザーがこの条件を満たし、ワンステップでセットアップ完了、(2) spec-kitの非侵襲的哲学を維持（ユーザー承認必須）、(3) SC-002「追加設定なしでビルド成功」を実現
- Q: CI/CD環境での非対話的実行をどのように制御すべきか？ → A: **`--auto-install`と`--no-install`の両フラグを提供** - `--auto-install`指定時は確認なしで自動インストール、`--no-install`指定時は依存関係チェック自体をスキップ、デフォルトは対話的確認。理由：(1) CI/CDで完全自動化が必要な場合に対応、(2) 依存関係を手動管理したい場合の選択肢を提供、(3) デフォルトは安全性優先（ユーザー承認必須）
- Q: `uv add`失敗時のフォールバック戦略は？ → A: **3段階の代替方法を明確に提示** - (1) 失敗理由の説明、(2) 方法1: 手動インストールコマンド（利用可能なパッケージマネージャーを自動検出：uv, pip, poetry等）、(3) 方法2: spec-kitワークフロー（`/speckit.specify` → `/speckit.plan` → `/speckit.tasks` → `/speckit.implement`）の手順とその利点（依存関係管理がplan.md/tasks.mdに記録される）を説明。理由：(1) spec-kitエコシステムを強化、(2) すべてのユーザーに対応可能な選択肢を提供、(3) 依存関係の履歴が残るという価値を提示
- Q: ユーザー承認プロンプトに含めるべき情報は？ → A: **包括的情報提示** - (1) インストール予定のパッケージリスト（バージョン制約含む）、(2) 実行されるコマンド（`uv add sphinx>=7.0 myst-parser>=2.0`）、(3) `pyproject.toml`が変更されることの警告、(4) 承認プロンプト。理由：(1) ユーザーが何が起こるかを完全に理解した上で承認できる、(2) インフォームドコンセントの原則に準拠、(3) 予期しない結果を防ぐ
- Q: 成功基準SC-002をどのように修正すべきか？ → A: **条件を明記し、新しい成功基準SC-002bを追加** - SC-002を「必要な依存関係がインストールされている環境、または自動インストールが成功した環境で、追加設定なしでビルドコマンドが成功する」に修正。SC-002b新設：「pyproject.tomlとuvが利用可能な環境で、ユーザーが依存関係インストールを承認した場合、90%以上のケースで`uv add`が成功し、その後のビルドコマンドが成功する（残り10%はネットワークエラー等の外部要因）」。理由：(1) SC-002の曖昧性を解消、(2) 自動インストール機能の成功率を明確に定義、(3) 現実的な基準（ネットワークエラー等の外部要因を許容）

### Session 2025-10-16 (Dependency Placement Strategy)

- Q: `uv add` で依存関係を追加する際、`[project.optional-dependencies.docs]`（pip/poetry/uv互換）と `[dependency-groups.docs]`（uvネイティブ）のどちらを使用すべきですか？ → A: **Option B - ユーザーに選択させる（デフォルト: `optional-dependencies`）** - `/doc-init` 実行時にユーザーに「optional-dependencies（推奨、広い互換性）」または「dependency-groups（uvネイティブ、モダン）」を選択可能にする。理由：(1) ユーザーの環境やワークフローに応じた柔軟性を提供、(2) pip/poetryユーザーには互換性のあるoptional-dependenciesを推奨、(3) uvネイティブユーザーにはより現代的なdependency-groupsを提供、(4) spec-kitの非侵襲的哲学（ユーザーに選択権を与える）に準拠、(5) アーキテクチャ的に正しい（ドキュメント生成ツールはメインアプリケーションの実行に不要であり、開発・ドキュメント専用の依存関係として分離すべき）

### Session 2025-10-16 (LLM-Driven Document Generation)

- **現状の課題認識**: `/speckit.doc-update` コマンドは、specsフォルダのファイル（spec.md、plan.md、tasks.md）を単純にJinja2テンプレートに挿入してコピーしているだけであり、エンドユーザー向けの読みやすさや理解しやすさを考慮していない。生成されるドキュメントは、開発者向けの技術的な仕様書をそのまま表示しているため、プロジェクトのエンドユーザー（顧客、ステークホルダー、非技術者）にとって難解で親しみにくい
- Q: LLMを統合してユーザーフレンドリーなドキュメントを生成すべきか？ → A: **Yes - LLMによるドキュメント変換を実装する** - `/speckit.doc-update`実行時に、spec.md等のコンテンツをそのままコピーするのではなく、LLMを使用してユーザーフレンドリーな形式に変換する。理由：(1) **エンドユーザー価値の最大化** - ドキュメントは開発者だけでなく、顧客、プロダクトマネージャー、営業チーム、サポートチームなど多様な読者を対象とするため、技術的詳細を適切に要約・翻訳することで価値が向上、(2) **spec-kitの哲学との整合** - spec-kitは「AI駆動型ワークフロー」を前提としており、ドキュメント生成にもAIを活用することは自然な拡張、(3) **差別化要因** - 単なるファイルコピーツールではなく、「インテリジェントなドキュメント生成ツール」として位置づけることで、本ツールの独自価値を明確化
- Q: LLM変換の具体的な処理内容は？ → A: **段階的な変換戦略** - (1) **Phase 1 (MVP)**: spec.mdのFunctional Requirementsセクションを「機能概要」として要約（技術的な"MUST"表現を自然な文章に変換、例：「FR-001: System MUST allow users to...」→「ユーザーは...できます」）、(2) **Phase 2**: plan.mdのアーキテクチャセクションから「技術的な意思決定の背景」を抽出して分かりやすく説明、(3) **Phase 3**: tasks.mdから「実装状況の概要」を生成（タスクの詳細ではなく、「この機能は80%完了しています」といった進捗サマリー）。各フェーズで、元のコンテンツへのリンクを提供し、技術者が詳細にアクセスできるようにする
- Q: LLM変換の責務分担は？（ANTHROPIC_API_KEYの扱い） → A: **Option B - AIエージェント（Claude Code）がLLM変換を実行し、変換済みコンテンツをスクリプトに渡す** - Claude Code環境では、ユーザーはAPIキーを意識する必要がない。理由：(1) **既存アーキテクチャパターンとの一貫性** - 「AIエージェント（Claude Code）が対話・検証・LLM処理を担当し、スクリプト（doc_update.py）は非対話的に実行」という責務分担に従う、(2) **ユーザー体験の簡素化** - Claude Code上でスラッシュコマンドを実行する場合、バックグラウンドでClaude APIと通信するため、エンドユーザーがANTHROPIC_API_KEYを設定・管理する必要がない、(3) **テスト容易性** - AIエージェントとスクリプトの境界が明確になり、スクリプトは変換済みコンテンツを受け取るだけなので単体テストが容易、(4) **将来の拡張性** - CLI直接実行時（Claude Code外）の動作は、コマンド定義（.claude/commands/speckit.doc-update.md）で制御可能
- Q: キャッシュの永続化形式は？ → A: **Option B - `.claude/.cache/llm-transforms.json`（JSON形式）** - LLM変換結果を永続化し、Claude Code再起動後も再利用可能にする。理由：(1) **人間が読みやすい** - JSONは構造化されており、デバッグ時に内容を容易に確認できる、(2) **標準ライブラリで処理可能** - Pythonの`json`モジュールで簡単に読み書きでき、外部依存なし、(3) **構造化データの格納** - 機能ID、元のコンテンツハッシュ（MD5）、変換結果、タイムスタンプ、Gitコミットハッシュなどを体系的に保存、(4) **適切な配置** - `.claude/`ディレクトリはClaude Code専用であり、ツール固有のキャッシュ配置として自然
- Q: キャッシュ無効化判定のハッシュアルゴリズムは？ → A: **Option A - MD5ハッシュ** - キャッシュの無効化判定のみに使用し、暗号学的強度は不要。理由：(1) **高速性** - MD5はSHA256より計算が高速で、大規模プロジェクト（数十機能）でもパフォーマンス影響が小さい、(2) **十分な精度** - キャッシュ無効化判定には衝突回避が重要であり、MD5の衝突確率は実用上問題ない、(3) **標準ライブラリサポート** - Pythonの`hashlib.md5()`で標準サポートされ、外部依存なし、(4) **ハッシュ値の長さ** - MD5は32文字（SHA256は64文字）で、JSONファイルが肥大化しない
- Q: コスト・パフォーマンス懸念への対応は？ → A: **実用的な制約を設ける** - (1) **デフォルト有効化とオプトアウト**: LLM変換をデフォルトで実行し、無効化したいユーザーは`--no-llm-transform`フラグを使用、(2) **永続的キャッシング**: `.claude/.cache/llm-transforms.json`に変換結果を保存し、変更されていないファイルは再変換しない（Git diffベースのインクリメンタル更新を活用）、(3) **コンテンツサイズ制限**: プロンプトサイズの上限を設定（例：1機能あたり最大10,000トークン）し、超過した場合は明確なエラーを返してプロセスを中断
- Q: エラーハンドリング戦略は？ → A: **明示的なエラー返却（憲章準拠）** - (1) LLM変換失敗時（AIエージェント側のエラー、コンテンツサイズ超過等）は、明確なエラーメッセージを返してプロセスを中断する、(2) LLM生成コンテンツが不適切（空、エラーメッセージ、フォーマット違反）な場合も同様にエラーを返す、(3) **フォールバック動作は行わない** - 憲章違反となるため、失敗時は自動的に単純コピー方式に切り替えず、ユーザーに問題を通知して対処を求める、(4) エラーメッセージには「ファイルパス」「エラー種類」「推奨アクション」を含める（例：「spec.md の Functional Requirements セクションが10,000トークンを超過しています。コンテンツを分割するか、--llm-transformフラグを外してください」）

### Session 2025-10-16 (Default Behavior Change)

- Q: `--llm-transform`をデフォルトの挙動にすべきか？ → A: **Yes - LLM変換をデフォルトで有効化する** - `/speckit.doc-update`実行時、`--llm-transform`フラグがなくてもLLM変換が実行される。理由：(1) **ユーザー価値の最大化** - spec-kit-docsの主要価値提案は「ユーザーフレンドリーなドキュメント生成」であり、デフォルトで有効化することでこの価値を全ユーザーに提供、(2) **AI駆動ツールとしての位置づけ** - spec-kitエコシステムの一部として、AI活用がデフォルトであることは自然、(3) **オプトアウト方式への変更** - 技術的な仕様書をそのまま表示したいユーザーは`--no-llm-transform`フラグで無効化可能（後方互換性とadvanced user向けの制御を提供）

## アーキテクチャと責務分担

spec-kit-docs は、AI エージェント（Claude Code）とバックエンドスクリプトの協調によって動作します。このアーキテクチャは spec-kit の標準パターンに従います。

### AI エージェント（Claude Code）の責務

- ユーザーとの対話的な情報収集（プロジェクト名、著者名、バージョン、言語、ドキュメントツール選択など）
- 入力値の検証とユーザーへのフィードバック
- 既存ファイル（docs/ ディレクトリ）の上書き確認
- **LLM変換処理**（`--llm-transform`フラグ指定時）: spec.md等のコンテンツをユーザーフレンドリーな形式に変換し、変換済みコンテンツを一時ファイルまたはコマンドライン引数としてスクリプトに渡す
- 収集した情報をコマンドライン引数としてスクリプトに渡す
- エラーメッセージの解釈とユーザーへの提示

### バックエンドスクリプトの責務

- コマンドライン引数から設定を受け取る
- 非対話的にドキュメントプロジェクトを生成
- エラーを構造化された形式で返す（終了コードとメッセージ）
- **標準入力（stdin）を使用しない** - すべての設定はコマンドライン引数またはデフォルト値から取得
- ファイルシステム操作（ディレクトリ作成、ファイル生成）
- テンプレートの展開と設定ファイルの生成

### 設計根拠

この責務分担により以下が実現されます：

1. **非対話的環境での実行可能性**: Python スクリプトは CI/CD、バックグラウンドジョブ、自動化ワークフローで EOFError を起こさずに実行可能
2. **テスト容易性**: スクリプトは決定的な入力（コマンドライン引数）を受け取り、単体テストが容易
3. **spec-kit との一貫性**: `/speckit.specify`、`/speckit.plan` などの他のコマンドと同じパターンに従う
4. **拡張性**: 将来的に他の AI エージェント（GitHub Copilot、Gemini など）をサポートする際も、スクリプト側の変更は不要

## ユーザーシナリオとテスト *(必須)*

### ユーザーストーリー1: ドキュメントプロジェクトの初期化 (優先度: P1) 🎯 MVP

**目的**: spec-kitユーザーが、単一コマンドでドキュメントプロジェクトを初期化し、Sphinx または MkDocs のいずれかを選択し、インタラクティブに設定を構成できるようにすることで、手動でディレクトリを作成したり設定ファイルを編集したりすることなく、プロジェクトに適したドキュメント基盤を確立できるようにします。

**この優先度の理由**: ドキュメント生成の前提条件です。初期化がなければ、更新するドキュメント構造が存在しません。これはワークフローの最初のステップです。

**独立テスト**: ユーザーが spec-kit プロジェクトで `/speckit.doc-init --type sphinx` を実行します。システムはプロジェクト名、著者名、バージョンを対話的に尋ねます。完了後、`docs/` ディレクトリが作成され、Sphinx の設定ファイル（`conf.py`、`index.md`）と基本構造が含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: 有効な spec-kit プロジェクト（`.specify/` ディレクトリを持つ）、**実行**: ユーザーが `/speckit.doc-init --type sphinx` を実行、**期待結果**: システムが対話的にプロジェクト名、著者名、バージョン、言語を尋ね、回答に基づいて `docs/` に Sphinx プロジェクトを作成し、`conf.py`、`index.md`、`Makefile`、必要なディレクトリ構造を含む

2. **前提条件**: 有効な spec-kit プロジェクト、**実行**: ユーザーが `/speckit.doc-init --type mkdocs` を実行、**期待結果**: システムが対話的に設定を尋ね、`docs/` に MkDocs プロジェクトを作成し、`mkdocs.yml`、`docs/index.md`、必要なディレクトリ構造を含む

3. **前提条件**: spec-kit プロジェクト、**実行**: ユーザーが type 引数なしで `/speckit.doc-init` を実行、**期待結果**: システムが「どのドキュメントツールを使用しますか？ (sphinx/mkdocs)」と尋ね、ユーザーの選択に基づいて初期化を続行

4. **前提条件**: 既に `docs/` ディレクトリが存在するプロジェクト、**実行**: ユーザーが初期化を試みる、**期待結果**: システムが警告を表示:「docs/ ディレクトリは既に存在します。上書きしますか？ (yes/no)」、拒否された場合は既存の構造を保持

5. **前提条件**: spec-kit プロジェクトではないディレクトリ（`.specify/` なし）、**実行**: ユーザーが初期化を試みる、**期待結果**: システムがエラーを表示:「spec-kit プロジェクトではありません。最初に 'specify init' を実行してください。」

6. **前提条件**: 初期化が完了したプロジェクト、**実行**: ユーザーが `docs/` ディレクトリを確認、**期待結果**: 選択したドキュメントツールに応じた標準的なディレクトリ構造、設定ファイル、プレースホルダーコンテンツが含まれ、すぐにビルド可能な状態

---

### ユーザーストーリー2: spec-kit 仕様からのドキュメント更新 (優先度: P1) 🎯 MVP

**目的**: ドキュメントプロジェクトを初期化した spec-kit ユーザーが、`specs/` ディレクトリから最新の仕様情報を明示的にドキュメントに統合できるようにすることで、spec.md、plan.md、tasks.md の変更を手動でコピー＆ペーストすることなく、ドキュメントを最新の状態に保つことができるようにします。

**この優先度の理由**: これは初期化の直接的な続きです。初期化後、ユーザーは実際のコンテンツでドキュメントを埋める必要があります。自動化はせず、ユーザーが制御できるようにします。

**独立テスト**: 3つの機能（001-user-auth、002-api-integration、003-notifications）を持つ spec-kit プロジェクトで `/speckit.doc-init` を実行後、`/speckit.doc-update` を実行します。システムは各機能の spec.md、plan.md、tasks.md から情報を抽出し、ドキュメント構造に統合します。生成されたドキュメントをビルドして、3つの機能すべての情報が含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: `/speckit.doc-init` で初期化された Sphinx プロジェクト、3つの機能（各ディレクトリに spec.md と plan.md を含む）、**実行**: ユーザーが `/speckit.doc-update` を実行、**期待結果**: システムが `docs/features/` に各機能のページを作成し、spec.md からのユーザーストーリーと要件、plan.md からのアーキテクチャ情報を含み、`index.md` の toctree に機能リストを追加

2. **前提条件**: 初期化された MkDocs プロジェクト、機能仕様、**実行**: `/speckit.doc-update` を実行、**期待結果**: システムが `docs/features/*.md` ファイルを作成し、`mkdocs.yml` の nav セクションを更新して新しいページを含める

3. **前提条件**: spec.md のみを持つ機能（plan.md や tasks.md がない）、**実行**: 更新を実行、**期待結果**: システムが利用可能な情報から機能ページを生成し、欠落しているセクションについて「[このセクションはまだ利用できません]」などの注記を表示

4. **前提条件**: `specs/` ディレクトリが空または存在しない、**実行**: ユーザーが更新を試みる、**期待結果**: システムがエラーを表示:「仕様が見つかりません。最初に /speckit.specify を実行して機能仕様を作成してください。」

5. **前提条件**: `docs/` ディレクトリが初期化されていない、**実行**: ユーザーが `/speckit.doc-update` を実行、**期待結果**: システムがエラーを表示:「ドキュメントプロジェクトが見つかりません。最初に /speckit.doc-init を実行してください。」

6. **前提条件**: 前回の更新以降に変更された機能仕様、**実行**: `/speckit.doc-update` を再実行、**期待結果**: システムが変更された機能のページのみを更新し、変更されていないページは保持し、「3つの機能が更新されました、2つは変更なし」などの更新サマリーを表示

---

### ユーザーストーリー3: spec-kit 拡張機能としてのインストール (優先度: P1) 🎯 MVP

**目的**: spec-kit ユーザーが、既存の spec-kit プロジェクトに spec-kit-docs を拡張機能として簡単なコマンドでインストールできるようにすることで、複雑な設定なしに AI エージェント（Claude Code）で `/speckit.doc-init` と `/speckit.doc-update` コマンドにアクセスできるようにします。

**この優先度の理由**: ユーザーはツールを使用する前にインストールできる必要があります。これは他のすべての機能の前提条件です。

**独立テスト**: 既存の spec-kit プロジェクトを持つユーザーが、まず`uv tool install speckit-docs --from git+https://github.com/drillan/spec-kit-docs.git`でCLIツールをインストールし、次にプロジェクトルートで`speckit-docs install`を実行します。インストール後、Claude Code で `/speckit.doc-init` と `/speckit.doc-update` を実行でき、エラーなくコマンドが実行されることを確認します。

**受け入れシナリオ**:

1. **前提条件**: spec-kit プロジェクトとして初期化されたディレクトリ（`.specify/` と `.claude/` ディレクトリを持つ）、**実行**: ユーザーがプロジェクトルートで`speckit-docs install`を実行、**期待結果**: システムが`.claude/commands/`にドキュメントコマンド定義（`doc-init.md`と`doc-update.md`、Pythonパッケージ内の`src/speckit_docs/commands/`からコピー）を追加し、必要なスクリプトを`.specify/scripts/docs/`にコピーし、インストール成功を確認

2. **前提条件**: spec-kit-docs をインストールしたユーザー、**実行**: プロジェクトディレクトリで Claude Code を開き、`/speckit` と入力、**期待結果**: `/speckit.specify`、`/speckit.plan` などと並んで、利用可能なコマンドリストに `/speckit.doc-init` と `/speckit.doc-update` が表示される

3. **前提条件**: spec-kit プロジェクトではないディレクトリ（`.specify/` ディレクトリなし）、**実行**: ユーザーがインストールを試みる、**期待結果**: システムがエラーを表示:「spec-kit プロジェクトではありません。最初に 'specify init' を実行してください。」

4. **前提条件**: 既にインストールされている spec-kit-docs 拡張機能、**実行**: ユーザーが再度インストールを実行、**期待結果**: システムが既存のインストールを検出し、上書き前に確認を求め（spec-kitの`specify init --here`パターンと同様）、拒否された場合はユーザーのカスタマイズを保持。`--force`フラグ指定時は確認をスキップして上書き

---

### ユーザーストーリー4: インテリジェントな複数機能の統合 (優先度: P2)

**目的**: 複数の進化する機能を持つspec-kitユーザーが、エンティティとAPIが時間とともにどのように進化するかを追跡しながら、システムが機能間の情報を自動的に統合できるようにすることで、ドキュメントが機能ごとの断片的なスナップショットではなく、プロダクトの現在の統一された状態を反映するようにします。

**この優先度の理由**: これは単純なファイル連結とこのツールを差別化するものです。AI駆動の統合の真の価値を提供しますが、基本的なドキュメント生成には必須ではありません。

**独立テスト**: 001-coreでUser{id, name, email}を定義し、003-profilesでUser.profile_pictureを追加するプロジェクトを作成します。生成されたドキュメントは、導入バージョンでマークされたすべてのフィールドを持つ単一の統合Userエンティティを示します。ドキュメントに2つの別々の矛盾するUser定義が表示されないことを確認します。

**受け入れシナリオ**:

1. **前提条件**: 001/data-model.mdがUserエンティティをフィールド[id, name, email]で定義し、003/data-model.mdがUserに[profile_picture, bio]を追加、**実行**: 統合を有効にしてドキュメントが生成される、**期待結果**: データモデルセクションに5つすべてのフィールドを持つ単一の統合Userエンティティが表示され、各フィールドを導入した機能で注釈が付けられる

2. **前提条件**: 001/contracts/api.jsonがエンドポイント[POST /users, GET /users/{id}]を定義し、003/contracts/extended-api.jsonが[PUT /users/{id}/profile, GET /users/{id}/activity]を追加、**実行**: 統合が実行される、**期待結果**: APIリファレンスセクションが4つすべてのエンドポイントをリソースごとにグループ化してリストし、各エンドポイントを導入した機能を示すメモが含まれる

3. **前提条件**: 001がTaskStatus列挙型を[todo, done]と定義し、003が[todo, in_progress, review, done]に拡張、**実行**: 統合がこの進化を検出、**期待結果**: ドキュメントが4つすべての値を持つ現在の列挙型を示し、メモが含まれる:「機能003でin_progressとreview状態を追加するために拡張されました。」

4. **前提条件**: 同じエンティティを互換性のない方法で変更する2つの機能(例:フィールドタイプがstringからenumに変更)、**実行**: 統合がそれらをマージしようとする、**期待結果**: システムが競合を検出し、時間ベースの解決(後の機能が優先)を適用し、ドキュメントに「Breaking Change」注釈を追加

---

### ユーザーストーリー5: 対象者別ドキュメント (優先度: P3)

**目的**: 異なるステークホルダー向けのドキュメントを準備するspec-kitユーザーが、エンドユーザー、外部開発者、コントリビューター向けに別々のドキュメントバージョンを生成できるようにすることで、各対象者が無関係な技術的詳細や内部実装メモに圧倒されることなく、ニーズに適した情報を受け取れるようにします。

**この優先度の理由**: 価値はありますが、ユーザーは最初は手動でコンテンツをフィルタリングできます。これは使いやすさを向上させますが、基本機能には必須ではありません。

**独立テスト**: --audience=enduserフラグでドキュメントを生成します。plan.mdからの技術的アーキテクチャの詳細とtasks.mdからの内部タスクの内訳が除外され、spec.mdからの機能説明が含まれていることを確認します。次に--audience=developerで生成し、APIコントラクトとデータモデルが含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: spec.md、plan.md、tasks.md、data-model.md、contracts/を含む完全な機能仕様を持つプロジェクト、**実行**: ユーザーが--audience=enduserでドキュメントを生成、**期待結果**: 出力に機能説明とクイックスタートガイドが含まれるが、技術的アーキテクチャ、タスクの内訳、実装の詳細は除外される

2. **前提条件**: 同じプロジェクト、**実行**: ユーザーが--audience=developerでドキュメントを生成、**期待結果**: 出力に完全なAPI仕様、データモデルの詳細、アーキテクチャの決定、実装ステータスに関係なくすべての機能が含まれる(実装済み/進行中/計画済みとしてマーク)

3. **前提条件**: 同じプロジェクト、**実行**: ユーザーが--audience=contributorでドキュメントを生成、**期待結果**: 出力にすべてが含まれる:機能仕様、アーキテクチャ、データモデル、API、タスクの内訳、実装ガイドライン、開発セットアップ手順

4. **前提条件**: gitブランチステータスを介して「進行中」とマークされた機能、**実行**: --audience=enduserドキュメントの生成、**期待結果**: その機能が出力から除外されるが、--audience=developerドキュメントの生成時には、「(進行中)」ステータスバッジ付きで機能が含まれる

---

### ユーザーストーリー6: バージョン履歴とトレーサビリティ (優先度: P3)

**目的**: 成長するプロダクトを維持するspec-kitユーザーが、明確なバージョン履歴とともに、エンティティとAPIが機能間でどのように進化したかを確認できるようにすることで、プロダクトの進化を理解し、破壊的変更を伝え、コントリビューターがアーキテクチャの決定を理解するのを支援できるようにします。

**この優先度の理由**: これは基本的なドキュメントニーズには必須ではない、プロフェッショナルな仕上げを追加する便利な拡張機能です。

**独立テスト**: 3つの機能にわたってUserエンティティが変更されたプロジェクトのドキュメントを生成します。Userエンティティのドキュメントに、各機能で何が変更され、なぜ変更されたかを示す「バージョン履歴」セクションが含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: Userエンティティが3つの機能にわたって進化(001:基本フィールドで作成、002:profile_picture追加、003:privacy_settings追加)、**実行**: ドキュメントが生成される、**期待結果**: Userエンティティページに、何が変更されたかを示し、各変更を導入した機能仕様にリンクする3つのエントリを持つ「バージョン履歴」セクションが含まれる

2. **前提条件**: 003でオプションのクエリパラメータを追加するために変更されたAPIエンドポイント/users/{id}、**実行**: ドキュメントが生成される、**期待結果**: エンドポイントドキュメントに変更履歴メモが含まれる:「003で更新:オプションの?include=profile,activityクエリパラメータを追加。」

3. **前提条件**: spec.mdの「根拠」または「前提条件」セクションを参照する機能、**実行**: ドキュメントを統合、**期待結果**: システムがこれらのコンテキストメモを抽出して保持し、関連セクション(例:特定のエンティティ構造が選ばれた理由)に含める

4. **前提条件**: 機能003がTaskStatus列挙値を変更した破壊的変更、**実行**: ドキュメントが生成される、**期待結果**: 破壊的変更が「⚠️ Breaking Change (v003)」バッジと何が変更されたかの説明で明確にフラグ付けされる

---

### ユーザーストーリー7: LLMによるユーザーフレンドリーなドキュメント生成 (優先度: P1) 🎯 MVP

**目的**: エンドユーザー（顧客、プロダクトマネージャー、営業チーム、サポートチーム）にプロジェクトのドキュメントを提供したいspec-kitユーザーが、技術的な仕様書を自動的に読みやすく親しみやすい形式に変換できるようにすることで、非技術者でもプロジェクトの機能や価値を理解できるドキュメントを作成できるようにします。

**この優先度の理由**: 現状の単純なファイルコピー方式では、開発者向けの技術的な仕様書がそのままドキュメントに表示され、エンドユーザーにとって難解です。LLMによる変換は、spec-kit-docsの独自価値を明確化し、単なる「ファイルコピーツール」から「インテリジェントなドキュメント生成ツール」への差別化を実現します。

**独立テスト**: 3つの機能を持つspec-kitプロジェクトでClaude Code上で`/speckit.doc-update`を実行します（デフォルトでLLM変換が有効）。生成されたドキュメントを確認し、(1) Functional Requirements（「FR-001: System MUST...」形式）がAIエージェントによって自然な文章（「ユーザーは...できます」形式）に変換されている、(2) 元のspec.mdへのリンクが保持されている、(3) LLM変換処理が失敗した場合は明確なエラーメッセージが表示されてプロセスが中断される、ことを確認します。

**受け入れシナリオ**:

1. **前提条件**: Claude Code環境で、3つの機能（各ディレクトリにspec.mdを含む）を持つspec-kitプロジェクト、**実行**: ユーザーが`/speckit.doc-update`を実行（フラグなし、デフォルトでLLM変換が有効）、**期待結果**: AIエージェント（Claude Code）が各機能のspec.mdを読み込み、LLM変換を実行し、変換済みコンテンツをdoc_update.pyスクリプトに渡す。各機能のドキュメントページに変換された「機能概要」セクションが含まれ、技術的な"MUST"表現が自然な文章に変換されている。更新サマリーに「LLM変換: 成功3件、スキップ（キャッシュ利用）0件」と表示される

2. **前提条件**: 1つの機能のspec.mdが非常に大きい（10,000トークン超過）プロジェクト、**実行**: `/speckit.doc-update`を実行、**期待結果**: AIエージェントがエラーメッセージ「specs/[BRANCH_NAME]/spec.md の Functional Requirements セクションが10,000トークンを超過しています（現在: [ACTUAL_SIZE]トークン）。コンテンツを分割するか、--no-llm-transformフラグでLLM変換を無効化してください」を表示し、プロセスが中断される

3. **前提条件**: LLM変換処理中にエラーが発生する環境（予期しない例外、API通信エラー等）、**実行**: `/speckit.doc-update`を実行、**期待結果**: AIエージェントがエラーメッセージ「specs/[BRANCH_NAME]/spec.md のLLM変換中にエラーが発生しました: [エラー詳細]。--no-llm-transformフラグでLLM変換を無効化して再実行するか、spec.mdのコンテンツ形式を確認してください」を表示し、プロセスが中断される。**フォールバック動作は行わない**（憲章準拠）

4. **前提条件**: 前回の`/speckit.doc-update`実行後、1つの機能のspec.mdのみが変更されたプロジェクト、**実行**: 再度`/speckit.doc-update`を実行、**期待結果**: AIエージェントがGit diffを使用して変更された機能のみLLM変換を実行し、変更されていない機能はキャッシュされた変換結果を再利用する。更新サマリーに「LLM変換: 成功1件、スキップ（キャッシュ利用）2件」と表示される

5. **前提条件**: デフォルトでLLM変換が有効化され、生成されたドキュメントページ、**実行**: ユーザーがドキュメントページを確認、**期待結果**: ページに「詳細な技術仕様はspec.mdを参照してください」といった元のファイルへのリンクが含まれており、技術者が正確な情報にアクセスできる

6. **前提条件**: `--no-llm-transform`フラグを指定して`/speckit.doc-update --no-llm-transform`を実行、**期待結果**: AIエージェントはLLM変換を実行せず、元のspec.mdコンテンツをそのままスクリプトに渡す（既存の単純コピー方式、オプトアウト方式）。更新サマリーにLLM変換の統計情報は表示されない

---

### エッジケース

- **空の機能ディレクトリ**: 機能フォルダーは存在するがmarkdownファイルがない → 静かにスキップするかユーザーに警告
- **不正なmarkdown**: spec.mdファイルに無効なmarkdown構文がある → 他のファイルの処理を継続し、ファイルパスとともに警告をログ
- **依存関係の欠落**: 機能が以前のどの機能にも存在しないエンティティやAPIを参照している → ドキュメントで潜在的な問題としてフラグ
- **循環依存**: 機能Aが機能Bを参照し、機能Bが機能Aを参照 → サイクルを検出して切断し、関係をドキュメント化
- **非常に大きなプロジェクト**: 数百ページの仕様を持つ50以上の機能 → 段階的に処理し、進行状況を表示し、メモリ使用を最適化
- **非標準のファイル名**: ユーザーがspecs/に追加ファイルを手動で作成 → 予期されるパターンに一致する場合(機能ディレクトリ内の*.md)は含め、それ以外は無視
- **gitブランチの状態**: 機能ブランチが存在するがmainにマージされていない → 実装ステータスを決定し、ドキュメントで適切にマーク
- **複数のコントラクト形式**: 一部の機能はOpenAPI JSONを使用し、他はmarkdownテーブルを使用 → 両方の形式を解析し、統一された表現に正規化
- **部分的な機能仕様**: 機能にspec.mdはあるがplan.mdまたはdata-model.mdがない → 利用可能なファイルからドキュメントを生成し、欠落しているアーティファクトに注意
- **競合するタイムスタンプ**: gitが機能003が002の前にコミットされたことを示す → gitタイムスタンプではなく機能番号を真実の源として使用
- **カスタムテンプレート**: ユーザーがプロジェクト内のspec-template.mdを変更 → 解析時にカスタムセクションを尊重し、フォールバックとして標準セクションを使用

## 要件 *(必須)*

### 機能要件

#### /speckit.doc-init コマンド

- **FR-001**: システムは、プロジェクトルートに `.specify/` ディレクトリが存在することを確認し、spec-kit プロジェクトであることを検証しなければならない
- **FR-002**: システムは、`--type` 引数または対話的プロンプトを通じて、ドキュメントツールの選択（sphinx または mkdocs）をサポートしなければならない
- **FR-003**: AI エージェント（Claude Code）は、Sphinx 初期化の場合、プロジェクト名、著者名、バージョン、言語設定をユーザーから対話的に収集し、コマンドライン引数として doc_init.py に渡さなければならない
- **FR-003a**: doc_init.py は、以下のコマンドライン引数を受け取らなければならない: `--type`, `--project-name`, `--author`, `--version`, `--language`, `--force` (Sphinx の場合)、`--type`, `--project-name`, `--site-name`, `--repo-url`, `--force` (MkDocs の場合)。`--force` フラグが指定された場合、既存の `docs/` ディレクトリを上書きする
- **FR-003b**: doc_init.py は、引数が未指定の場合、合理的なデフォルト値を使用しなければならない。Sphinx の場合：（プロジェクト名：現在のディレクトリ名、著者：Git user.name または "Unknown Author"、バージョン："0.1.0"、言語："ja"）。MkDocs の場合：（プロジェクト名：現在のディレクトリ名、サイト名：プロジェクト名と同じ、リポジトリURL：Git remote origin URL または空文字列）
- **FR-003c**: doc_init.py は、標準入力（stdin）を使用してはならない。すべての設定はコマンドライン引数またはデフォルト値から取得する
- **FR-003d**: doc_init.py は、`docs/` ディレクトリが既に存在し `--force` フラグが指定されていない場合、エラー終了コード 1 とメッセージ "docs/ already exists. Use --force to overwrite." を返さなければならない
- **FR-004**: AI エージェント（Claude Code）は、MkDocs 初期化の場合、プロジェクト名、サイト名、リポジトリURLをユーザーから対話的に収集し、コマンドライン引数として doc_init.py に渡さなければならない
- **FR-005**: システムは、Sphinx の場合、`docs/` ディレクトリに `conf.py`（myst-parser設定を含む）、`index.md`（Markdown形式）、`Makefile`、`make.bat`、および以下のディレクトリ構造を生成しなければならない。すべてのファイルはMarkdown形式（.md）で、MyST Markdown構文をサポート。初期化時に `specs/` ディレクトリ内の機能数をカウントし、構造を決定する：
  - 5機能以下の小規模プロジェクト：フラット構造（`docs/` 直下に機能ページ）
  - 6機能以上のプロジェクト：包括的な構造（`docs/features/`、`docs/guides/`、`docs/api/`、`docs/architecture/`）
- **FR-005a**: システムは、Sphinx初期化時に`conf.py`でmyst-parserを有効化し、Markdown（.md）ファイルを解析できるように設定しなければならない。具体的には：
  - `extensions`に`'myst_parser'`を追加
  - `source_suffix`に`.md`を含める（`.rst`もサポート）
  - MyST Markdownの拡張機能（colon_fence、deflist、tasklist、attrs_inline等）を有効化
- **FR-006**: システムは、MkDocs の場合、`docs/` ディレクトリに `mkdocs.yml`、`docs/index.md`、および以下のディレクトリ構造を生成しなければならない。初期化時に `specs/` ディレクトリ内の機能数をカウントし、構造を決定する：
  - 5機能以下の小規模プロジェクト：フラット構造（`docs/` 直下に機能ページ）
  - 6機能以上のプロジェクト：包括的な構造（`docs/features/`、`docs/guides/`、`docs/api/`、`docs/architecture/`）
- **FR-007**: AI エージェント（Claude Code）は、`docs/` ディレクトリが既に存在する場合、ユーザーに上書き確認を求め、ユーザーが承認した場合のみ `--force` フラグ付きで doc_init.py を呼び出さなければならない。ユーザーが拒否した場合は既存の構造を保持し、処理を中断する
- **FR-008**: doc_init.py は、選択したツールに必要な Python パッケージ（Sphinxの場合：sphinx + myst-parser、MkDocsの場合：mkdocs）を標準出力（stdout）に人間が読みやすい形式で出力しなければならない。形式：「次のパッケージのインストールが必要です: {package_list}」+ 「インストールコマンド: uv add {package_list}」。この出力は、AI エージェント（Claude Code）がユーザーにインストール手順を提示するために使用する
- **FR-008b**: doc_init.py は、以下の**すべての条件**が満たされる場合、ユーザーの承認を得て依存関係を自動的にインストールしなければならない：(1) `pyproject.toml`がプロジェクトルートに存在する、(2) `uv`コマンドが実行環境で利用可能（`shutil.which("uv")`が非None）、(3) `--no-install`フラグが指定されていない、(4) 必要なパッケージが既にインストールされていない（`importlib.util.find_spec()`で検証）
- **FR-008c**: 自動インストールを実行する前に、以下の情報をユーザーに明示しなければならない：(1) インストール予定のパッケージリスト（バージョン制約含む、例：`sphinx>=7.0`, `myst-parser>=2.0`）、(2) 実行されるコマンド（例：`uv add --optional docs sphinx>=7.0 myst-parser>=2.0` または `uv add --group docs sphinx>=7.0 myst-parser>=2.0`、FR-008fで選択された配置先に応じる）、(3) `pyproject.toml`の変更先セクション（`[project.optional-dependencies.docs]` または `[dependency-groups.docs]`）の警告、(4) ユーザーの承認を求める確認プロンプト（`--auto-install`フラグがない場合）。確認プロンプトは`typer.confirm()`を使用し、デフォルト値は`True`とする
- **FR-008d**: 自動インストールの条件が満たされない場合、以下を明確に提示しなければならない：(1) 条件が満たされない理由（`pyproject.toml`不在または`uv`コマンド不在）、(2) **方法1（手動インストール）**: 利用可能なパッケージマネージャーを自動検出（`shutil.which()`で`uv`, `pip`, `poetry`を確認）し、検出されたツールごとのインストールコマンドを表示、(3) **方法2（spec-kitワークフロー）**: 依存関係管理をspec-kitワークフロー（`/speckit.specify` → `/speckit.plan` → `/speckit.tasks` → `/speckit.implement`）で管理する方法を手順と共に説明し、その利点（依存関係がplan.md/tasks.mdに記録され履歴が残る）を明示する
- **FR-008e**: doc_init.py は、以下の2つのコマンドラインフラグをサポートしなければならない：(1) `--auto-install`フラグ指定時は、CI/CD環境での非対話的実行をサポートするため、ユーザー確認をスキップして自動的にインストールを実行する、(2) `--no-install`フラグ指定時は、依存関係チェックとインストールをすべてスキップする（ユーザーが依存関係を手動管理する場合）。`uv add`実行時に失敗した場合（ネットワークエラー、権限エラー、タイムアウト等）は、エラー詳細とFR-008dで定義された代替方法を表示し、終了コード1を返す
- **FR-008f**: AI エージェント（Claude Code）は、`/doc-init` 実行時にユーザーに依存関係の配置先を選択させなければならない。選択肢は：(1) `[project.optional-dependencies.docs]`（推奨、pip/poetry/uv互換、`uv add --optional docs` を使用）、(2) `[dependency-groups.docs]`（uvネイティブ、モダン、`uv add --group docs` を使用）。デフォルトは選択肢(1)とする。選択された配置先はdoc_init.pyに`--dependency-target`引数（値: `optional-dependencies` または `dependency-groups`）として渡され、FR-008cで表示されるコマンド例と実際の`uv add`実行に反映される。この選択により、ドキュメント生成ツール（Sphinx/MkDocs）がメインアプリケーションの依存関係から分離され、アーキテクチャ的に正しい構造が実現される
- **FR-009**: システムは、初期化後すぐにビルド可能な最小限のドキュメント構造を作成しなければならない

#### /speckit.doc-update コマンド

- **FR-010**: システムは、`docs/` ディレクトリが存在し、有効なドキュメントプロジェクト（`conf.py` または `mkdocs.yml`）であることを検証しなければならない
- **FR-011**: システムは、少なくとも spec.md ファイルを含む `specs/` 配下のすべての機能ディレクトリを発見しなければならない
- **FR-012**: システムは、markdown ファイル（spec.md、plan.md、tasks.md、data-model.md）を解析し、見出し、リスト、テーブル、コードブロックを含む構造化されたコンテンツを抽出しなければならない
- **FR-013**: システムは、Sphinx プロジェクトの場合、各機能の `.md` ファイル（MyST Markdown形式）を生成し、`index.md` の toctree に追加しなければならない。ファイル命名規則：機能ディレクトリ名から番号を除いた説明的な名前（例：`001-user-auth` → `user-auth.md`）。小規模プロジェクト（5機能以下）は `docs/` 直下、大規模プロジェクトは `docs/features/` 内に配置
- **FR-014**: システムは、MkDocs プロジェクトの場合、各機能の `.md` ファイルを生成し、`mkdocs.yml` の nav セクションに追加しなければならない。ファイル命名規則：機能ディレクトリ名から番号を除いた説明的な名前（例：`001-user-auth` → `user-auth.md`）。小規模プロジェクト（5機能以下）は `docs/` 直下、大規模プロジェクトは `docs/features/` 内に配置
- **FR-015**: システムは、spec.md からのすべてのセクション（ユーザーシナリオ、要件、成功基準、エッジケース）を含む元のコンテンツを保持しなければならない
- **FR-016**: システムは、plan.md が存在する場合、アーキテクチャセクションと技術的決定をドキュメントに含めなければならない
- **FR-017**: システムは、tasks.md が存在する場合、実装タスクの概要をドキュメントに含めなければならない
- **FR-018**: システムは、欠落しているファイル（plan.md や tasks.md がない）がある機能について、利用可能なコンテンツからドキュメントを生成し、欠落セクションには視覚的に明確なアドモニション（Sphinx の `.. note::` や MkDocs の `!!! note`）形式で注記を追加しなければならない
- **FR-019**: システムは、Git の変更履歴（git diff）を使用して前回の更新以降に変更されたファイルのみを検出し、変更されたファイルのみを再処理し、変更されていないファイルは保持しなければならない
- **FR-019a**: システムは、`/speckit.doc-update` 実行時に現在の機能数をカウントし、現在フラット構造（`docs/` 直下に機能ページ）で機能数が6以上になった場合、自動的に包括的構造（`docs/features/`、`docs/guides/`、`docs/api/`、`docs/architecture/`）に移行しなければならない。移行時には既存の機能ページを `docs/features/` に移動し、インデックスとナビゲーションを更新する
- **FR-019b**: システムは、逆方向の移行（包括的構造からフラット構造への移行）を行ってはならない。一度包括的構造に移行したプロジェクトは、機能数が減少しても包括的構造を維持する
- **FR-020**: システムは、更新後に何個の機能が更新され、何個が変更なしだったかを示すサマリーを表示しなければならない。構造移行が発生した場合は「フラット構造から包括的構造に移行しました」というメッセージも含める

#### インストールとプロジェクト構造

- **FR-021**: `speckit-docs`CLIツールは、独立したPythonパッケージとしてGitHubから配布され、**エンドユーザー向けの推奨インストール方法は`uv tool install speckit-docs --from git+https://github.com/drillan/spec-kit-docs.git`とする**。この方法は本家spec-kitの`uv tool install specify-cli`パターンと一貫性を保ち、グローバルCLIツールとしてプロジェクト環境を汚染せずに管理される。開発者向けのコントリビューション時には`uv pip install -e .`（編集可能インストール）も引き続きサポートするが、README.mdなどのエンドユーザー向けドキュメントでは`uv tool install`方式を唯一の推奨方法として記載する。PyPI公開は将来のフェーズで検討する
- **FR-021a**: `speckit-docs install`コマンドは、カレントディレクトリがspec-kitプロジェクトであることを確認し（`.specify/`ディレクトリと`.claude/`ディレクトリの存在確認）、そうでない場合は明確なエラーメッセージを表示しなければならない
- **FR-021b**: `speckit-docs install`コマンドは、カレントディレクトリに自動的にインストールし、明示的なディレクトリ指定引数を要求してはならない（`cd my-project && speckit-docs install`パターン）
- **FR-022**: `speckit-docs install`コマンドは、インストール時に `.claude/commands/speckit.doc-init.md` と `.claude/commands/speckit.doc-update.md` の2つのコマンド定義を作成しなければならない（Claude Codeが `/speckit.doc-init` と `/speckit.doc-update` として認識し、spec-kitの他のコマンドとの命名規則の一貫性を保つ）
- **FR-022a**: `.claude/commands/speckit.doc-init.md` は、以下のワークフローを実行するプロンプトを記述しなければならない：(1) ユーザーに対話的に質問（ドキュメントツール選択、プロジェクト名、著者名、バージョン、言語等）、(2) 収集した情報をコマンドライン引数に構築、(3) `uv run python .specify/scripts/docs/doc_init.py` を適切な引数で呼び出し、(4) スクリプトの結果をユーザーにフィードバック、(5) エラーが発生した場合は明確なメッセージと次のステップを提示
- **FR-022b**: `.claude/commands/speckit.doc-update.md` は、以下のワークフローを実行するプロンプトを記述しなければならない：(1) `docs/` ディレクトリの存在確認、(2) `uv run python .specify/scripts/docs/doc_update.py` の呼び出し、(3) 更新されたファイルのサマリー表示、(4) エラーハンドリングとユーザーフィードバック
- **FR-023**: `speckit-docs install`コマンドは、インストール時に必要なスクリプト（`doc_init.py`、`doc_update.py`）を `.specify/scripts/docs/` にコピーしなければならない
- **FR-023a**: コマンドテンプレートファイル（`speckit.doc-init.md`、`speckit.doc-update.md`）とスクリプトファイル（`doc_init.py`、`doc_update.py`）は `src/speckit_docs/commands/` および `src/speckit_docs/scripts/` ディレクトリに配置され、`importlib.resources`を使用してアクセスされなければならない。これにより、Pythonパッケージに含まれ、オフライン環境でも動作する
- **FR-023b**: `speckit-docs install` コマンドは、既存のコマンド定義ファイル（`.claude/commands/speckit.doc-*.md`）または スクリプトファイル（`.specify/scripts/docs/`）が存在する場合、ユーザーに上書き確認を求めなければならない。`--force` フラグが指定された場合は、確認をスキップして上書きする（spec-kitの`specify init --here`パターンと一貫）
- **FR-023c**: インストール中にエラーが発生した場合、システムはベストエフォート方式で動作し、エラー発生時点までにコピーされたファイルは残す。ユーザーは手動で修正するか、問題を解決してから再実行できる（spec-kitの既存ディレクトリへの追加パターンと一貫）
- **FR-024**: システムは、コンテンツを統合する際に時間的順序を決定するために、機能ディレクトリの番号付け（001、002、003）を使用しなければならない

#### 高度な機能（将来のフェーズ）

- **FR-025**: システムは、複数の data-model.md ファイルからエンティティ定義を統合し、現在の状態と進化を示す統一されたデータモデルを生成しなければならない（P2）。「進化を示す」とは、以下の情報を含むことを意味する：(a) 各フィールドを導入した機能番号（例：`profile_picture` (added in 003)）、(b) フィールドが変更された場合の変更履歴（例：`status: string → TaskStatus enum` (changed in 005)）、(c) 削除されたフィールドの記録（例：`~~old_field~~` (removed in 007)）。詳細な出力形式は、Phase 2実装時にdata-model.mdまたは専用の設計ドキュメントで定義される
- **FR-026**: システムは、複数の機能の contracts/ ディレクトリから API 仕様をマージし、統一された API リファレンスを生成しなければならない（P2）
- **FR-027**: システムは、競合する情報（例：同じエンティティの異なる定義）を検出し、最新優先戦略を使用して解決しなければならない（P2）
- **FR-028**: システムは、各要素を導入または変更した機能を示すために、統合されたコンテンツに注釈を付けなければならない（P2）
- **FR-029**: システムは、対象者パラメータに基づいてコンテンツをフィルタリングしなければならない：enduser（機能と使用法のみ）、developer（API とアーキテクチャ）、contributor（すべて）（P3）
- **FR-030**: システムは、機能の実装ステータスを決定するために git リポジトリの状態を確認しなければならない（main にマージ済み=実装済み、ブランチとして存在=進行中、ブランチなし=計画済み）（P3）
- **FR-031**: システムは、機能間での進化を示すエンティティと API のバージョン履歴セクションを生成しなければならない（P3）
- **FR-032**: システムは、破壊的変更（タイプの変更、削除されたフィールド、変更された列挙型）を警告バッジでフラグ付けしなければならない（P3）

#### エラーハンドリングと品質

- **FR-033**: システムは、一般的な問題に対して明確なエラーメッセージを提供しなければならない：spec-kit プロジェクトではない、ドキュメントプロジェクトが初期化されていない、機能が見つからない、不正なファイル
- **FR-034**: システムは、オフラインで表示でき、任意の Web サーバーでホストできる静的 HTML ファイルとしてドキュメントを生成しなければならない
- **FR-035**: システムは、不正な markdown を適切に処理し、他のファイルの処理を継続し、特定のエラーを報告しなければならない。すべてのエラーは `SpecKitDocsError` 例外として発生させ、エラーメッセージには「ファイルパス」「エラーの種類」「ユーザーへの推奨アクション」を含める。AI エージェント（Claude Code）は、この構造化されたエラーメッセージをユーザーにわかりやすく提示する
- **FR-036**: システムは、コードリント・フォーマットに**ruff**を使用しなければならない（blackは禁止）。`pyproject.toml`で以下の設定を指定する：`select = ["E", "F", "W", "I"]`（エラー、致命的エラー、警告、import順序）、`line-length = 100`、`target-version = "py311"`。開発者は`uv run ruff check .`でローカル実行する（CI/CDパイプラインは構築しない）
- **FR-037**: システムは、Pythonの標準logging模块を使用した構造化ログを実装しなければならない。デフォルトでINFOレベル以上を標準出力に出力し、`--verbose`フラグでDEBUGレベル、`--quiet`フラグでERRORレベルのみを出力する。ログメッセージは進捗情報（「3機能を処理中...」等）とエラー詳細を含む

#### LLMドキュメント変換機能（Phase 1 - MVP）

- **FR-038**: AIエージェント（Claude Code）は、`/speckit.doc-update`実行時、デフォルトでspec.mdのFunctional Requirementsセクションをユーザーフレンドリーな「機能概要」に変換しなければならない（`--no-llm-transform`フラグで無効化可能）。変換では、技術的な"MUST"表現を自然な文章に変換する（例：「FR-001: System MUST allow users to create accounts」→「ユーザーはアカウントを作成できます」）。変換済みコンテンツは一時ファイルまたはコマンドライン引数としてバックエンドスクリプト（doc_update.py）に渡される
- **FR-038a**: AIエージェント（Claude Code）は、LLM変換対象のコンテンツサイズが設定された上限（デフォルト: 1機能あたり10,000トークン）を超える場合、明確なエラーメッセージを返してプロセスを中断しなければならない。エラーメッセージには「ファイルパス」「エラー種類」「推奨アクション」を含める（例：「specs/[BRANCH_NAME]/spec.md の Functional Requirements セクションが10,000トークンを超過しています（現在: [ACTUAL_SIZE]トークン）。コンテンツを分割するか、--no-llm-transformフラグでLLM変換を無効化してください」）
- **FR-038b**: AIエージェント（Claude Code）は、LLM変換処理中にエラーが発生した場合（予期しない例外、コンテンツ形式エラー、API通信エラー等）、明確なエラーメッセージを返してプロセスを中断しなければならない。エラーメッセージには「ファイルパス」「エラー種類」「推奨アクション」を含める（例：「specs/[BRANCH_NAME]/spec.md のLLM変換中にエラーが発生しました: [エラー詳細]。--no-llm-transformフラグでLLM変換を無効化して再実行するか、spec.mdのコンテンツ形式を確認してください」）。**フォールバック動作は行わない**（憲章準拠）
- **FR-038c**: AIエージェント（Claude Code）は、LLM生成コンテンツが不適切（空文字列、明らかなエラーメッセージ、Markdown形式違反）な場合、品質チェックを実行し、不合格の場合は明確なエラーメッセージを返してプロセスを中断しなければならない。エラーメッセージには「ファイルパス」「エラー種類」「推奨アクション」を含める（例：「specs/[BRANCH_NAME]/spec.md のLLM変換で生成されたコンテンツが品質基準を満たしません（理由: [VALIDATION_ERROR]）。--no-llm-transformフラグでLLM変換を無効化して再実行するか、spec.mdのコンテンツを確認してください」）。**フォールバック動作は行わない**（憲章準拠）
- **FR-038d**: コマンド定義（`.claude/commands/speckit.doc-update.md`）は、LLM変換が有効な場合でも、生成されるドキュメントページに元のspec.mdファイルへのリンク（例：「詳細な技術仕様はspec.mdを参照してください」）を必ず含めるようスクリプトに指示しなければならない。これにより、技術者が元の正確な情報にアクセスできることを保証する
- **FR-038e**: AIエージェント（Claude Code）は、Git diffベースのインクリメンタル更新機能（FR-019）と統合し、変更されていない機能の前回のLLM変換結果をキャッシュとして再利用しなければならない。キャッシュは`.claude/.cache/llm-transforms.json`ファイルにJSON形式で永続化され、以下の情報を含む：(1) 機能ID（例：`001-user-auth`）、(2) 元のspec.mdコンテンツのMD5ハッシュ値（32文字、Pythonの`hashlib.md5()`を使用）、(3) 変換済みコンテンツ、(4) タイムスタンプ（ISO 8601形式）、(5) Gitコミットハッシュ（オプション）。キャッシュの無効化判定は、現在のspec.mdコンテンツのMD5ハッシュとキャッシュ内のハッシュ値を比較して行う。これにより、Claude Code再起動後も変換結果を再利用でき、不要なLLM処理を回避し、応答時間を削減する
- **FR-038f**: AIエージェント（Claude Code）は、LLM変換が有効な場合（デフォルト、または`--no-llm-transform`フラグが指定されていない場合）、更新サマリー（FR-020）にLLM変換の統計情報を追加しなければならない。表示内容：「LLM変換: 成功X件、スキップ（キャッシュ利用）Y件」。エラーが発生した場合はプロセスが中断されるため、統計情報には成功件数とキャッシュ利用件数のみを表示する
- **FR-038g**: システムは、`--no-llm-transform`フラグをサポートし、ユーザーがLLM変換を無効化できるようにしなければならない。このフラグが指定された場合、AIエージェントはLLM変換を実行せず、元のspec.mdコンテンツをそのままスクリプトに渡す（既存の単純コピー方式）

### 主要エンティティ *(機能がデータを含む場合に含める)*

- **SpecKitProject**: spec-kitプロジェクトを表し、ルートディレクトリ、.specify/設定、specs/ディレクトリを含む
- **Feature**: 単一の機能仕様(例:001-user-auth)で、markdownファイルのコレクション、コントラクト、実装ステータスを含む
- **Entity**: data-model.mdファイルから抽出されたデータモデルエンティティ(例:User、Task)で、フィールド、タイプ、バージョン履歴を含む
- **APIEndpoint**: contracts/からのAPIエンドポイント定義で、メソッド、パス、パラメータ、バージョン履歴を含む
- **DocumentationSite**: ページ、ナビゲーション、アセットを含む生成された出力構造
- **Audience**: 関連するコンテンツフィルタリングルールを持つターゲットオーディエンス(enduser、developer、contributor)の列挙型
- **SynthesisResult**: 機能間でマージした後のエンティティとAPIの統合ビュー
- **FeatureStatus**: gitブランチステータスから派生した実装状態(implemented、in_progress、planned)の列挙型
- **BaseGenerator**: ドキュメントジェネレーターの抽象ベースクラス。以下の4つの必須メソッドを定義：(1) `initialize()` - ドキュメントプロジェクトの初期化と設定ファイル生成、(2) `generate_feature_page(feature: Feature) -> None` - 単一機能のページ生成、(3) `update_navigation() -> None` - 目次（toctree/nav）の更新、(4) `validate() -> bool` - ビルド前検証。SphinxGeneratorとMkDocsGeneratorがこのインターフェースを実装する

## 成功基準 *(必須)*

### 測定可能な成果

#### /speckit.doc-init コマンド

- **SC-001**: ユーザーは `/speckit.doc-init` を実行してから完了まで30秒以内にドキュメントプロジェクトを初期化できる（対話的な入力時間を除く）
- **SC-002**: 必要な依存関係がインストールされている環境、または自動インストールが成功した環境で、初期化されたドキュメントプロジェクトは、追加設定なしでビルドコマンド（`make html` または `mkdocs build`）が成功する。依存関係が`[project.optional-dependencies.docs]`に配置された場合は、`uv sync --all-extras`または`pip install -e ".[docs]"`を実行後にビルドが成功する
- **SC-002b**: `pyproject.toml`と`uv`コマンドが利用可能な環境で、ユーザーが依存関係のインストールを承認した場合、90%以上のケースで`uv add`（`--optional docs`または`--group docs`、FR-008fで選択された配置先に応じる）が成功し、その後のビルドコマンド（`make html`または`mkdocs build`）が成功する。残り10%はネットワークエラー、権限エラー、パッケージリポジトリの一時的な問題等の外部要因による失敗を許容する
- **SC-002c**: FR-008fで選択された依存関係の配置先（`optional-dependencies`または`dependency-groups`）に応じて、100%のケースでユーザーのプロジェクトの`pyproject.toml`の正しいセクション（`[project.optional-dependencies.docs]`または`[dependency-groups.docs]`）に依存関係が追加される。依存関係はメイン依存関係（`[project.dependencies]`）と分離され、アーキテクチャ的に正しい構造が維持される
- **SC-003**: Sphinx と MkDocs の両方のドキュメントツールが正しくサポートされ、それぞれの標準的なプロジェクト構造が生成される
- **SC-004**: 既存の `docs/` ディレクトリを持つプロジェクトで初期化を試みた場合、100% のケースで上書き確認が表示される
- **SC-005**: インタラクティブプロンプトで収集された設定（プロジェクト名、著者名など）が生成された設定ファイルに正確に反映される

#### /speckit.doc-update コマンド

- **SC-006**: ユーザーは5機能のプロジェクトで `/speckit.doc-update` を実行してから45秒以内にドキュメントを更新できる（AI統合時間を除く）
- **SC-007**: 生成されたドキュメントサイトは、Web サーバーを必要とせずに任意のモダン Web ブラウザでナビゲート可能で読みやすい
- **SC-008**: spec.md からのすべてのセクション（ユーザーシナリオ、要件、成功基準、エッジケース）の95%以上が、生成されたドキュメントに正しく含まれる
- **SC-009**: plan.md と tasks.md が存在する機能について、それらのコンテンツの90%以上がドキュメントに統合される
- **SC-010**: 機能に欠落しているファイル（例：plan.md がない）がある場合でも、ドキュメント更新が成功し、利用可能なコンテンツを含み、欠落セクションに適切な注記が表示される
- **SC-011**: 前回の更新以降に変更されていない機能について、システムが再処理をスキップし、更新サマリーに正確な変更/未変更の件数が表示される
- **SC-008b**: 自動インストールの条件（`pyproject.toml`存在かつ`uv`コマンド利用可能）が満たされない場合、100%のケースで利用可能な代替方法（方法1: 手動インストール、方法2: spec-kitワークフロー）が明確に提示される。代替方法には、それぞれの手順と利点（spec-kitワークフローの場合は「依存関係の履歴がplan.md/tasks.mdに記録される」等）が含まれる
- **SC-008c**: `uv add`が失敗した場合（ネットワークエラー、権限エラー、タイムアウト等）、100%のケースで失敗理由と代替方法（FR-008dで定義された方法1と方法2）が明確に提示され、ユーザーが次のアクションを判断できる

#### LLMドキュメント変換機能（Phase 1 - MVP）

- **SC-022**: デフォルトでLLM変換が有効な場合（`--no-llm-transform`フラグが指定されていない場合）、Claude Code環境で90%以上のケースでAIエージェントによるLLM変換が成功し、Functional Requirementsが自然な文章に変換される（残り10%はコンテンツ解析エラー、予期しない形式等による失敗を許容）
- **SC-023**: LLM変換失敗時（コンテンツサイズ超過、変換処理エラー、品質チェック不合格）、100%のケースで明確なエラーメッセージ（「ファイルパス」「エラー種類」「推奨アクション」を含む）が表示され、プロセスが中断される。**フォールバック動作は行わない**（憲章準拠）
- **SC-024**: LLM変換されたドキュメントページの100%に、元のspec.mdファイルへのリンクが含まれ、技術者が詳細な情報にアクセスできる
- **SC-025**: Git diffベースのインクリメンタル更新との統合により、変更されていない機能のLLM変換結果が95%以上のケースでキャッシュから再利用され、不要なLLM処理が回避される
- **SC-026**: LLM変換が有効な場合（デフォルト、または`--no-llm-transform`フラグが指定されていない場合）、更新サマリーに「LLM変換: 成功X件、スキップ（キャッシュ利用）Y件」の統計情報が100%のケースで表示される（エラー発生時はプロセスが中断されるため、統計には成功件数とキャッシュ利用件数のみを含む）
- **SC-027**: LLM変換されたドキュメントは、非技術者（プロダクトマネージャー、営業チーム、サポートチーム等）にとって、技術的な仕様書よりも理解しやすい（主観的評価：ユーザーテストで80%以上の非技術者が「理解しやすい」と回答）
- **SC-028**: `--no-llm-transform`フラグ指定時、システムは既存の単純コピー方式を使用し、AIエージェントはLLM変換を実行しない（オプトアウト方式）。更新サマリーにLLM変換の統計情報は表示されない

#### インストールと統合

- **SC-013**: 新しい spec-kit プロジェクトでのインストールが10秒以内に正常に完了する
- **SC-014**: ユーザーはインストール直後に追加設定なしで Claude Code で `/speckit.doc-init` と `/speckit.doc-update` を実行できる
- **SC-015**: インストールされた2つのコマンド定義が Claude Code のコマンドリストに正しく表示される

#### 高度な機能（将来のフェーズ）

- **SC-016**: すべての機能からのエンティティフィールドと API エンドポイントの95%が、統合されたドキュメントに正しく含まれる（P2）
- **SC-017**: エンティティの進化が少なくとも3つの機能にわたって正確に追跡され、何がいつ変更されたかを示す変更履歴が表示される（P2）
- **SC-018**: enduser ドキュメントは、技術的実装の詳細（plan.md のアーキテクチャセクション、tasks.md）を100%除外する（P3）
- **SC-019**: developer ドキュメントは、実装ステータスに関係なく、API エンドポイントとデータモデルエンティティを100%含む（P3）
- **SC-020**: 破壊的変更は、エンティティまたは API 定義が互換性のない方法で変更された場合の少なくとも90%で正しく識別され、フラグ付けされる（P3）
- **SC-021**: システムは、標準的なケース（マージ済み、ブランチが存在、ブランチなし）の100%で、git ブランチ状態から機能の実装ステータスを正しく決定する（P3）

## スコープ境界 *(オプション)*

**スコープ内（フェーズ1 - MVP）**:
- `/speckit.doc-init` コマンド：ドキュメントプロジェクトの初期化
  - Sphinx および MkDocs のサポート（`--type` 引数で選択）
  - インタラクティブな設定収集（プロジェクト名、著者、バージョン）
  - 標準的なディレクトリ構造とビルド可能な設定ファイルの生成
  - 既存 `docs/` ディレクトリの上書き確認
- `/speckit.doc-update` コマンド：spec-kit 仕様からのドキュメント更新
  - markdown ファイル解析（spec.md、plan.md、tasks.md）
  - Sphinx（.md with MyST）および MkDocs（.md）形式でのドキュメントページ生成
  - 機能ページの自動生成と目次への追加
  - インクリメンタル更新（変更されたファイルのみを再処理）
  - 欠落ファイルの適切な処理と注記
- 既存の spec-kit プロジェクトへの拡張機能としてのインストール
- Claude Code AI エージェントのサポート
- 機能ディレクトリの番号付け（001、002、003）による時系列順序の維持

**スコープ内（フェーズ2 - 高度な統合）**:
- エンティティ統合と競合解決のための LLM API を使用した AI 駆動の統合
- 複数の data-model.md ファイルからのエンティティ定義の統合
- 複数の機能の contracts/ ディレクトリからの API 仕様のマージ
- 統合されたコンテンツへの機能トレーサビリティ注釈
- 競合する情報の検出と解決（最新優先戦略）

**スコープ内（フェーズ3 - 高度な機能）**:
- 対象者別フィルタリング（enduser、developer、contributor）
- git ブランチステータスからの実装ステータス検出
- 機能間のバージョン履歴追跡
- 破壊的変更の自動検出とフラグ付け

**スコープ外（将来のフェーズ）**:
- アンインストールコマンド（`speckit-docs uninstall`） - MVP範囲外。少数のファイルなので手動削除で十分。本家spec-kitも提供していない
- 専用アップグレードコマンド - `speckit-docs install --force`で代替可能（本家spec-kitの`specify init --here --force`パターン）
- 他のドキュメントジェネレータ（Docusaurus、VitePress）のサポート - 将来検討
- 他の AI エージェント（GitHub Copilot、Gemini、Cursor）のサポート - 将来検討
- インタラクティブなドキュメント機能（検索、フィルタリング、ライブ例） - 将来検討
- 多言語ドキュメント生成（i18n） - 将来検討
- ホスティングとデプロイの自動化（GitHub Pages、Netlify） - 将来検討
- カスタムテーマとブランディング - 将来検討
- PDF と ePub エクスポート - 将来検討
- API ドキュメントテスト（実行中の API に対するコントラクトの検証） - 将来検討
- ドキュメントのバージョン管理（複数のプロダクトバージョンのドキュメントの維持） - 将来検討

## 前提条件 *(オプション)*

### フェーズ1（MVP）の前提条件

1. **spec-kit プロジェクト**: ユーザーは有効な spec-kit プロジェクト（`.specify/` と `.claude/` ディレクトリを持つ）を持っている
2. **仕様フォーマット**: ユーザーは、期待されるセクション見出しを持つ spec.md、plan.md、tasks.md の標準 spec-kit テンプレートに従う
3. **機能番号付け**: 機能は順番に番号付けされ（001、002、003）、番号は時系列順を反映する
4. **AI エージェントのコンテキスト**: Claude Code はコマンド定義の scripts: frontmatter 経由でシェルスクリプトを実行できる
5. **markdown 規則**: markdown ファイルは GitHub Flavored Markdown 拡張を含む標準 CommonMark 構文を使用する
6. **プロジェクト構造**: spec-kit プロジェクトは、機能ディレクトリを含む `specs/` を持つ標準構造に従う
7. **コマンドの可用性**: ユーザーは環境で必要な依存関係（Python 3.11+、Sphinxの場合：sphinx + myst-parser、MkDocsの場合：mkdocs）を利用可能、またはインストールできる
7a. **specify-cli依存関係**: spec-kit-docsは`specify-cli`に依存し、pyproject.tomlでGit URL直接指定（`specify-cli @ git+https://github.com/github/spec-kit.git`）を使用する。specify-cliは公開リポジトリであり、通常のpip/uvインストールで取得可能
8. **ファイルシステムアクセス**: ツールは `.specify/` ディレクトリへの読み取りアクセスと `docs/` ディレクトリへの書き込みアクセスを持つ
9. **ネットワークアクセス**: インストールは PyPI からパッケージをダウンロードできる
10. **合理的な規模**: ほとんどのプロジェクトは1-20機能を持つ；50以上の機能の最適化は便利な追加機能
11. **言語**: 仕様は主に日本語または英語で書かれる；多言語サポートは将来の作業
12. **Git 使用**: プロジェクトは git リポジトリである必要がある（インクリメンタル更新での変更検出に git diff を使用）

### フェーズ2以降の追加前提条件

13. **Git ブランチング**: プロジェクトは標準ブランチング（機能ブランチが main にマージ）で git を使用する（実装ステータス検出に必要）
14. **LLM アクセス**: ユーザーは、十分なレート制限を持つ統合機能用の LLM API（Claude、GPT-4）へのアクセスを持つ（AI 駆動の統合に必要）
15. **data-model.md と contracts/**: 高度な統合機能を使用する場合、機能は data-model.md や contracts/ ディレクトリを含む
16. **一貫したエンティティ命名**: 機能間で統合されるエンティティは一貫した命名を使用する（例：User、user_entity ではなく User）

## 非機能要件 *(オプション)*

### フェーズ1（MVP）

- **パフォーマンス**:
  - `/speckit.doc-init` は30秒以内に完了する（対話的入力時間を除く）
  - `/speckit.doc-update` は、最大10機能のプロジェクトで45秒以内に完了する（フル更新時）
  - インクリメンタル更新により、変更されていない機能の再処理を回避し、以下の基準を満たす：
    - 1機能のみ変更された場合、更新時間は5秒以内（フル更新比で約90%削減、SC-008）
    - 変更されていない機能のファイル読み取り・解析をスキップ
    - Git diff検出のオーバーヘッドは1秒以内
- **信頼性**:
  - システムは不正な markdown を適切に処理し、他のファイルの処理を継続し、特定のエラーを報告する
  - 欠落しているファイル（plan.md、tasks.md）がある場合でも処理を継続
  - `speckit-docs install` コマンドはベストエフォート方式で動作し、エラー発生時もそれまでにコピーされたファイルは残す（spec-kitの`specify init --here`パターンと一貫）。ユーザーは手動で修正するか、問題解決後に再実行可能
  - **依存関係自動インストール成功率**: pyproject.toml + uv環境が整っている場合、90%以上のケースで依存関係インストールが成功する（SC-002b、ネットワークエラー・権限エラー・タイムアウト等の10%許容）
  - **タイムアウト制限**: `uv add`コマンドの実行は300秒（5分）でタイムアウトし、明確なエラーメッセージと代替手段を提示する（FR-008e）
  - **エラー伝播**: すべてのエラーは`SpecKitDocsError`例外として明示的に伝播され、隠蔽されない。エラーメッセージには「ファイルパス」「エラー種類」「推奨アクション」を含む（Constitution C002準拠）
- **セキュリティ**:
  - **依存関係バリデーション**: `importlib.util.find_spec()`を使用してパッケージのインストール状態を検証し、不正なパッケージ名や存在しないパッケージの誤インストールを防ぐ（FR-008b）
  - **コマンドインジェクション防止**: `subprocess.run()`に渡す引数はリスト形式で指定し、シェルインジェクションを防止する（`shell=False`を明示）
  - **権限管理**: pyproject.tomlへの書き込み権限がない場合、適切なエラーメッセージと推奨アクション（手動インストール方法）を提示する（FR-008d）
- **使いやすさ**:
  - インストールは手動設定なしで単一コマンドを必要とする
  - `/speckit.doc-init` はインタラクティブプロンプトで設定を収集し、手動での設定ファイル編集を不要にする
  - `/speckit.doc-update` は単一のコマンドですべての機能を更新する
  - 明確なエラーメッセージと次のステップの提案を提供
- **互換性**:
  - spec-kit 0.0.19+ および Python 3.11+ で動作する
  - Sphinx 7.0+ および myst-parser 2.0+（Sphinx使用時）
  - MkDocs 1.5+（MkDocs使用時）をサポート
- **保守性**:
  - プラグインアーキテクチャにより、spec-kit コアの変更を必要とせずに更新が可能
  - 2つの独立したコマンド（`doc-init` と `doc-update`）により、各機能を個別に保守可能
  - **テストカバレッジ**: 主要なコードパス（初期化、更新、エラーハンドリング、依存関係管理）で90%以上のカバレッジを維持する（Constitution V準拠）
  - **TDD必須**: すべての新機能はRed-Green-Refactorサイクルに従って実装される（Constitution C010準拠）
  - **コード品質**: ruff（linter）、mypy --strict（型チェック）がすべて通過しなければコミットしない（Constitution C006準拠）
  - **DRY原則**: コードの重複を排除し、共通ロジックは抽象化する（Constitution C012準拠）
- **拡張性**:
  - アーキテクチャは、将来のリリースで新しいドキュメントジェネレータ（Docusaurus、VitePress）の追加をサポート
  - 各ドキュメントツール（Sphinx、MkDocs）は独立したモジュールとして実装され、新しいツールの追加が容易

### フェーズ2以降

- **パフォーマンス（高度な統合）**:
  - LLM API を使用したエンティティ統合は、5機能あたり追加30秒以内
  - 並列処理により複数機能の API 統合を高速化
- **拡張性（AI エージェント）**:
  - 他の AI エージェント（GitHub Copilot、Gemini、Cursor）のサポート追加が可能
