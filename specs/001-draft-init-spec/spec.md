# 機能仕様書: spec-kit-docs - AI駆動型ドキュメント生成システム

**機能ブランチ**: `001-draft-init-spec`
**作成日**: 2025-10-12
**ステータス**: ドラフト
**入力**: ユーザー記述: "draft/init-spec.md を確認し、日本語で要件定義を行ってください"

## Clarifications

### Session 2025-10-12

- Q: `/speckit.doc-init` で初期化されるドキュメント構造は、どのディレクトリ階層を生成すべきですか？ → A: 包括的な構造（`docs/features/`（機能ページ）+ `docs/guides/`（ガイド）+ `docs/api/`（API リファレンス）+ `docs/architecture/`（アーキテクチャ））、ただし5機能以下の小規模プロジェクトはフラット構造も可能
- Q: `/speckit.doc-update` のインクリメンタル更新で、「変更されたファイル」をどのように検出しますか？ → A: Git の変更履歴を使用（git diff で前回のコミットから変更されたファイルを検出）
- Q: plan.md や tasks.md が欠落している場合、生成されるドキュメントにどのような形式で注記を表示しますか？ → A: 視覚的に明確なアドモニション（MyST構文の ` ```{note}` や MkDocs の `!!! note` を使用）
- Q: `docs/features/` 内の機能ページファイルは、どのような命名規則にしますか？ → A: 説明的な名前のみ（`user-auth.md`, `api-integration.md`、番号なし）
- Q: 「小規模プロジェクト」としてフラット構造を使用する判定基準は、機能数がいくつ以下ですか？ → A: 5機能以下
- Q: SphinxでreStructuredText (.rst) とMarkdown (.md) のどちらをデフォルト形式にしますか？ → A: Markdown (.md) + myst-parser をデフォルトにする。理由：(1) spec-kitのすべてのソースファイル（spec.md、plan.md、tasks.md）がMarkdownであり、フォーマット統一により変換ロジックが不要、(2) ユーザーの学習コストを削減（reStructuredText構文の習得が不要）、(3) 生成後のドキュメントをユーザーが手動編集する際の利便性向上、(4) MyST Markdownは業界標準となりつつあり、Sphinxのほぼ全機能をサポート

## ユーザーシナリオとテスト *(必須)*

### ユーザーストーリー1: ドキュメントプロジェクトの初期化 (優先度: P1) 🎯 MVP

**目的**: spec-kitユーザーが、単一コマンドでドキュメントプロジェクトを初期化し、Sphinx または MkDocs のいずれかを選択し、インタラクティブに設定を構成できるようにすることで、手動でディレクトリを作成したり設定ファイルを編集したりすることなく、プロジェクトに適したドキュメント基盤を確立できるようにします。

**この優先度の理由**: ドキュメント生成の前提条件です。初期化がなければ、更新するドキュメント構造が存在しません。これはワークフローの最初のステップです。

**独立テスト**: ユーザーが spec-kit プロジェクトで `/speckit.doc-init --type sphinx` を実行します。システムはプロジェクト名、著者名、バージョンを対話的に尋ねます。完了後、`docs/` ディレクトリが作成され、Sphinx の設定ファイル（`conf.py`、`index.rst`）と基本構造が含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: 有効な spec-kit プロジェクト（`.specify/` ディレクトリを持つ）、**実行**: ユーザーが `/speckit.doc-init --type sphinx` を実行、**期待結果**: システムが対話的にプロジェクト名、著者名、バージョン、言語を尋ね、回答に基づいて `docs/` に Sphinx プロジェクトを作成し、`conf.py`、`index.rst`、`Makefile`、必要なディレクトリ構造を含む

2. **前提条件**: 有効な spec-kit プロジェクト、**実行**: ユーザーが `/speckit.doc-init --type mkdocs` を実行、**期待結果**: システムが対話的に設定を尋ね、`docs/` に MkDocs プロジェクトを作成し、`mkdocs.yml`、`docs/index.md`、必要なディレクトリ構造を含む

3. **前提条件**: spec-kit プロジェクト、**実行**: ユーザーが type 引数なしで `/speckit.doc-init` を実行、**期待結果**: システムが「どのドキュメントツールを使用しますか？ (sphinx/mkdocs)」と尋ね、ユーザーの選択に基づいて初期化を続行

4. **前提条件**: 既に `docs/` ディレクトリが存在するプロジェクト、**実行**: ユーザーが初期化を試みる、**期待結果**: システムが警告を表示:「docs/ ディレクトリは既に存在します。上書きしますか？ (yes/no)」、拒否された場合は既存の構造を保持

5. **前提条件**: spec-kit プロジェクトではないディレクトリ（`.specify/` なし）、**実行**: ユーザーが初期化を試みる、**期待結果**: システムがエラーを表示:「spec-kit プロジェクトではありません。最初に 'specify init' を実行してください。」

6. **前提条件**: 初期化が完了したプロジェクト、**実行**: ユーザーが `docs/` ディレクトリを確認、**期待結果**: 選択したドキュメントツールに応じた標準的なディレクトリ構造、設定ファイル、プレースホルダーコンテンツが含まれ、すぐにビルド可能な状態

---

### ユーザーストーリー2: spec-kit 仕様からのドキュメント更新 (優先度: P1) 🎯 MVP

**目的**: ドキュメントプロジェクトを初期化した spec-kit ユーザーが、`.specify/specs/` ディレクトリから最新の仕様情報を明示的にドキュメントに統合できるようにすることで、spec.md、plan.md、tasks.md の変更を手動でコピー＆ペーストすることなく、ドキュメントを最新の状態に保つことができるようにします。

**この優先度の理由**: これは初期化の直接的な続きです。初期化後、ユーザーは実際のコンテンツでドキュメントを埋める必要があります。自動化はせず、ユーザーが制御できるようにします。

**独立テスト**: 3つの機能（001-user-auth、002-api-integration、003-notifications）を持つ spec-kit プロジェクトで `/speckit.doc-init` を実行後、`/speckit.doc-update` を実行します。システムは各機能の spec.md、plan.md、tasks.md から情報を抽出し、ドキュメント構造に統合します。生成されたドキュメントをビルドして、3つの機能すべての情報が含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: `/speckit.doc-init` で初期化された Sphinx プロジェクト、3つの機能（各ディレクトリに spec.md と plan.md を含む）、**実行**: ユーザーが `/speckit.doc-update` を実行、**期待結果**: システムが `docs/features/` に各機能のページを作成し、spec.md からのユーザーストーリーと要件、plan.md からのアーキテクチャ情報を含み、`index.rst` に機能リストを追加

2. **前提条件**: 初期化された MkDocs プロジェクト、機能仕様、**実行**: `/speckit.doc-update` を実行、**期待結果**: システムが `docs/features/*.md` ファイルを作成し、`mkdocs.yml` の nav セクションを更新して新しいページを含める

3. **前提条件**: spec.md のみを持つ機能（plan.md や tasks.md がない）、**実行**: 更新を実行、**期待結果**: システムが利用可能な情報から機能ページを生成し、欠落しているセクションについて「[このセクションはまだ利用できません]」などの注記を表示

4. **前提条件**: `.specify/specs/` ディレクトリが空または存在しない、**実行**: ユーザーが更新を試みる、**期待結果**: システムがエラーを表示:「仕様が見つかりません。最初に /speckit.specify を実行して機能仕様を作成してください。」

5. **前提条件**: `docs/` ディレクトリが初期化されていない、**実行**: ユーザーが `/speckit.doc-update` を実行、**期待結果**: システムがエラーを表示:「ドキュメントプロジェクトが見つかりません。最初に /speckit.doc-init を実行してください。」

6. **前提条件**: 前回の更新以降に変更された機能仕様、**実行**: `/speckit.doc-update` を再実行、**期待結果**: システムが変更された機能のページのみを更新し、変更されていないページは保持し、「3つの機能が更新されました、2つは変更なし」などの更新サマリーを表示

---

### ユーザーストーリー3: spec-kit 拡張機能としてのインストール (優先度: P1) 🎯 MVP

**目的**: spec-kit ユーザーが、既存の spec-kit プロジェクトに spec-kit-docs を拡張機能として簡単なコマンドでインストールできるようにすることで、複雑な設定なしに AI エージェント（Claude Code）で `/speckit.doc-init` と `/speckit.doc-update` コマンドにアクセスできるようにします。

**この優先度の理由**: ユーザーはツールを使用する前にインストールできる必要があります。これは他のすべての機能の前提条件です。

**独立テスト**: 既存の spec-kit プロジェクトを持つユーザーがインストールコマンドを実行します。インストール後、Claude Code で `/speckit.doc-init` と `/speckit.doc-update` を実行でき、エラーなくコマンドが実行されることを確認します。

**受け入れシナリオ**:

1. **前提条件**: spec-kit プロジェクトとして初期化されたディレクトリ（`.specify/` と `.claude/` ディレクトリを持つ）、**実行**: ユーザーがプロジェクトルートからインストールコマンドを実行、**期待結果**: システムが `.claude/commands/` にドキュメントコマンド定義（`speckit.doc-init.md` と `speckit.doc-update.md`）を追加し、必要なスクリプトを `.specify/scripts/docs/` にコピーし、インストール成功を確認

2. **前提条件**: spec-kit-docs をインストールしたユーザー、**実行**: プロジェクトディレクトリで Claude Code を開き、`/speckit` と入力、**期待結果**: `/speckit.specify`、`/speckit.plan` などと並んで、利用可能なコマンドリストに `/speckit.doc-init` と `/speckit.doc-update` が表示される

3. **前提条件**: spec-kit プロジェクトではないディレクトリ（`.specify/` ディレクトリなし）、**実行**: ユーザーがインストールを試みる、**期待結果**: システムがエラーを表示:「spec-kit プロジェクトではありません。最初に 'specify init' を実行してください。」

4. **前提条件**: 既にインストールされている spec-kit-docs 拡張機能、**実行**: ユーザーが再度インストールを実行、**期待結果**: システムが既存のインストールを検出し、上書き前に確認を求め、拒否された場合はユーザーのカスタマイズを保持

---

### ユーザーストーリー4: インテリジェントな複数機能の統合 (優先度: P2)

**目的**: 複数の進化する機能を持つspec-kitユーザーが、エンティティとAPIが時間とともにどのように進化するかを追跡しながら、システムが機能間の情報を自動的に統合できるようにすることで、ドキュメントが機能ごとの断片的なスナップショットではなく、プロダクトの現在の統一された状態を反映するようにします。

**この優先度の理由**: これは単純なファイル連結とこのツールを差別化するものです。AI駆動の統合の真の価値を提供しますが、基本的なドキュメント生成には必須ではありません。

**独立テスト**: 001-coreでUser{id, name, email}を定義し、003-profilesでUser.profile_pictureを追加するプロジェクトを作成します。生成されたドキュメントは、導入バージョンでマークされたすべてのフィールドを持つ単一の統合Userエンティティを示します。ドキュメントに2つの別々の矛盾するUser定義が表示されないことを確認します。

**受け入れシナリオ**:

1. **前提条件**: 001/data-model.mdがUserエンティティをフィールド[id, name, email]で定義し、003/data-model.mdがUserに[profile_picture, bio]を追加、**実行**: 統合を有効にしてドキュメントが生成される、**期待結果**: データモデルセクションに5つすべてのフィールドを持つ単一の統合Userエンティティが表示され、各フィールドを導入した機能で注釈が付けられる

2. **前提条件**: 001/contracts/api.jsonがエンドポイント[POST /users, GET /users/{id}]を定義し、003/contracts/extended-api.jsonが[PUT /users/{id}/profile, GET /users/{id}/activity]を追加、**実行**: 統合が実行される、**期待結果**: APIリファレンスセクションが4つすべてのエンドポイントをリソースごとにグループ化してリストし、各エンドポイントを導入した機能を示すメモが含まれる

3. **前提条件**: 001がTaskStatus列挙型を[todo, done]と定義し、003が[todo, in_progress, review, done]に拡張、**実行**: 統合がこの進化を検出、**期待結果**: ドキュメントが4つすべての値を持つ現在の列挙型を示し、メモが含まれる:「機能003でin_progressとreview状態を追加するために拡張されました。」

4. **前提条件**: 同じエンティティを互換性のない方法で変更する2つの機能(例:フィールドタイプがstringからenumに変更)、**実行**: 統合がそれらをマージしようとする、**期待結果**: システムが競合を検出し、時間ベースの解決(後の機能が優先)を適用し、ドキュメントに「Breaking Change」注釈を追加

---

### ユーザーストーリー5: 対象者別ドキュメント (優先度: P3)

**目的**: 異なるステークホルダー向けのドキュメントを準備するspec-kitユーザーが、エンドユーザー、外部開発者、コントリビューター向けに別々のドキュメントバージョンを生成できるようにすることで、各対象者が無関係な技術的詳細や内部実装メモに圧倒されることなく、ニーズに適した情報を受け取れるようにします。

**この優先度の理由**: 価値はありますが、ユーザーは最初は手動でコンテンツをフィルタリングできます。これは使いやすさを向上させますが、基本機能には必須ではありません。

**独立テスト**: --audience=enduserフラグでドキュメントを生成します。plan.mdからの技術的アーキテクチャの詳細とtasks.mdからの内部タスクの内訳が除外され、spec.mdからの機能説明が含まれていることを確認します。次に--audience=developerで生成し、APIコントラクトとデータモデルが含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: spec.md、plan.md、tasks.md、data-model.md、contracts/を含む完全な機能仕様を持つプロジェクト、**実行**: ユーザーが--audience=enduserでドキュメントを生成、**期待結果**: 出力に機能説明とクイックスタートガイドが含まれるが、技術的アーキテクチャ、タスクの内訳、実装の詳細は除外される

2. **前提条件**: 同じプロジェクト、**実行**: ユーザーが--audience=developerでドキュメントを生成、**期待結果**: 出力に完全なAPI仕様、データモデルの詳細、アーキテクチャの決定、実装ステータスに関係なくすべての機能が含まれる(実装済み/進行中/計画済みとしてマーク)

3. **前提条件**: 同じプロジェクト、**実行**: ユーザーが--audience=contributorでドキュメントを生成、**期待結果**: 出力にすべてが含まれる:機能仕様、アーキテクチャ、データモデル、API、タスクの内訳、実装ガイドライン、開発セットアップ手順

4. **前提条件**: gitブランチステータスを介して「進行中」とマークされた機能、**実行**: --audience=enduserドキュメントの生成、**期待結果**: その機能が出力から除外されるが、--audience=developerドキュメントの生成時には、「(進行中)」ステータスバッジ付きで機能が含まれる

---

### ユーザーストーリー6: バージョン履歴とトレーサビリティ (優先度: P3)

**目的**: 成長するプロダクトを維持するspec-kitユーザーが、明確なバージョン履歴とともに、エンティティとAPIが機能間でどのように進化したかを確認できるようにすることで、プロダクトの進化を理解し、破壊的変更を伝え、コントリビューターがアーキテクチャの決定を理解するのを支援できるようにします。

**この優先度の理由**: これは基本的なドキュメントニーズには必須ではない、プロフェッショナルな仕上げを追加する便利な拡張機能です。

**独立テスト**: 3つの機能にわたってUserエンティティが変更されたプロジェクトのドキュメントを生成します。Userエンティティのドキュメントに、各機能で何が変更され、なぜ変更されたかを示す「バージョン履歴」セクションが含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: Userエンティティが3つの機能にわたって進化(001:基本フィールドで作成、002:profile_picture追加、003:privacy_settings追加)、**実行**: ドキュメントが生成される、**期待結果**: Userエンティティページに、何が変更されたかを示し、各変更を導入した機能仕様にリンクする3つのエントリを持つ「バージョン履歴」セクションが含まれる

2. **前提条件**: 003でオプションのクエリパラメータを追加するために変更されたAPIエンドポイント/users/{id}、**実行**: ドキュメントが生成される、**期待結果**: エンドポイントドキュメントに変更履歴メモが含まれる:「003で更新:オプションの?include=profile,activityクエリパラメータを追加。」

3. **前提条件**: spec.mdの「根拠」または「前提条件」セクションを参照する機能、**実行**: ドキュメントを統合、**期待結果**: システムがこれらのコンテキストメモを抽出して保持し、関連セクション(例:特定のエンティティ構造が選ばれた理由)に含める

4. **前提条件**: 機能003がTaskStatus列挙値を変更した破壊的変更、**実行**: ドキュメントが生成される、**期待結果**: 破壊的変更が「⚠️ Breaking Change (v003)」バッジと何が変更されたかの説明で明確にフラグ付けされる

---

### エッジケース

- **空の機能ディレクトリ**: 機能フォルダーは存在するがmarkdownファイルがない → 静かにスキップするかユーザーに警告
- **不正なmarkdown**: spec.mdファイルに無効なmarkdown構文がある → 他のファイルの処理を継続し、ファイルパスとともに警告をログ
- **依存関係の欠落**: 機能が以前のどの機能にも存在しないエンティティやAPIを参照している → ドキュメントで潜在的な問題としてフラグ
- **循環依存**: 機能Aが機能Bを参照し、機能Bが機能Aを参照 → サイクルを検出して切断し、関係をドキュメント化
- **非常に大きなプロジェクト**: 数百ページの仕様を持つ50以上の機能 → 段階的に処理し、進行状況を表示し、メモリ使用を最適化
- **非標準のファイル名**: ユーザーがspecs/に追加ファイルを手動で作成 → 予期されるパターンに一致する場合(機能ディレクトリ内の*.md)は含め、それ以外は無視
- **gitブランチの状態**: 機能ブランチが存在するがmainにマージされていない → 実装ステータスを決定し、ドキュメントで適切にマーク
- **複数のコントラクト形式**: 一部の機能はOpenAPI JSONを使用し、他はmarkdownテーブルを使用 → 両方の形式を解析し、統一された表現に正規化
- **部分的な機能仕様**: 機能にspec.mdはあるがplan.mdまたはdata-model.mdがない → 利用可能なファイルからドキュメントを生成し、欠落しているアーティファクトに注意
- **競合するタイムスタンプ**: gitが機能003が002の前にコミットされたことを示す → gitタイムスタンプではなく機能番号を真実の源として使用
- **カスタムテンプレート**: ユーザーがプロジェクト内のspec-template.mdを変更 → 解析時にカスタムセクションを尊重し、フォールバックとして標準セクションを使用

## 要件 *(必須)*

### 機能要件

#### /speckit.doc-init コマンド

- **FR-001**: システムは、プロジェクトルートに `.specify/` ディレクトリが存在することを確認し、spec-kit プロジェクトであることを検証しなければならない
- **FR-002**: システムは、`--type` 引数または対話的プロンプトを通じて、ドキュメントツールの選択（sphinx または mkdocs）をサポートしなければならない
- **FR-003**: システムは、Sphinx 初期化の場合、プロジェクト名、著者名、バージョン、言語設定を対話的に収集しなければならない
- **FR-004**: システムは、MkDocs 初期化の場合、プロジェクト名、サイト名、リポジトリURLを対話的に収集しなければならない
- **FR-005**: システムは、Sphinx の場合、`docs/` ディレクトリに `conf.py`（myst-parser設定を含む）、`index.md`、`Makefile`、`make.bat`、および以下のディレクトリ構造を生成しなければならない。すべてのファイルはMarkdown形式（.md）で、MyST Markdown構文をサポート：
  - 5機能以下の小規模プロジェクト：フラット構造（`docs/` 直下に機能ページ）
  - 6機能以上のプロジェクト：包括的な構造（`docs/features/`、`docs/guides/`、`docs/api/`、`docs/architecture/`）
- **FR-005a**: システムは、Sphinx初期化時に`conf.py`でmyst-parserを有効化し、Markdown（.md）ファイルを解析できるように設定しなければならない。具体的には：
  - `extensions`に`'myst_parser'`を追加
  - `source_suffix`に`.md`を含める（`.rst`もサポート）
  - MyST Markdownの拡張機能（colon_fence、deflist、tasklist、attrs_inline等）を有効化
- **FR-006**: システムは、MkDocs の場合、`docs/` ディレクトリに `mkdocs.yml`、`docs/index.md`、および以下のディレクトリ構造を生成しなければならない：
  - 5機能以下の小規模プロジェクト：フラット構造（`docs/` 直下に機能ページ）
  - 6機能以上のプロジェクト：包括的な構造（`docs/features/`、`docs/guides/`、`docs/api/`、`docs/architecture/`）
- **FR-007**: システムは、`docs/` ディレクトリが既に存在する場合、上書き確認を求め、ユーザーが拒否した場合は既存の構造を保持しなければならない
- **FR-008**: システムは、選択したツールに必要な Python パッケージ（Sphinxの場合：sphinx + myst-parser、MkDocsの場合：mkdocs）をインストール手順とともに通知しなければならない
- **FR-009**: システムは、初期化後すぐにビルド可能な最小限のドキュメント構造を作成しなければならない

#### /speckit.doc-update コマンド

- **FR-010**: システムは、`docs/` ディレクトリが存在し、有効なドキュメントプロジェクト（`conf.py` または `mkdocs.yml`）であることを検証しなければならない
- **FR-011**: システムは、少なくとも spec.md ファイルを含む `.specify/specs/` 配下のすべての機能ディレクトリを発見しなければならない
- **FR-012**: システムは、markdown ファイル（spec.md、plan.md、tasks.md、data-model.md）を解析し、見出し、リスト、テーブル、コードブロックを含む構造化されたコンテンツを抽出しなければならない
- **FR-013**: システムは、Sphinx プロジェクトの場合、各機能の `.md` ファイル（MyST Markdown形式）を生成し、`index.md` の toctree に追加しなければならない。ファイル命名規則：機能ディレクトリ名から番号を除いた説明的な名前（例：`001-user-auth` → `user-auth.md`）。小規模プロジェクト（5機能以下）は `docs/` 直下、大規模プロジェクトは `docs/features/` 内に配置
- **FR-014**: システムは、MkDocs プロジェクトの場合、各機能の `.md` ファイルを生成し、`mkdocs.yml` の nav セクションに追加しなければならない。ファイル命名規則：機能ディレクトリ名から番号を除いた説明的な名前（例：`001-user-auth` → `user-auth.md`）。小規模プロジェクト（5機能以下）は `docs/` 直下、大規模プロジェクトは `docs/features/` 内に配置
- **FR-015**: システムは、spec.md からのすべてのセクション（ユーザーシナリオ、要件、成功基準、エッジケース）を含む元のコンテンツを保持しなければならない
- **FR-016**: システムは、plan.md が存在する場合、アーキテクチャセクションと技術的決定をドキュメントに含めなければならない
- **FR-017**: システムは、tasks.md が存在する場合、実装タスクの概要をドキュメントに含めなければならない
- **FR-018**: システムは、欠落しているファイル（plan.md や tasks.md がない）がある機能について、利用可能なコンテンツからドキュメントを生成し、欠落セクションには視覚的に明確なアドモニション（Sphinx の `.. note::` や MkDocs の `!!! note`）形式で注記を追加しなければならない
- **FR-019**: システムは、Git の変更履歴（git diff）を使用して前回の更新以降に変更されたファイルのみを検出し、変更されたファイルのみを再処理し、変更されていないファイルは保持しなければならない
- **FR-020**: システムは、更新後に何個の機能が更新され、何個が変更なしだったかを示すサマリーを表示しなければならない

#### インストールとプロジェクト構造

- **FR-021**: システムは、`.claude/` ディレクトリを確認することで使用中の AI エージェント（最初は Claude Code）を検出し、適切な場所にコマンド定義をインストールしなければならない
- **FR-022**: システムは、インストール時に `.claude/commands/speckit.doc-init.md` と `.claude/commands/speckit.doc-update.md` の2つのコマンド定義を作成しなければならない
- **FR-023**: システムは、インストール時に必要なスクリプトを `.specify/scripts/docs/` にコピーしなければならない
- **FR-024**: システムは、コンテンツを統合する際に時間的順序を決定するために、機能ディレクトリの番号付け（001、002、003）を使用しなければならない

#### 高度な機能（将来のフェーズ）

- **FR-025**: システムは、複数の data-model.md ファイルからエンティティ定義を統合し、現在の状態と進化を示す統一されたデータモデルを生成しなければならない（P2）
- **FR-026**: システムは、複数の機能の contracts/ ディレクトリから API 仕様をマージし、統一された API リファレンスを生成しなければならない（P2）
- **FR-027**: システムは、競合する情報（例：同じエンティティの異なる定義）を検出し、最新優先戦略を使用して解決しなければならない（P2）
- **FR-028**: システムは、各要素を導入または変更した機能を示すために、統合されたコンテンツに注釈を付けなければならない（P2）
- **FR-029**: システムは、対象者パラメータに基づいてコンテンツをフィルタリングしなければならない：enduser（機能と使用法のみ）、developer（API とアーキテクチャ）、contributor（すべて）（P3）
- **FR-030**: システムは、機能の実装ステータスを決定するために git リポジトリの状態を確認しなければならない（main にマージ済み=実装済み、ブランチとして存在=進行中、ブランチなし=計画済み）（P3）
- **FR-031**: システムは、機能間での進化を示すエンティティと API のバージョン履歴セクションを生成しなければならない（P3）
- **FR-032**: システムは、破壊的変更（タイプの変更、削除されたフィールド、変更された列挙型）を警告バッジでフラグ付けしなければならない（P3）

#### エラーハンドリングと品質

- **FR-033**: システムは、一般的な問題に対して明確なエラーメッセージを提供しなければならない：spec-kit プロジェクトではない、ドキュメントプロジェクトが初期化されていない、機能が見つからない、不正なファイル
- **FR-034**: システムは、オフラインで表示でき、任意の Web サーバーでホストできる静的 HTML ファイルとしてドキュメントを生成しなければならない
- **FR-035**: システムは、不正な markdown を適切に処理し、他のファイルの処理を継続し、特定のエラーを報告しなければならない

### 主要エンティティ *(機能がデータを含む場合に含める)*

- **SpecKitProject**: spec-kitプロジェクトを表し、ルートディレクトリ、.specify/設定、specs/ディレクトリを含む
- **Feature**: 単一の機能仕様(例:001-user-auth)で、markdownファイルのコレクション、コントラクト、実装ステータスを含む
- **Entity**: data-model.mdファイルから抽出されたデータモデルエンティティ(例:User、Task)で、フィールド、タイプ、バージョン履歴を含む
- **APIEndpoint**: contracts/からのAPIエンドポイント定義で、メソッド、パス、パラメータ、バージョン履歴を含む
- **DocumentationSite**: ページ、ナビゲーション、アセットを含む生成された出力構造
- **Audience**: 関連するコンテンツフィルタリングルールを持つターゲットオーディエンス(enduser、developer、contributor)の列挙型
- **SynthesisResult**: 機能間でマージした後のエンティティとAPIの統合ビュー
- **FeatureStatus**: gitブランチステータスから派生した実装状態(implemented、in_progress、planned)の列挙型

## 成功基準 *(必須)*

### 測定可能な成果

#### /speckit.doc-init コマンド

- **SC-001**: ユーザーは `/speckit.doc-init` を実行してから完了まで30秒以内にドキュメントプロジェクトを初期化できる（対話的な入力時間を除く）
- **SC-002**: 初期化されたドキュメントプロジェクトは、追加設定なしでビルドコマンド（`make html` または `mkdocs build`）が成功する
- **SC-003**: Sphinx と MkDocs の両方のドキュメントツールが正しくサポートされ、それぞれの標準的なプロジェクト構造が生成される
- **SC-004**: 既存の `docs/` ディレクトリを持つプロジェクトで初期化を試みた場合、100% のケースで上書き確認が表示される
- **SC-005**: インタラクティブプロンプトで収集された設定（プロジェクト名、著者名など）が生成された設定ファイルに正確に反映される

#### /speckit.doc-update コマンド

- **SC-006**: ユーザーは5機能のプロジェクトで `/speckit.doc-update` を実行してから45秒以内にドキュメントを更新できる（AI統合時間を除く）
- **SC-007**: 生成されたドキュメントサイトは、Web サーバーを必要とせずに任意のモダン Web ブラウザでナビゲート可能で読みやすい
- **SC-008**: spec.md からのすべてのセクション（ユーザーシナリオ、要件、成功基準、エッジケース）の95%以上が、生成されたドキュメントに正しく含まれる
- **SC-009**: plan.md と tasks.md が存在する機能について、それらのコンテンツの90%以上がドキュメントに統合される
- **SC-010**: 機能に欠落しているファイル（例：plan.md がない）がある場合でも、ドキュメント更新が成功し、利用可能なコンテンツを含み、欠落セクションに適切な注記が表示される
- **SC-011**: 前回の更新以降に変更されていない機能について、システムが再処理をスキップし、更新サマリーに正確な変更/未変更の件数が表示される
- **SC-012**: 更新後のドキュメントは、適切なタイポグラフィ、コードハイライト、レスポンシブレイアウトを備えた視覚的にプロフェッショナルである

#### インストールと統合

- **SC-013**: 新しい spec-kit プロジェクトでのインストールが10秒以内に正常に完了する
- **SC-014**: ユーザーはインストール直後に追加設定なしで Claude Code で `/speckit.doc-init` と `/speckit.doc-update` を実行できる
- **SC-015**: インストールされた2つのコマンド定義が Claude Code のコマンドリストに正しく表示される

#### 高度な機能（将来のフェーズ）

- **SC-016**: すべての機能からのエンティティフィールドと API エンドポイントの95%が、統合されたドキュメントに正しく含まれる（P2）
- **SC-017**: エンティティの進化が少なくとも3つの機能にわたって正確に追跡され、何がいつ変更されたかを示す変更履歴が表示される（P2）
- **SC-018**: enduser ドキュメントは、技術的実装の詳細（plan.md のアーキテクチャセクション、tasks.md）を100%除外する（P3）
- **SC-019**: developer ドキュメントは、実装ステータスに関係なく、API エンドポイントとデータモデルエンティティを100%含む（P3）
- **SC-020**: 破壊的変更は、エンティティまたは API 定義が互換性のない方法で変更された場合の少なくとも90%で正しく識別され、フラグ付けされる（P3）
- **SC-021**: システムは、標準的なケース（マージ済み、ブランチが存在、ブランチなし）の100%で、git ブランチ状態から機能の実装ステータスを正しく決定する（P3）

## スコープ境界 *(オプション)*

**スコープ内（フェーズ1 - MVP）**:
- `/speckit.doc-init` コマンド：ドキュメントプロジェクトの初期化
  - Sphinx および MkDocs のサポート（`--type` 引数で選択）
  - インタラクティブな設定収集（プロジェクト名、著者、バージョン）
  - 標準的なディレクトリ構造とビルド可能な設定ファイルの生成
  - 既存 `docs/` ディレクトリの上書き確認
- `/speckit.doc-update` コマンド：spec-kit 仕様からのドキュメント更新
  - markdown ファイル解析（spec.md、plan.md、tasks.md）
  - Sphinx（.rst）および MkDocs（.md）形式でのドキュメントページ生成
  - 機能ページの自動生成と目次への追加
  - インクリメンタル更新（変更されたファイルのみを再処理）
  - 欠落ファイルの適切な処理と注記
- 既存の spec-kit プロジェクトへの拡張機能としてのインストール
- Claude Code AI エージェントのサポート
- 機能ディレクトリの番号付け（001、002、003）による時系列順序の維持

**スコープ内（フェーズ2 - 高度な統合）**:
- エンティティ統合と競合解決のための LLM API を使用した AI 駆動の統合
- 複数の data-model.md ファイルからのエンティティ定義の統合
- 複数の機能の contracts/ ディレクトリからの API 仕様のマージ
- 統合されたコンテンツへの機能トレーサビリティ注釈
- 競合する情報の検出と解決（最新優先戦略）

**スコープ内（フェーズ3 - 高度な機能）**:
- 対象者別フィルタリング（enduser、developer、contributor）
- git ブランチステータスからの実装ステータス検出
- 機能間のバージョン履歴追跡
- 破壊的変更の自動検出とフラグ付け

**スコープ外（将来のフェーズ）**:
- 他のドキュメントジェネレータ（Docusaurus、VitePress）のサポート - 将来検討
- 他の AI エージェント（GitHub Copilot、Gemini、Cursor）のサポート - 将来検討
- インタラクティブなドキュメント機能（検索、フィルタリング、ライブ例） - 将来検討
- 多言語ドキュメント生成（i18n） - 将来検討
- ホスティングとデプロイの自動化（GitHub Pages、Netlify） - 将来検討
- カスタムテーマとブランディング - 将来検討
- PDF と ePub エクスポート - 将来検討
- API ドキュメントテスト（実行中の API に対するコントラクトの検証） - 将来検討
- ドキュメントのバージョン管理（複数のプロダクトバージョンのドキュメントの維持） - 将来検討

## 前提条件 *(オプション)*

### フェーズ1（MVP）の前提条件

1. **spec-kit プロジェクト**: ユーザーは有効な spec-kit プロジェクト（`.specify/` と `.claude/` ディレクトリを持つ）を持っている
2. **仕様フォーマット**: ユーザーは、期待されるセクション見出しを持つ spec.md、plan.md、tasks.md の標準 spec-kit テンプレートに従う
3. **機能番号付け**: 機能は順番に番号付けされ（001、002、003）、番号は時系列順を反映する
4. **AI エージェントのコンテキスト**: Claude Code はコマンド定義の scripts: frontmatter 経由でシェルスクリプトを実行できる
5. **markdown 規則**: markdown ファイルは GitHub Flavored Markdown 拡張を含む標準 CommonMark 構文を使用する
6. **プロジェクト構造**: spec-kit プロジェクトは、機能ディレクトリを含む `.specify/specs/` を持つ標準構造に従う
7. **コマンドの可用性**: ユーザーは環境で必要な依存関係（Python 3.11+、Sphinxの場合：sphinx + myst-parser、MkDocsの場合：mkdocs）を利用可能、またはインストールできる
8. **ファイルシステムアクセス**: ツールは `.specify/` ディレクトリへの読み取りアクセスと `docs/` ディレクトリへの書き込みアクセスを持つ
9. **ネットワークアクセス**: インストールは PyPI からパッケージをダウンロードできる
10. **合理的な規模**: ほとんどのプロジェクトは1-20機能を持つ；50以上の機能の最適化は便利な追加機能
11. **言語**: 仕様は主に日本語または英語で書かれる；多言語サポートは将来の作業
12. **Git 使用**: プロジェクトは git リポジトリである必要がある（インクリメンタル更新での変更検出に git diff を使用）

### フェーズ2以降の追加前提条件

13. **Git ブランチング**: プロジェクトは標準ブランチング（機能ブランチが main にマージ）で git を使用する（実装ステータス検出に必要）
14. **LLM アクセス**: ユーザーは、十分なレート制限を持つ統合機能用の LLM API（Claude、GPT-4）へのアクセスを持つ（AI 駆動の統合に必要）
15. **data-model.md と contracts/**: 高度な統合機能を使用する場合、機能は data-model.md や contracts/ ディレクトリを含む
16. **一貫したエンティティ命名**: 機能間で統合されるエンティティは一貫した命名を使用する（例：User、user_entity ではなく User）

## 非機能要件 *(オプション)*

### フェーズ1（MVP）

- **パフォーマンス**:
  - `/speckit.doc-init` は30秒以内に完了する（対話的入力時間を除く）
  - `/speckit.doc-update` は、最大10機能のプロジェクトで45秒以内に完了する
  - インクリメンタル更新により、変更されていない機能の再処理を回避
- **信頼性**:
  - システムは不正な markdown を適切に処理し、他のファイルの処理を継続し、特定のエラーを報告する
  - 欠落しているファイル（plan.md、tasks.md）がある場合でも処理を継続
  - 初期化中にエラーが発生した場合、部分的なディレクトリ構造を残さない（ロールバック）
- **使いやすさ**:
  - インストールは手動設定なしで単一コマンドを必要とする
  - `/speckit.doc-init` はインタラクティブプロンプトで設定を収集し、手動での設定ファイル編集を不要にする
  - `/speckit.doc-update` は単一のコマンドですべての機能を更新する
  - 明確なエラーメッセージと次のステップの提案を提供
- **互換性**:
  - spec-kit 0.0.19+ および Python 3.11+ で動作する
  - Sphinx 7.0+ および myst-parser 2.0+（Sphinx使用時）
  - MkDocs 1.5+（MkDocs使用時）をサポート
- **保守性**:
  - プラグインアーキテクチャにより、spec-kit コアの変更を必要とせずに更新が可能
  - 2つの独立したコマンド（`doc-init` と `doc-update`）により、各機能を個別に保守可能
- **拡張性**:
  - アーキテクチャは、将来のリリースで新しいドキュメントジェネレータ（Docusaurus、VitePress）の追加をサポート
  - 各ドキュメントツール（Sphinx、MkDocs）は独立したモジュールとして実装され、新しいツールの追加が容易

### フェーズ2以降

- **パフォーマンス（高度な統合）**:
  - LLM API を使用したエンティティ統合は、5機能あたり追加30秒以内
  - 並列処理により複数機能の API 統合を高速化
- **拡張性（AI エージェント）**:
  - 他の AI エージェント（GitHub Copilot、Gemini、Cursor）のサポート追加が可能
