# 機能仕様書: spec-kit-docs - AI駆動型ドキュメント生成システム

**機能ブランチ**: `001-draft-init-spec`
**作成日**: 2025-10-12
**ステータス**: ドラフト
**入力**: ユーザー記述: "draft/init-spec.md を確認し、日本語で要件定義を行ってください"

## Clarifications

### Session 2025-10-12

- Q: `/speckit.doc-init` で初期化されるドキュメント構造は、どのディレクトリ階層を生成すべきですか？ → A: 包括的な構造（`docs/features/`（機能ページ）+ `docs/guides/`（ガイド）+ `docs/api/`（API リファレンス）+ `docs/architecture/`（アーキテクチャ））、ただし5機能以下の小規模プロジェクトはフラット構造も可能
- Q: `/speckit.doc-update` のインクリメンタル更新で、「変更されたファイル」をどのように検出しますか？ → A: Git の変更履歴を使用（git diff で前回のコミットから変更されたファイルを検出）
- Q: plan.md や tasks.md が欠落している場合、生成されるドキュメントにどのような形式で注記を表示しますか？ → A: 視覚的に明確なアドモニション（MyST構文の ` ```{note}` や MkDocs の `!!! note` を使用）
- Q: `docs/features/` 内の機能ページファイルは、どのような命名規則にしますか？ → A: 説明的な名前のみ（`user-auth.md`, `api-integration.md`、番号なし）
- Q: 「小規模プロジェクト」としてフラット構造を使用する判定基準は、機能数がいくつ以下ですか？ → A: 5機能以下
- Q: SphinxでreStructuredText (.rst) とMarkdown (.md) のどちらをデフォルト形式にしますか？ → A: Markdown (.md) + myst-parser をデフォルトにする。理由：(1) spec-kitのすべてのソースファイル（spec.md、plan.md、tasks.md）がMarkdownであり、フォーマット統一により変換ロジックが不要、(2) ユーザーの学習コストを削減（reStructuredText構文の習得が不要）、(3) 生成後のドキュメントをユーザーが手動編集する際の利便性向上、(4) MyST Markdownは業界標準となりつつあり、Sphinxのほぼ全機能をサポート

### Session 2025-10-12 (Correction)

- **修正1**: spec-kit の公式仕様に基づき、機能仕様ディレクトリの場所を `.specify/specs/` から `specs/` (ルート直下) に修正しました。spec-kit の `scripts/bash/create-new-feature.sh` は `SPECS_DIR="$REPO_ROOT/specs"` を使用しており、`.specify/` は spec-kit 自身の内部ディレクトリ（scripts, templates, memory）であり、ユーザーの機能仕様を配置する場所ではありません。
- **修正2**: Sphinx のデフォルトファイル形式の不整合を解消しました。Session 2025-10-12 の決定（「Markdown (.md) + myst-parser をデフォルトにする」）に基づき、`index.rst` への参照をすべて `index.md` に変更し、Sphinx で生成されるすべてのファイルが Markdown 形式（.md）であることを明確化しました。これにより、spec-kit のソースファイル（spec.md、plan.md、tasks.md）との形式統一が実現されます。

### Session 2025-10-12 (Architecture Clarifications)

- Q: 対話的設定収集（プロジェクト名、著者名等）の責務は、AI エージェント（Claude Code）と Python スクリプト（doc_init.py）のどちらが担うべきか？ → A: オプション A - AI エージェント（Claude Code）が対話的に設定を収集し、スクリプト（doc_init.py）は引数のみを受け取る非対話的実行。理由：(1) Python スクリプトの input() は CI/CD などの非対話的環境で EOFError を起こす、(2) spec-kit の他のコマンド（/speckit.specify, /speckit.plan）と一貫性が保たれる、(3) 拡張性とテスト容易性が向上する
- Q: `.claude/commands/speckit.doc-init.md` コマンド定義の具体的な役割は？ → A: オプション A - コマンド定義は、対話的質問→情報収集→引数構築→スクリプト呼び出し→結果フィードバックの一連のプロンプトを記述。理由：(1) spec-kit の他のコマンド定義と一貫したパターン、(2) Claude Code が自然言語プロンプトからタスクを実行できる、(3) エラーハンドリングとユーザーフィードバックを AI エージェントが担当
- Q: 既存 `docs/` ディレクトリの上書き確認は、AI エージェントとスクリプトのどちらが担うべきか？ → A: オプション A - AI エージェントが事前に `docs/` の存在を確認し、存在する場合はユーザーに上書き確認を取り、確認が取れた場合のみ `--force` フラグ付きでスクリプトを実行。理由：(1) 非対話的環境でスクリプトが動作可能、(2) ユーザーとの対話は AI エージェントが担当するアーキテクチャに一貫、(3) スクリプトは `--force` の有無で動作を制御できテスト容易
- Q: MkDocs 初期化時のデフォルト値（サイト名、リポジトリURL）は？ → A: オプション A - サイト名：プロジェクト名と同じ、リポジトリURL：Git remote origin URL（取得できない場合は空文字列）。理由：(1) Sphinx との一貫性、(2) Git から自動取得可能な情報を活用、(3) 必須でない項目（リポジトリURL）は空でも問題なし
- Q: ディレクトリ構造決定（フラット vs 包括的）の機能数検出タイミングは？ → A: オプション A（自動移行付き）- 初期化時に現在の機能数を検出して構造を決定し、さらに `/doc-update` 実行時にも機能数を再チェックして、フラット構造から包括的構造への移行が必要な場合（機能数が6以上になった場合）は自動的に移行する。理由：(1) プロジェクトの成長に自動的に適応、(2) 小規模プロジェクトは常にシンプルなフラット構造で開始、(3) 逆方向の移行（包括的→フラット）は行わず、破壊的変更を避ける

### Session 2025-10-13 (Install Command Clarifications)

- Q: pyproject.tomlでのspecify-cliの依存関係指定方法は？ → A: オプション A - Git URL直接指定（`dependencies = ["specify-cli @ git+https://github.com/github/spec-kit.git"]`）。理由：specify-cliは公開リポジトリであり、Git URL直接指定で問題なくインストール可能

### Session 2025-10-13 (CLI Design Clarifications)

- Q: CLIツールの設計：どのようなコマンド構造にすべきか（独立したCLIツール vs spec-kitとの統合）？ → A: オプション B - `speckit-docs`コマンドを`specify`コマンドと統合し、`specify add-docs`のようなサブコマンドとして実装する。理由：(1) spec-kitエコシステムの一貫性を最大化、(2) ユーザーの学習コストを削減（新しいCLIツールを覚える必要がない）、(3) `/speckit.doc-init`と`/speckit.doc-update`のスラッシュコマンドは完全に維持される（インストール方法のみが統合され、使用方法は変わらない）
- Q: 配布方法：PyPIへの公開も検討すべきか、それともGitHubのみで十分か？ → A: オプション A - GitHubのみで配布（`uv tool install speckit-docs --from git+https://github.com/drillan/spec-kit-docs.git`）、PyPI公開は将来のフェーズで検討。理由：(1) MVP段階では開発とリリースプロセスをシンプルに保つ、(2) spec-kit自体もGitHubから配布されており、ユーザーは既にこのパターンに慣れている、(3) PyPI公開は追加の保守負担（バージョン管理、リリースプロセス、パッケージメタデータ）があり初期段階では不要
- Q: spec-kitとの統合方法：spec-kitリポジトリに統合すべきか、独立したリポジトリで開発すべきか？ → A: オプション A - 独立したCLIツールとして実装し、spec-kitの`specify`コマンドとは別に`speckit-docs install`を提供（spec-kitとの統合は名目上のみ）。理由：(1) spec-kitリポジトリへのPRは承認が必要で開発スピードが遅くなる可能性がある、(2) 独立したリポジトリで開発することで、spec-kit-docs固有の機能やリリースサイクルを柔軟に管理できる、(3) コマンド体系はspec-kitと一貫性を保ちながら（`specify add-docs`のようなパターン）、実装は独立して進められる
- Q: スラッシュコマンドの生成：CLIツールがどのようにして.claude/commands/にスラッシュコマンドを配置すべきか？ → A: オプション A - `speckit-docs install`コマンドがPythonパッケージ内のテンプレートファイル（`src/speckit_docs/commands/speckit.doc-init.md`, `speckit.doc-update.md`）をユーザープロジェクトの`.claude/commands/`にコピーする。理由：(1) spec-kitの`specify init`と同じパターンに従い実装がシンプル、(2) ユーザーにとって透明性が高く、コピー後のファイルをカスタマイズ可能、(3) importlib.resourcesでパッケージ内テンプレートにアクセスするためオフライン環境でも動作、(4) `--force`オプションで上書き更新が可能、(5) `/speckit.doc-init`と`/speckit.doc-update`としてClaude Codeに認識され、spec-kitの他のコマンドとの命名規則の一貫性を保つ
- Q: 既存プロジェクトへのインストール：`--here`フラグのようなオプションは必要か？ → A: オプション A - カレントディレクトリに自動的にインストール（`cd my-project && speckit-docs install`）、明示的なディレクトリ指定は不要。理由：(1) spec-kit-docsは既存のspec-kitプロジェクトに拡張機能を追加するツールであり、ユーザーは既にプロジェクトルートにいることが前提、(2) 新しいディレクトリを作成することはなく常に既存プロジェクトへの追加なので`--here`フラグも不要、(3) コマンドがシンプルになり使いやすさが向上
- Q: 既存ファイル（.claude/commands/や.specify/scripts/）が存在する場合の動作は？ → A: オプション C - インタラクティブ確認（全体）+ --forceで確認スキップ。理由：(1) spec-kitの本家`specify init --here`パターンと一貫性がある、(2) デフォルトは安全（確認を求める）だが、自動化時は`--force`で対応可能、(3) ユーザーの学習コストを削減
- Q: コマンドテンプレート（doc-init.md, doc-update.md）の配置場所とインストール方法は？ → A: オプション A - `src/speckit_docs/commands/` に配置し、importlib.resourcesでアクセス。理由：(1) 少数のファイル（2つのコマンド定義 + スクリプト）なので、Pythonパッケージに含めるのが適切、(2) オフライン環境でも動作（pip install後にネットワーク不要）、(3) Python標準のパッケージングベストプラクティスに準拠、(4) spec-kitのGitHubダウンロード方式は大量ファイル配布向けでspec-kit-docsには過剰
- Q: インストール失敗時の動作は？ → A: オプション B - ベストエフォート（エラー発生時もそこまでのファイルは残す）。理由：(1) spec-kitの`specify init --here`パターンと一貫性がある（既存ディレクトリへの追加時は部分的な状態を残す）、(2) spec-kit-docsは既存プロジェクトにファイルを追加するだけなので、プロジェクト全体を壊すリスクは低い、(3) ユーザーが手動で修正可能（失敗したファイルを削除して再実行）、(4) トランザクション機構は複雑でMVP範囲を超える
- Q: アンインストール・アップグレード機能は必要か？ → A: オプション D - 機能は提供しない（MVP範囲外）。理由：(1) 本家spec-kitもuninstall/upgrade機能を提供していない（一貫性）、(2) MVPの焦点は「ドキュメント生成」であり、ライフサイクル管理は二次的、(3) 少数のファイルなので手動削除も容易、(4) アップグレードは`speckit-docs install --force`で代替可能、(5) 将来必要になれば追加可能

### Session 2025-10-13 (CLI Framework Re-evaluation)

- Q: CLIフレームワーク選択の再検討：本家spec-kitが**typer**を使用しており、spec-kit-docsも`specify-cli`に依存するため既にtyperが依存ツリーに存在している。Constitution（憲章）のCore Principle I「spec-kit Integration First」に基づき、argparseからtyperに変更すべきか？ → A: **Option B (typerに変更)** - 本家spec-kitとの一貫性を最優先する。既にtyperに間接依存しており、追加の依存関係はない。ユーザーは一貫したCLI体験を得られ、型ヒントのネイティブサポートも得られる（C006: 堅牢コード品質に準拠）。エラーハンドリングの制御は、本家spec-kitが既に実現しているように、typerでも可能。理由：(1) **Core Principle I (spec-kit Integration First)への準拠** - 「spec-kitの標準パターンと完全に一貫していなければならない」という憲章要件を満たす、(2) **実質的な追加依存なし** - specify-cli経由で既にtyperに間接依存しているため、新しい外部依存は増えない、(3) **型ヒントのネイティブサポート** - Python 3.11+の型ヒント（`int`, `str`, `bool`等）を直接使用でき、mypy互換（C006準拠）、(4) **DRY原則** - 本家spec-kitのtyperパターン（`typer.confirm()`、`typer.Option()`等）を再利用できる（C012準拠）、(5) **Phase 2計画との整合** - research.mdでPhase 2に計画されている「specify-cliからStepTracker/console再利用」がtyper前提であり、一貫性が保たれる

### Session 2025-10-13 (Command Naming & Installation Method)

- Q: コマンド名の標準化：仕様では `/speckit.doc-init` だが README.md では `/doc-init` となっている不整合を解決すべきか？ → A: **Option A (長い形式)** - `/speckit.doc-init`, `/speckit.doc-update` に統一する。理由：spec-kitの付属物という扱いをコマンド名に含めることで、spec-kit エコシステムとの統合を明確にし、他のspec-kitコマンド（`/speckit.specify`, `/speckit.plan`）との命名規則の一貫性を保つ
- Q: インストールコマンドの推奨方法：README.mdに両方（CLIコマンドとPython API呼び出し）が記載されているが、どちらを推奨すべきか？ → A: **Option A (CLIコマンド)** - `speckit-docs install` を推奨する。理由：(1) 仕様（FR-021a, FR-022, FR-023）が前提としている標準的な方法、(2) ユーザーにとってシンプルで覚えやすい、(3) spec-kitの`specify init`パターンと一貫性がある、(4) Python API呼び出しはアドバンスドユーザー向けのフォールバックとして残す

### Session 2025-10-13 (Code Quality & Architecture Details)

- Q: ruffの設定：デフォルト設定のみ vs 一貫性のあるプリセット vs 厳格なルールセット？ → A: **Option B (一貫性のあるプリセット)** - `pyproject.toml`で`select = ["E", "F", "W", "I"]` + `line-length = 100` + `target-version = "py311"`を指定。理由：(1) エラー（E）、致命的エラー（F）、警告（W）、import順序（I）の基本ルールでツールプロジェクトには十分、(2) line-length=100はPython標準（PEP 8の88-100推奨）に準拠、(3) target-version指定により型ヒント構文の互換性を保証、(4) 過度に厳格なルール（docstring必須等）は開発速度を低下させる可能性を回避
- Q: CI/CD環境でのruffエラー処理：Fail-fast vs Warning-only vs ブランチ別動作？ → A: **CI/CDパイプラインは構築しない** - ローカル開発環境でのみruffを手動実行する。理由：MVP段階ではCI/CD構築はスコープ外、開発者がローカルで`uv run ruff check .`を実行して品質を維持
- Q: BaseGenerator抽象クラスのインターフェース：最小（1メソッド）vs 段階的（4メソッド）vs 詳細（7-8メソッド）？ → A: **Option B (段階的インターフェース)** - `initialize()`, `generate_feature_page(feature)`, `update_navigation()`, `validate()`の4メソッド。理由：(1) 単一責任原則に従い各メソッドが明確な役割を持つ、(2) initialize→個別ページ生成→ナビゲーション更新→検証と処理が分離されテスト容易、(3) 将来のDocusaurus等追加時も同じパターンを適用可能、(4) 最小インターフェースより構造化され、詳細インターフェースより保守しやすい
- Q: specify-cli（本家spec-kit）からの再利用範囲：MVP段階でStepTracker/consoleも再利用 vs typerパターンのみ？ → A: **Option A (MVP範囲は最小限)** - typerの基本パターン（`typer.confirm()`, `typer.Option()`等）のみ再利用、StepTracker/consoleは将来フェーズ。理由：(1) MVPの焦点は「ドキュメント生成」でありCLI体験の高度化は二次的、(2) specify-cliコード調査コストをMVPで回避し開発スピード優先、(3) Phase 2でStepTracker再利用を計画済み（research.md記載）なので段階的アプローチが適切、(4) typerパターン再利用だけでもDRY原則とC012（一貫性）を満たす
- Q: ログレベルとエラー出力の戦略：エラーのみ vs 構造化ログ（INFO/DEBUG/ERROR） vs 詳細ログ（常にDEBUG）？ → A: **Option B (構造化ログ)** - 標準出力にINFO以上、`--verbose`でDEBUG、`--quiet`でERRORのみ。理由：(1) ユーザーは通常実行で適切な進捗情報を得られる（「3機能を処理中...」等）、(2) `--verbose`フラグでトラブルシューティング時に詳細情報取得可能、(3) `--quiet`でCIやスクリプト組み込み時にエラーのみ出力、(4) Pythonの標準logging模块を使用し保守性が高い、(5) 本家spec-kitの他コマンドとの一貫性

### Session 2025-10-14 (Installation Method Standardization)

- Q: インストール方法の標準化：spec-kitと同様に`uv tool install`方式を推奨インストール方法とすべきか、それとも`uv pip install -e`(編集可能インストール)を維持すべきか？ → A: **Option A (uv tool install)** - `uv tool install speckit-docs --from git+https://github.com/drillan/spec-kit-docs.git`を標準インストール方法とする。理由：(1) **Core Principle I (spec-kit Integration First)への準拠** - spec-kitと同じインストールパターンでユーザー体験を統一、(2) **ツール分離** - `uv tool`は独立したCLIツールのインストール専用で、プロジェクト環境を汚染しない、(3) **シンプルな依存関係管理** - グローバルツールとして管理され、複数プロジェクトから利用可能、(4) **本家spec-kitとの対称性** - `uv tool install specify-cli`と`uv tool install speckit-docs`で対になる。開発者向けのコントリビューション時には`uv pip install -e .`も引き続きサポートするが、エンドユーザー向けドキュメント（README.md）では`uv tool install`を唯一の推奨方法として記載する

### Session 2025-10-15 (Dependency Auto-Installation)

- Q: 依存関係の自動インストールを実装すべきか？ → A: **条件付き自動インストール** - `pyproject.toml`が存在し`uv`コマンドが利用可能な場合、ユーザー承認後に`uv add`を実行する。条件が満たされない場合は、代替方法（手動インストールまたはspec-kitワークフロー）を明確に提示する。理由：(1) 95%以上のspec-kitユーザーがこの条件を満たし、ワンステップでセットアップ完了、(2) spec-kitの非侵襲的哲学を維持（ユーザー承認必須）、(3) SC-002「追加設定なしでビルド成功」を実現
- Q: CI/CD環境での非対話的実行をどのように制御すべきか？ → A: **`--auto-install`と`--no-install`の両フラグを提供** - `--auto-install`指定時は確認なしで自動インストール、`--no-install`指定時は依存関係チェック自体をスキップ、デフォルトは対話的確認。理由：(1) CI/CDで完全自動化が必要な場合に対応、(2) 依存関係を手動管理したい場合の選択肢を提供、(3) デフォルトは安全性優先（ユーザー承認必須）
- Q: `uv add`失敗時のフォールバック戦略は？ → A: **3段階の代替方法を明確に提示** - (1) 失敗理由の説明、(2) 方法1: 手動インストールコマンド（利用可能なパッケージマネージャーを自動検出：uv, pip, poetry等）、(3) 方法2: spec-kitワークフロー（`/speckit.specify` → `/speckit.plan` → `/speckit.tasks` → `/speckit.implement`）の手順とその利点（依存関係管理がplan.md/tasks.mdに記録される）を説明。理由：(1) spec-kitエコシステムを強化、(2) すべてのユーザーに対応可能な選択肢を提供、(3) 依存関係の履歴が残るという価値を提示
- Q: ユーザー承認プロンプトに含めるべき情報は？ → A: **包括的情報提示** - (1) インストール予定のパッケージリスト（バージョン制約含む）、(2) 実行されるコマンド（`uv add sphinx>=7.0 myst-parser>=2.0`）、(3) `pyproject.toml`が変更されることの警告、(4) 承認プロンプト。理由：(1) ユーザーが何が起こるかを完全に理解した上で承認できる、(2) インフォームドコンセントの原則に準拠、(3) 予期しない結果を防ぐ
- Q: 成功基準SC-002をどのように修正すべきか？ → A: **条件を明記し、新しい成功基準SC-002bを追加** - SC-002を「必要な依存関係がインストールされている環境、または自動インストールが成功した環境で、追加設定なしでビルドコマンドが成功する」に修正。SC-002b新設：「pyproject.tomlとuvが利用可能な環境で、ユーザーが依存関係インストールを承認した場合、90%以上のケースで`uv add`が成功し、その後のビルドコマンドが成功する（残り10%はネットワークエラー等の外部要因）」。理由：(1) SC-002の曖昧性を解消、(2) 自動インストール機能の成功率を明確に定義、(3) 現実的な基準（ネットワークエラー等の外部要因を許容）

### Session 2025-10-16 (Dependency Placement Strategy)

- Q: `uv add` で依存関係を追加する際、`[project.optional-dependencies.docs]`（pip/poetry/uv互換）と `[dependency-groups.docs]`（uvネイティブ）のどちらを使用すべきですか？ → A: **Option B - ユーザーに選択させる（デフォルト: `optional-dependencies`）** - `/doc-init` 実行時にユーザーに「optional-dependencies（推奨、広い互換性）」または「dependency-groups（uvネイティブ、モダン）」を選択可能にする。理由：(1) ユーザーの環境やワークフローに応じた柔軟性を提供、(2) pip/poetryユーザーには互換性のあるoptional-dependenciesを推奨、(3) uvネイティブユーザーにはより現代的なdependency-groupsを提供、(4) spec-kitの非侵襲的哲学（ユーザーに選択権を与える）に準拠、(5) アーキテクチャ的に正しい（ドキュメント生成ツールはメインアプリケーションの実行に不要であり、開発・ドキュメント専用の依存関係として分離すべき）

### Session 2025-10-16 (LLM-Driven Document Generation)

- **現状の課題認識**: `/speckit.doc-update` コマンドは、specsフォルダのファイル（spec.md、plan.md、tasks.md）を単純にJinja2テンプレートに挿入してコピーしているだけであり、エンドユーザー向けの読みやすさや理解しやすさを考慮していない。生成されるドキュメントは、開発者向けの技術的な仕様書をそのまま表示しているため、プロジェクトのエンドユーザー（顧客、ステークホルダー、非技術者）にとって難解で親しみにくい
- Q: LLMを統合してユーザーフレンドリーなドキュメントを生成すべきか？ → A: **Yes - LLMによるドキュメント変換を実装する** - `/speckit.doc-update`実行時に、spec.md等のコンテンツをそのままコピーするのではなく、LLMを使用してユーザーフレンドリーな形式に変換する。理由：(1) **エンドユーザー価値の最大化** - ドキュメントは開発者だけでなく、顧客、プロダクトマネージャー、営業チーム、サポートチームなど多様な読者を対象とするため、技術的詳細を適切に要約・翻訳することで価値が向上、(2) **spec-kitの哲学との整合** - spec-kitは「AI駆動型ワークフロー」を前提としており、ドキュメント生成にもAIを活用することは自然な拡張、(3) **差別化要因** - 単なるファイルコピーツールではなく、「インテリジェントなドキュメント生成ツール」として位置づけることで、本ツールの独自価値を明確化
- Q: LLM変換の具体的な処理内容は？ → A: **段階的な変換戦略** - (1) **Phase 1 (MVP)**: spec.mdのFunctional Requirementsセクションを「機能概要」として要約（技術的な"MUST"表現を自然な文章に変換、例：「FR-001: System MUST allow users to...」→「ユーザーは...できます」）、(2) **Phase 2**: plan.mdのアーキテクチャセクションから「技術的な意思決定の背景」を抽出して分かりやすく説明、(3) **Phase 3**: tasks.mdから「実装状況の概要」を生成（タスクの詳細ではなく、「この機能は80%完了しています」といった進捗サマリー）。各フェーズで、元のコンテンツへのリンクを提供し、技術者が詳細にアクセスできるようにする
- Q: LLM変換の責務分担は？（ANTHROPIC_API_KEYの扱い） → A: **Option B - AIエージェント（Claude Code）がLLM変換を実行し、変換済みコンテンツをスクリプトに渡す** - Claude Code環境では、ユーザーはAPIキーを意識する必要がない。理由：(1) **既存アーキテクチャパターンとの一貫性** - 「AIエージェント（Claude Code）が対話・検証・LLM処理を担当し、スクリプト（doc_update.py）は非対話的に実行」という責務分担に従う、(2) **ユーザー体験の簡素化** - Claude Code上でスラッシュコマンドを実行する場合、バックグラウンドでClaude APIと通信するため、エンドユーザーがANTHROPIC_API_KEYを設定・管理する必要がない、(3) **テスト容易性** - AIエージェントとスクリプトの境界が明確になり、スクリプトは変換済みコンテンツを受け取るだけなので単体テストが容易、(4) **将来の拡張性** - CLI直接実行時（Claude Code外）の動作は、コマンド定義（.claude/commands/speckit.doc-update.md）で制御可能
- Q: キャッシュの永続化形式は？ → A: **この質問は後に削除決定されました** - Session 2025-10-17 Q3の決定により、永続的キャッシング機能は削除されました。代わりに`--quick`フラグによるGit diffベースの変更検出を使用します（Session 2025-10-17 Q4参照）。

**注意**: 以前の回答では`.claude/.cache/llm-transforms.json`形式のキャッシングを提案していましたが、実装の簡素化とメンテナンスコスト削減のため、この機能は削除されました。
- Q: キャッシュ無効化判定のハッシュアルゴリズムは？ → A: **この質問は後に削除決定されました** - Session 2025-10-17 Q3の決定により、MD5ハッシュベースのキャッシュ機能は削除されました。
- Q: コスト・パフォーマンス懸念への対応は？ → A: **実用的な制約を設ける** - (1) **コンテンツサイズ制限**: プロンプトサイズの上限を設定（例：1機能あたり最大10,000トークン）し、超過した場合は明確なエラーを返してプロセスを中断、(2) **変更検出による処理削減**: `--quick`フラグで変更された機能のみを処理（詳細はSession 2025-10-17 Q4参照）

**注意**: 以前の設計では`--no-llm-transform`フラグと永続的キャッシング機能が含まれていましたが、Session 2025-10-17の決定により両方とも削除されました（Q1、Q3参照）。
- Q: エラーハンドリング戦略は？ → A: **明示的なエラー返却（憲章準拠）** - (1) LLM変換失敗時（AIエージェント側のエラー、コンテンツサイズ超過等）は、明確なエラーメッセージを返してプロセスを中断する、(2) LLM生成コンテンツが不適切（空、エラーメッセージ、フォーマット違反）な場合も同様にエラーを返す、(3) **フォールバック動作は行わない** - 憲章違反となるため、失敗時は自動的に単純コピー方式に切り替えず、ユーザーに問題を通知して対処を求める、(4) エラーメッセージには「ファイルパス」「エラー種類」「推奨アクション」を含める（例：「README.md が10,000トークンを超過しています（現在: X トークン）。コンテンツを分割してください」）

### Session 2025-10-16 (Default Behavior Change)

- Q: LLM変換をデフォルトの挙動にすべきか？ → A: **Yes - LLM変換を常に有効化する** - `/speckit.doc-update`実行時、常にLLM変換が実行される。理由：(1) **ユーザー価値の最大化** - spec-kit-docsの主要価値提案は「ユーザーフレンドリーなドキュメント生成」であり、LLM変換を全ユーザーに提供、(2) **AI駆動ツールとしての位置づけ** - spec-kitエコシステムの一部として、AI活用が前提、(3) **機能の明確化** - ツールの目的を「LLM変換によるユーザーフレンドリーなドキュメント生成」に特化

**注意**: 以前の設計ではオプトアウト用の`--no-llm-transform`フラグが含まれていましたが、Session 2025-10-17 Q1の決定により削除されました。

### Session 2025-10-17 (User Documentation Focus)

- Q1: ドキュメントの対象読者とコンテンツソースは？現在の設計では開発者向けの技術仕様書（spec.md全体: 35,146トークン）をそのままドキュメント化するが、ユーザードキュメントの本来の目的は**エンドユーザー（非技術者を含む）が理解できるドキュメント**を提供することである。どのアプローチを採用すべきか？ → A: **Option C - 最小限の技術情報のみ抽出し、ユーザー向けファイルを優先** - spec.mdから最小限の情報のみ抽出（ユーザーストーリーの「目的」セクション、前提条件、スコープ境界の「できないこと」）し、README.md/QUICKSTART.mdが存在すればそちらを優先使用する。理由：(1) **トークン数削減** - spec.md全体（35,146トークン）ではなく約4,500トークンのみ処理し、Read制限（25,000トークン）とLLM変換制限（10,000トークン）の両方を回避、(2) **ユーザー価値に特化** - spec.mdの約80%は開発者向けの技術詳細（要件ID、アーキテクチャ、詳細なタスク）であり、エンドユーザーには不要。ユーザーが必要とするのは「何ができるか」「どう使うか」「使用例」、(3) **コスト削減** - LLM変換処理を約90%削減し、応答時間とAPIコストを大幅に改善、(4) **ユーザー向けファイルの優先** - README.md/QUICKSTART.mdが存在する場合はそちらを優先使用することで、最もユーザーフレンドリーな情報源を活用、(5) **フォールバック戦略** - ユーザー向けファイルが存在しない場合でも、spec.mdから最小限の情報を抽出してドキュメント生成が可能
- Q2: README.md/QUICKSTART.mdが両方存在する場合の優先順位とサイズ制限は？現在のFR-038では優先順位が「(1) README.md → (2) QUICKSTART.md → (3) spec.md最小限抽出」と定義されているが、**両方存在する場合の処理**と**10,000トークンを超える場合の処理**が不明確である。どのアプローチを採用すべきか？ → A: **Option A - README.md完全優先 + サイズ制限エラー** - README.mdが存在する場合はREADME.mdのみ使用（QUICKSTART.mdは無視）、README.mdがなくQUICKSTART.mdが存在する場合はQUICKSTART.mdのみ使用、両方ない場合はspec.mdから最小限抽出（約4,500トークン保証）。**サイズチェック**: README.md/QUICKSTART.mdが10,000トークンを超える場合はエラーで中断し、明確なエラーメッセージ（「ファイルパス」「現在のトークン数」「上限」「推奨アクション」）を表示する。理由：(1) **憲章準拠** - 「フォールバック動作を避ける」原則に完全準拠（フォールバック方式は憲章違反）、(2) **実装シンプル** - 明確なif-elif-elseロジック、テスト容易性が高い、(3) **ユーザーに明確なガイド** - 「README.mdは10,000トークン以内に保つ」という明確な推奨事項を提供、(4) **予測可能** - ファイル存在と優先順位が1:1で対応、(5) **明確なエラーメッセージ** - サイズ超過時に「README.mdを分割してください（現在: X トークン、上限: 10,000トークン）」と具体的な対処方法を提示
- Q3: spec.mdからの最小限抽出の具体的な実装方法は？現在のFR-038では「spec.mdから最小限の情報のみ抽出（ユーザーストーリーの『目的』セクション、前提条件セクション、スコープ境界の『できないこと』）」と定義されているが、**具体的な抽出方法**（マークダウンパーサー使用？正規表現？）、**複数ユーザーストーリーの処理方法**、**セクション区切りの判定方法**が不明確である。どのアプローチを採用すべきか？ → A: **Option B - 構造化マークダウン解析（厳格・パーサーベース）** - markdown-it-py（既存依存関係）を使用してspec.mdをパースし、明確なルールでセクション抽出を行う。**抽出ルール**: (1) **ユーザーストーリーの目的** - すべての`### ユーザーストーリーN:`セクションを検出し、その下の`**目的**:`から次の`**`までのテキストを抽出、(2) **前提条件** - `## 前提条件`（または`## Prerequisites`）セクション全体を抽出（サブセクションを含む）、(3) **スコープ境界** - `## スコープ境界`セクション内の`**スコープ外（フェーズ1 - MVP）**:`から次のセクション（`##`）までのリストを抽出。抽出されたテキストを結合し、トークン数チェック（最大10,000トークン）を実行。理由：(1) **予測可能性** - 明確なルールにより抽出結果が100%予測可能、実装とテストが明確、(2) **スタンドアロン動作** - バックエンドスクリプト単独で動作可能（AIエージェント環境以外でも動作）、(3) **トークン数保証** - 抽出後に正確にトークン数を測定し、4,500トークン以内を確実に保証、(4) **テスト容易性** - 単体テストで各抽出ロジックを検証し、契約テストでspec.md構造を保証、(5) **憲章準拠** - フォールバック動作なし、失敗時は明確なエラーメッセージを表示、(6) **既存ツールとの整合性** - spec-kitはすでに構造化されたspec.mdフォーマットを推奨しており、このアプローチはその延長線上
- Q4: LLM変換キャッシュのキー設計とライフサイクル管理は？ → A: **この質問は後に削除決定されました** - Session 2025-10-17 (No-Transform Flag Removal & Quick Mode) Q3の決定により、永続的キャッシング機能全体が削除されました。代わりに`--quick`フラグによるGit diffベースの変更検出を使用します（同セッションQ4参照）。

**注意**: 以前の回答では`--clear-cache`フラグとMD5ハッシュベースのキャッシングを提案していましたが、実装の簡素化のため削除されました。
- Q5: LLM生成コンテンツの品質チェック基準は？現在のFR-038cでは「空文字列、明らかなエラーメッセージ、Markdown形式違反」を検出すると定義されているが、**「明らかなエラーメッセージ」の判定基準**、**「Markdown形式違反」の検証範囲**、**品質チェックの実装方法**が不明確である。どのアプローチを採用すべきか？ → A: **Option D - 基本的な妥当性チェック + Markdownリンター（実用的・高品質）** - 以下の4つの検証を実行：(1) **空文字列チェック** - 変換結果が空文字列または空白のみの場合エラー、(2) **最小文字数チェック** - 変換結果が50文字未満の場合エラー（LLMが正常に動作していない可能性）、(3) **エラーパターンマッチング** - 以下のパターンを含む場合エラー：英語（`error`, `failed`, `invalid`, `cannot`, `unable`）、日本語（`申し訳`, `すみません`）、大文字小文字を区別しない正規表現で検出、(4) **Markdownリンター** - markdown-it-py（既存依存関係）を使用してMarkdown構文をパース、構文エラーがあれば例外をキャッチしてエラー。理由：(1) **実用的な品質保証** - 基本的なエラーとMarkdown構文の両方を検証、95%以上のエラーケースをカバー、(2) **既存ツール活用** - markdown-it-pyは既に依存関係にあるため追加依存なし、(3) **高速** - パース処理は高速で処理時間への影響は最小、(4) **テスト容易** - 明確なルールで単体テストが書きやすい、(5) **拡張性** - 将来pymarkdownlnt等のより厳密なリンターに切り替え可能、(6) **明確なエラーメッセージ** - 各検証項目で具体的なエラー理由を提供（「空文字列」「短すぎる（X文字）」「エラーパターン: error」「Markdown構文エラー: [詳細]」）

### Session 2025-10-17 (No-Transform Flag Removal & Quick Mode)

- Q1: `--no-llm-transform`フラグの扱いは？現在の仕様では`--no-llm-transform`フラグでspec.md単純コピーが可能だが、これはユーザーストーリーの目的（「エンドユーザー（非技術者を含む）が理解できるドキュメント」を提供する）と矛盾している。どのアプローチを採用すべきか？ → A: **Option A - `--no-llm-transform`フラグを完全に削除し、LLM変換のみをサポート** - 理由：(1) ツールの目的（「ユーザーフレンドリーなドキュメント生成」）に完全に集中し、機能範囲を明確化、(2) 単純コピーは既存ツール（Sphinx/MkDocsのマニュアル構築）で十分対応可能であり、重複機能を避ける、(3) 実装・テスト・保守コストを削減、(4) ユーザーに混乱を与えない（「どちらを選ぶべきか」という判断不要）
- Q2: LLM変換失敗時のエラーハンドリング戦略は？失敗した機能のみスキップして他を処理続行すべきか、それともプロセス全体を中断すべきか？ → A: **Option A - プロセスを完全に中断（厳格なエラーハンドリング）** - 理由：(1) 憲章の「Primary Data Non-Assumption Principle」に完全準拠、(2) 問題を明確に通知し、ユーザーが根本原因を解決できる、(3) 部分的な成功による混乱を避ける（どの機能が成功/失敗したかを追跡する複雑さを回避）
- Q3: キャッシュ機能の扱いは？`--no-llm-transform`フラグを削除する場合、LLM変換キャッシュ機能（`.claude/.cache/llm-transforms.json`）と`--clear-cache`フラグも削除すべきか？ → A: **Option B - キャッシュ機能も削除し、完全にLLM変換機能のみを提供** - 理由：(1) `--no-llm-transform`フラグ自体を削除するため、関連する全ての機能（キャッシュ、統計情報）も削除すべき、(2) 実装のシンプル化 - キャッシュ機能はLLM変換専用であり、フラグがなければキャッシュも不要、(3) コードベースの簡潔化 - 使用されない機能のコード・テストを削除し、保守コストを削減、(4) 明確な機能境界 - ツールは「LLM変換によるユーザーフレンドリーなドキュメント生成」のみを提供
- Q4: 変更検出の扱いは？キャッシュを削除する場合、Git diffベースの変更検出機能をどうすべきか？ → A: **Option C - 全機能変換をデフォルト、`--quick`フラグで変更検出をオプション提供** - 理由：(1) 確実性優先 - デフォルトは常に全機能を変換し、変更検出の誤判定やGit管理外の変更を確実にキャッチ、(2) 開発中の高速化 - 頻繁な更新時は`--quick`フラグで変更された機能のみ処理（開発フィードバックサイクルを短縮）、(3) ユースケースの分離 - 本番デプロイ時は確実性を重視、開発中は速度を重視、(4) Git diff機能の活用 - FR-019の既存ロジックを`--quick`モードで再利用
- Q5: 更新サマリーの統計情報表示は？`--quick`モードの導入により、統計情報の表示内容をどうすべきか？ → A: **Option A - モード別の統計情報表示** - デフォルトモードでは「LLM変換: 成功X件、失敗Y件」、`--quick`モードでは「LLM変換: 成功X件、スキップ（変更なし）Y件、失敗Z件」と表示。理由：(1) 明確な情報提供 - 実行内容に応じた統計を表示、(2) ユーザーの理解を促進 - どの機能が処理されたか、スキップされたかを明確に把握できる、(3) デバッグ支援 - `--quick`モードで期待した機能がスキップされた場合、Git diff検出の問題を特定しやすい

### Session 2025-10-17 (README/QUICKSTART Integration Strategy)

- Q1: README.md/QUICKSTART.mdの統合戦略は？現在の仕様（Session 2025-10-17 Q2）では「README.md完全優先（QUICKSTART.mdは無視）」となっているが、両方に重要な情報が入っている場合の統合と、不整合がある場合の警告が必要である。どのアプローチを採用すべきか？ → A: **Option C - README.md/QUICKSTART.md統合 + 不整合警告** - 両方が存在する場合、内容を統合してLLM変換する。不整合検出時は警告して中止する。理由：(1) **ユーザー要求に完全対応** - 両方に重要な情報がある場合に統合し、不整合時は警告して中止、(2) **情報の網羅性** - README.mdは「何ができるか」、QUICKSTART.mdは「どう使うか」と異なる側面をカバーする可能性があり、両方を活用することでユーザー価値を最大化、(3) **安全性** - 不整合検出により、矛盾した情報がドキュメントに含まれるリスクを回避
- Q2: README.md/QUICKSTART.mdの統合時、合計サイズが10,000トークンを超える場合の処理は？ → A: **Option D - セクション単位の統合（スマート）** - README.md/QUICKSTART.mdをそれぞれセクション（見出し）単位でmarkdown-it-pyを使ってパースし、セクションの優先順位に従って統合する。優先順位順にセクションを追加し、合計トークン数が10,000以内に収まるまで追加する。10,000トークン超過する場合、優先度の低いセクションは除外し、警告メッセージで「除外されたセクション」を表示する。理由：(1) 両方のファイルから最重要情報を抽出できる、(2) 10,000トークン制限内で自動的に調整、(3) ユーザーに手動でファイルを編集させる必要がない
- Q3: セクションの優先順位をどのように決定すべきか？日本語で記述されている場合もあり、固定のキーワードリストでは対応できない。 → A: **Option E - LLMによるセクション優先順位判定（インテリジェント）** - README.md/QUICKSTART.mdから全ての見出し（`##`, `###`）を抽出し、抽出した見出しリストをLLMに渡し、「これらはドキュメント生成用のセクション見出しです。エンドユーザー（非技術者を含む）にとって重要度が高い順に並び替えてください」と依頼する。LLMが返した優先順位に従ってセクションを統合する。理由：(1) 多言語完全対応（日本語・英語・その他の言語を自動判定）、(2) プロジェクトごとの文脈に応じた優先順位判定、(3) 「概要」「機能」「使い方」「クイックスタート」「インストール」など、様々な表現を理解
- Q4: README.md/QUICKSTART.md間の不整合をどのように検出すべきか？ → A: **Option B - LLMによる不整合検出（実用的）** - README.md/QUICKSTART.mdの内容をLLMに渡し、「これら2つのファイルは同じプロジェクトを説明していますか？重大な矛盾（技術スタック、主要機能、目的の食い違い）がありますか？」と判定を依頼する。許容: 表記揺れ、詳細度の違い、補完的な情報。不整合: 異なる技術スタック、矛盾する機能説明、異なるプロジェクト目的。理由：(1) 柔軟性 - プロジェクト名の表記揺れや詳細度の違いを許容、(2) 実用性 - 重大な矛盾のみを検出し、些細な違いは許容、(3) 多言語対応 - 日本語・英語混在でも適切に判定
- Q5: LLM処理（不整合検出・優先順位判定）が失敗した場合の挙動は？ → A: **Option A - エラーで中断（厳格、憲章準拠）** - LLM呼び出しが失敗した場合、明確なエラーメッセージを表示してプロセス全体を中断する。理由：(1) 憲章準拠 - 「Primary Data Non-Assumption Principle」に従い、LLM処理が失敗した場合はフォールバックせず明確にエラーを返す、(2) 予測可能性 - ユーザーは問題を認識し、再実行または代替手段を選択できる、(3) 一貫性 - 他のエラーハンドリング（FR-038b: LLM変換エラー時は中断）と同じ戦略

### Session 2025-10-17 (Command Template Clarification)

- Q1: LLM変換の実行責任と必須性を明確化すべきか？Session 2025-10-16では「AIエージェント（Claude Code）がLLM変換を実行する」と明記されているが、FR-022b（コマンド定義の要件）にはLLM変換を実行するワークフローが定義されていない。このギャップを解消すべきか？ → A: **Option A - コマンド定義にLLM変換実行ワークフローを明示的に追加** - FR-022bを以下のように変更：(1) docs/ディレクトリの存在確認、(2) 各機能に対してLLM変換を実行（FR-038のロジックに従い、README.md/QUICKSTART.md/spec.mdからコンテンツを選択・抽出し、Claude APIで変換）、(3) 変換済みコンテンツを一時ファイルまたはコマンドライン引数として準備、(4) `uv run python .specify/scripts/docs/doc_update.py --transformed-content <path>` の呼び出し、(5) 更新されたファイルのサマリー表示、(6) エラーハンドリングとユーザーフィードバック。理由：(1) **完全性** - LLM変換が「常に実行される」ことを保証、(2) **トレーサビリティ** - 変換実行の責任がコマンド定義に明確化、(3) **テスト可能性** - 変換実行の要件が明示的になり、検証可能
- Q2: `transformed_content`パラメータの必須性は？Session 2025-10-17で「LLM変換は常に実行される」と決定されたが、バックエンドスクリプトの`doc_update.py`の`transformed_content`パラメータが`Optional`として定義されている。これは矛盾しており、変換が実行されなくてもスクリプトがエラーを返さない問題がある。このパラメータを必須にすべきか？ → A: **Option A - パラメータを必須にする** - `doc_update.py`の`transformed_content`パラメータを`typer.Option(...)`として必須定義に変更する。理由：(1) **整合性** - 「LLM変換は常に実行される」要件と実装が一致、(2) **早期失敗** - コマンド定義が変換を実行し忘れた場合、即座にエラーで検知、(3) **明確性** - パラメータが必須であることで、LLM変換の必須性が実装レベルで保証される

### Session 2025-10-17 (Content Filtering Strategy)

- Q1: ドキュメント生成対象の範囲は？現在の実装では、`feature-page.md.jinja2`テンプレートが**plan.mdとtasks.mdの内容を全て含めています**。しかし、これらは開発者向けの技術的詳細（実装計画、タスク一覧、依存関係グラフ、Phase定義等）であり、**エンドユーザー（顧客、プロダクトマネージャー、営業チーム）には不要**です。spec-kit-docsの本来の目的は「エンドユーザーが理解できるドキュメント」を提供することであり、現状はこの目的と矛盾しています。どのアプローチを採用すべきか？ → A: **Option A - plan.md と tasks.md を生成対象から完全に除外** - `feature-page.md.jinja2`テンプレートからplan_contentとtasks_contentセクションを削除し、`FeaturePageGenerator`でplan.mdとtasks.mdの読み込みをスキップする。開発者向け情報は元の仕様書へのリンク経由でアクセス可能（Feature Filesセクション）。理由：(1) **目的との整合** - spec-kit-docsの目的（「エンドユーザーが理解できるドキュメント」）に完全に合致、(2) **最もシンプルな実装** - テンプレートから該当セクションを削除し、パーサーの読み込みをスキップするだけで問題を解決（2ファイルの修正のみ）、(3) **明確な情報アーキテクチャ** - エンドユーザー向けドキュメントと開発者向け仕様書を明確に分離、(4) **パフォーマンス向上** - 不要なファイル読み込みとLLM変換処理を削減、(5) **バグリスク最小** - 最小限の変更で問題を解決
- Q2: テンプレート実装の具体的なアプローチは？`feature-page.md.jinja2`から"Implementation Plan"と"Implementation Tasks"セクションを除外する具体的な実装方法として、どのアプローチを採用すべきか？ → A: **Option A - テンプレートから該当セクションを完全に削除** - `feature-page.md.jinja2`から`{% if plan_content %}`ブロックと`{% if tasks_content %}`ブロックを完全に削除し、`FeaturePageGenerator.generate_pages()`メソッド内で`plan_doc = None`、`tasks_doc = None`を設定してplan.md/tasks.mdの読み込みを完全にスキップする。Feature Filesセクションは保持し、元の仕様書へのリンクを提供する。理由：(1) **最もシンプル** - テンプレートから2つのセクションを削除するのみ、実装が明確、(2) **パフォーマンス向上** - 不要なファイル読み込みを削減（FeaturePageGenerator内で`_parse_document()`を呼ばない）、(3) **バグリスク最小** - 最小限の変更で問題を解決、(4) **将来の拡張性** - 将来的に開発者向けドキュメントが必要になった場合、別のテンプレート（`feature-page-developer.md.jinja2`）を作成可能
- Q3: 既存の受け入れシナリオとテストの更新は？plan.md と tasks.md を除外する決定により、既存の受け入れシナリオ（特にUser Story 2）とテストケースを更新する必要がある。どのアプローチを採用すべきか？ → A: **Option A - 受け入れシナリオを全面的に書き換え** - User Story 2の目的、独立テスト、受け入れシナリオからplan.md/tasks.mdへの参照を完全に削除し、LLM変換済みのユーザーフレンドリーなコンテンツ（機能の目的、使い方、価値）の検証に置き換える。新しい受け入れシナリオでは、(1) LLM変換済みコンテンツが含まれていることを検証、(2) plan.md/tasks.mdの技術的詳細が**含まれていない**ことを検証、(3) Feature Filesセクション経由で元の仕様書へのリンクが含まれていることを検証する。理由：(1) **新しい要件との整合** - 更新されたFR-012、FR-015、FR-018と完全に整合、(2) **テストの本質を反映** - テストは「エンドユーザーに必要な情報が含まれているか」を検証すべきであり、開発者向け技術的詳細の検証ではない、(3) **明確な期待値** - 「何が含まれるべきか」と「何が含まれるべきでないか」の両方を明確に定義

## アーキテクチャと責務分担

spec-kit-docs は、AI エージェント（Claude Code）とバックエンドスクリプトの協調によって動作します。このアーキテクチャは spec-kit の標準パターンに従います。

### AI エージェント（Claude Code）の責務

- ユーザーとの対話的な情報収集（プロジェクト名、著者名、バージョン、言語、ドキュメントツール選択など）
- 入力値の検証とユーザーへのフィードバック
- 既存ファイル（docs/ ディレクトリ）の上書き確認
- **LLM変換処理**: spec.md等のコンテンツをユーザーフレンドリーな形式に変換し、変換済みコンテンツを一時ファイルまたはコマンドライン引数としてスクリプトに渡す（Session 2025-10-17決定: LLM変換は常に実行される）
- 収集した情報をコマンドライン引数としてスクリプトに渡す
- エラーメッセージの解釈とユーザーへの提示

### バックエンドスクリプトの責務

- コマンドライン引数から設定を受け取る
- 非対話的にドキュメントプロジェクトを生成
- エラーを構造化された形式で返す（終了コードとメッセージ）
- **標準入力（stdin）を使用しない** - すべての設定はコマンドライン引数またはデフォルト値から取得
- ファイルシステム操作（ディレクトリ作成、ファイル生成）
- テンプレートの展開と設定ファイルの生成

### 設計根拠

この責務分担により以下が実現されます：

1. **非対話的環境での実行可能性**: Python スクリプトは CI/CD、バックグラウンドジョブ、自動化ワークフローで EOFError を起こさずに実行可能
2. **テスト容易性**: スクリプトは決定的な入力（コマンドライン引数）を受け取り、単体テストが容易
3. **spec-kit との一貫性**: `/speckit.specify`、`/speckit.plan` などの他のコマンドと同じパターンに従う
4. **拡張性**: 将来的に他の AI エージェント（GitHub Copilot、Gemini など）をサポートする際も、スクリプト側の変更は不要

## ユーザーシナリオとテスト *(必須)*

### ユーザーストーリー1: ドキュメントプロジェクトの初期化 (優先度: P1) 🎯 MVP

**目的**: spec-kitユーザーが、単一コマンドでドキュメントプロジェクトを初期化し、Sphinx または MkDocs のいずれかを選択し、インタラクティブに設定を構成できるようにすることで、手動でディレクトリを作成したり設定ファイルを編集したりすることなく、プロジェクトに適したドキュメント基盤を確立できるようにします。

**この優先度の理由**: ドキュメント生成の前提条件です。初期化がなければ、更新するドキュメント構造が存在しません。これはワークフローの最初のステップです。

**独立テスト**: ユーザーが spec-kit プロジェクトで `/speckit.doc-init --type sphinx` を実行します。システムはプロジェクト名、著者名、バージョンを対話的に尋ねます。完了後、`docs/` ディレクトリが作成され、Sphinx の設定ファイル（`conf.py`、`index.md`）と基本構造が含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: 有効な spec-kit プロジェクト（`.specify/` ディレクトリを持つ）、**実行**: ユーザーが `/speckit.doc-init --type sphinx` を実行、**期待結果**: システムが対話的にプロジェクト名、著者名、バージョン、言語を尋ね、回答に基づいて `docs/` に Sphinx プロジェクトを作成し、`conf.py`、`index.md`、`Makefile`、必要なディレクトリ構造を含む

2. **前提条件**: 有効な spec-kit プロジェクト、**実行**: ユーザーが `/speckit.doc-init --type mkdocs` を実行、**期待結果**: システムが対話的に設定を尋ね、`docs/` に MkDocs プロジェクトを作成し、`mkdocs.yml`、`docs/index.md`、必要なディレクトリ構造を含む

3. **前提条件**: spec-kit プロジェクト、**実行**: ユーザーが type 引数なしで `/speckit.doc-init` を実行、**期待結果**: システムが「どのドキュメントツールを使用しますか？ (sphinx/mkdocs)」と尋ね、ユーザーの選択に基づいて初期化を続行

4. **前提条件**: 既に `docs/` ディレクトリが存在するプロジェクト、**実行**: ユーザーが初期化を試みる、**期待結果**: システムが警告を表示:「docs/ ディレクトリは既に存在します。上書きしますか？ (yes/no)」、拒否された場合は既存の構造を保持

5. **前提条件**: spec-kit プロジェクトではないディレクトリ（`.specify/` なし）、**実行**: ユーザーが初期化を試みる、**期待結果**: システムがエラーを表示:「spec-kit プロジェクトではありません。最初に 'specify init' を実行してください。」

6. **前提条件**: 初期化が完了したプロジェクト、**実行**: ユーザーが `docs/` ディレクトリを確認、**期待結果**: 選択したドキュメントツールに応じた標準的なディレクトリ構造、設定ファイル、プレースホルダーコンテンツが含まれ、すぐにビルド可能な状態

---

### ユーザーストーリー2: spec-kit 仕様からのドキュメント更新 (優先度: P1) 🎯 MVP

**目的**: ドキュメントプロジェクトを初期化した spec-kit ユーザーが、`specs/` ディレクトリから最新のユーザー向け情報を明示的にドキュメントに統合できるようにすることで、README.md、QUICKSTART.md、またはspec.mdの変更を手動でコピー＆ペーストすることなく、エンドユーザーにとって理解しやすいドキュメントを最新の状態に保つことができるようにします。**Session 2025-10-17決定: plan.mdとtasks.mdは開発者向け情報のため除外され、元の仕様書へのリンク（Feature Filesセクション）経由でアクセス可能にします。**

**この優先度の理由**: これは初期化の直接的な続きです。初期化後、ユーザーは実際のエンドユーザー向けコンテンツでドキュメントを埋める必要があります。自動化はせず、ユーザーが制御できるようにします。

**独立テスト**: 3つの機能（001-user-auth、002-api-integration、003-notifications）を持つ spec-kit プロジェクトで `/speckit.doc-init` を実行後、`/speckit.doc-update` を実行します。システムは各機能のREADME.md/QUICKSTART.md/spec.mdからユーザー向け情報を抽出し、LLM変換を使用してユーザーフレンドリーな形式に変換し、ドキュメント構造に統合します。生成されたドキュメントをビルドして、3つの機能すべてのユーザー向け情報（機能の目的、使い方、価値）が含まれ、plan.md/tasks.mdの技術的詳細が**含まれていない**ことを確認します。

**受け入れシナリオ**:

1. **前提条件**: `/speckit.doc-init` で初期化された Sphinx プロジェクト、3つの機能（各ディレクトリに spec.md、またはREADME.md/QUICKSTART.mdを含む）、**実行**: ユーザーが `/speckit.doc-update` を実行、**期待結果**: システムが `docs/features/` に各機能のページを作成し、LLM変換済みのユーザーフレンドリーなコンテンツ（機能の目的、使い方、価値）を含み、**plan.mdやtasks.mdの技術的詳細（実装計画、タスク一覧、Phase定義）は含まれず**、`index.md` の toctree に機能リストを追加。各ページにはFeature Filesセクション経由で元のspec.md/plan.md/tasks.mdへのリンクが含まれる

2. **前提条件**: 初期化された MkDocs プロジェクト、機能仕様、**実行**: `/speckit.doc-update` を実行、**期待結果**: システムが `docs/features/*.md` ファイルを作成し、LLM変換済みのエンドユーザー向けコンテンツのみを含み、**開発者向け情報（plan.md、tasks.md）を含まず**、`mkdocs.yml` の nav セクションを更新して新しいページを含める

3. **前提条件**: README.md/QUICKSTART.md/spec.mdのいずれかを持つ機能、**実行**: 更新を実行、**期待結果**: システムがFR-038のロジックに従ってコンテンツソースを選択し（README.md → QUICKSTART.md → spec.md最小限抽出の優先順位）、LLM変換を使用してユーザーフレンドリーな機能ページを生成。Feature Filesセクションに元の仕様書へのリンクを含める

4. **前提条件**: `specs/` ディレクトリが空または存在しない、**実行**: ユーザーが更新を試みる、**期待結果**: システムがエラーを表示:「仕様が見つかりません。最初に /speckit.specify を実行して機能仕様を作成してください。」

5. **前提条件**: `docs/` ディレクトリが初期化されていない、**実行**: ユーザーが `/speckit.doc-update` を実行、**期待結果**: システムがエラーを表示:「ドキュメントプロジェクトが見つかりません。最初に /speckit.doc-init を実行してください。」

6. **前提条件**: 前回の更新以降に変更された機能のREADME.md/spec.md、**実行**: `/speckit.doc-update --quick` を再実行、**期待結果**: システムがGit diffを使用して変更された機能のページのみを更新し、変更されていないページは保持し、「LLM変換: 成功3件、スキップ（変更なし）2件、失敗0件」などの更新サマリーを表示

---

### ユーザーストーリー3: spec-kit 拡張機能としてのインストール (優先度: P1) 🎯 MVP

**目的**: spec-kit ユーザーが、既存の spec-kit プロジェクトに spec-kit-docs を拡張機能として簡単なコマンドでインストールできるようにすることで、複雑な設定なしに AI エージェント（Claude Code）で `/speckit.doc-init` と `/speckit.doc-update` コマンドにアクセスできるようにします。

**この優先度の理由**: ユーザーはツールを使用する前にインストールできる必要があります。これは他のすべての機能の前提条件です。

**独立テスト**: 既存の spec-kit プロジェクトを持つユーザーが、まず`uv tool install speckit-docs --from git+https://github.com/drillan/spec-kit-docs.git`でCLIツールをインストールし、次にプロジェクトルートで`speckit-docs install`を実行します。インストール後、Claude Code で `/speckit.doc-init` と `/speckit.doc-update` を実行でき、エラーなくコマンドが実行されることを確認します。

**受け入れシナリオ**:

1. **前提条件**: spec-kit プロジェクトとして初期化されたディレクトリ（`.specify/` と `.claude/` ディレクトリを持つ）、**実行**: ユーザーがプロジェクトルートで`speckit-docs install`を実行、**期待結果**: システムが`.claude/commands/`にドキュメントコマンド定義（`doc-init.md`と`doc-update.md`、Pythonパッケージ内の`src/speckit_docs/commands/`からコピー）を追加し、必要なスクリプトを`.specify/scripts/docs/`にコピーし、インストール成功を確認

2. **前提条件**: spec-kit-docs をインストールしたユーザー、**実行**: プロジェクトディレクトリで Claude Code を開き、`/speckit` と入力、**期待結果**: `/speckit.specify`、`/speckit.plan` などと並んで、利用可能なコマンドリストに `/speckit.doc-init` と `/speckit.doc-update` が表示される

3. **前提条件**: spec-kit プロジェクトではないディレクトリ（`.specify/` ディレクトリなし）、**実行**: ユーザーがインストールを試みる、**期待結果**: システムがエラーを表示:「spec-kit プロジェクトではありません。最初に 'specify init' を実行してください。」

4. **前提条件**: 既にインストールされている spec-kit-docs 拡張機能、**実行**: ユーザーが再度インストールを実行、**期待結果**: システムが既存のインストールを検出し、上書き前に確認を求め（spec-kitの`specify init --here`パターンと同様）、拒否された場合はユーザーのカスタマイズを保持。`--force`フラグ指定時は確認をスキップして上書き

---

### ユーザーストーリー4: インテリジェントな複数機能の統合 (優先度: P2)

**目的**: 複数の進化する機能を持つspec-kitユーザーが、エンティティとAPIが時間とともにどのように進化するかを追跡しながら、システムが機能間の情報を自動的に統合できるようにすることで、ドキュメントが機能ごとの断片的なスナップショットではなく、プロダクトの現在の統一された状態を反映するようにします。

**この優先度の理由**: これは単純なファイル連結とこのツールを差別化するものです。AI駆動の統合の真の価値を提供しますが、基本的なドキュメント生成には必須ではありません。

**独立テスト**: 001-coreでUser{id, name, email}を定義し、003-profilesでUser.profile_pictureを追加するプロジェクトを作成します。生成されたドキュメントは、導入バージョンでマークされたすべてのフィールドを持つ単一の統合Userエンティティを示します。ドキュメントに2つの別々の矛盾するUser定義が表示されないことを確認します。

**受け入れシナリオ**:

1. **前提条件**: 001/data-model.mdがUserエンティティをフィールド[id, name, email]で定義し、003/data-model.mdがUserに[profile_picture, bio]を追加、**実行**: 統合を有効にしてドキュメントが生成される、**期待結果**: データモデルセクションに5つすべてのフィールドを持つ単一の統合Userエンティティが表示され、各フィールドを導入した機能で注釈が付けられる

2. **前提条件**: 001/contracts/api.jsonがエンドポイント[POST /users, GET /users/{id}]を定義し、003/contracts/extended-api.jsonが[PUT /users/{id}/profile, GET /users/{id}/activity]を追加、**実行**: 統合が実行される、**期待結果**: APIリファレンスセクションが4つすべてのエンドポイントをリソースごとにグループ化してリストし、各エンドポイントを導入した機能を示すメモが含まれる

3. **前提条件**: 001がTaskStatus列挙型を[todo, done]と定義し、003が[todo, in_progress, review, done]に拡張、**実行**: 統合がこの進化を検出、**期待結果**: ドキュメントが4つすべての値を持つ現在の列挙型を示し、メモが含まれる:「機能003でin_progressとreview状態を追加するために拡張されました。」

4. **前提条件**: 同じエンティティを互換性のない方法で変更する2つの機能(例:フィールドタイプがstringからenumに変更)、**実行**: 統合がそれらをマージしようとする、**期待結果**: システムが競合を検出し、時間ベースの解決(後の機能が優先)を適用し、ドキュメントに「Breaking Change」注釈を追加

---

### ユーザーストーリー5: 対象者別ドキュメント (優先度: P3)

**目的**: 異なるステークホルダー向けのドキュメントを準備するspec-kitユーザーが、エンドユーザー、外部開発者、コントリビューター向けに別々のドキュメントバージョンを生成できるようにすることで、各対象者が無関係な技術的詳細や内部実装メモに圧倒されることなく、ニーズに適した情報を受け取れるようにします。

**この優先度の理由**: 価値はありますが、ユーザーは最初は手動でコンテンツをフィルタリングできます。これは使いやすさを向上させますが、基本機能には必須ではありません。

**独立テスト**: --audience=enduserフラグでドキュメントを生成します。plan.mdからの技術的アーキテクチャの詳細とtasks.mdからの内部タスクの内訳が除外され、spec.mdからの機能説明が含まれていることを確認します。次に--audience=developerで生成し、APIコントラクトとデータモデルが含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: spec.md、plan.md、tasks.md、data-model.md、contracts/を含む完全な機能仕様を持つプロジェクト、**実行**: ユーザーが--audience=enduserでドキュメントを生成、**期待結果**: 出力に機能説明とクイックスタートガイドが含まれるが、技術的アーキテクチャ、タスクの内訳、実装の詳細は除外される

2. **前提条件**: 同じプロジェクト、**実行**: ユーザーが--audience=developerでドキュメントを生成、**期待結果**: 出力に完全なAPI仕様、データモデルの詳細、アーキテクチャの決定、実装ステータスに関係なくすべての機能が含まれる(実装済み/進行中/計画済みとしてマーク)

3. **前提条件**: 同じプロジェクト、**実行**: ユーザーが--audience=contributorでドキュメントを生成、**期待結果**: 出力にすべてが含まれる:機能仕様、アーキテクチャ、データモデル、API、タスクの内訳、実装ガイドライン、開発セットアップ手順

4. **前提条件**: gitブランチステータスを介して「進行中」とマークされた機能、**実行**: --audience=enduserドキュメントの生成、**期待結果**: その機能が出力から除外されるが、--audience=developerドキュメントの生成時には、「(進行中)」ステータスバッジ付きで機能が含まれる

---

### ユーザーストーリー6: バージョン履歴とトレーサビリティ (優先度: P3)

**目的**: 成長するプロダクトを維持するspec-kitユーザーが、明確なバージョン履歴とともに、エンティティとAPIが機能間でどのように進化したかを確認できるようにすることで、プロダクトの進化を理解し、破壊的変更を伝え、コントリビューターがアーキテクチャの決定を理解するのを支援できるようにします。

**この優先度の理由**: これは基本的なドキュメントニーズには必須ではない、プロフェッショナルな仕上げを追加する便利な拡張機能です。

**独立テスト**: 3つの機能にわたってUserエンティティが変更されたプロジェクトのドキュメントを生成します。Userエンティティのドキュメントに、各機能で何が変更され、なぜ変更されたかを示す「バージョン履歴」セクションが含まれていることを確認します。

**受け入れシナリオ**:

1. **前提条件**: Userエンティティが3つの機能にわたって進化(001:基本フィールドで作成、002:profile_picture追加、003:privacy_settings追加)、**実行**: ドキュメントが生成される、**期待結果**: Userエンティティページに、何が変更されたかを示し、各変更を導入した機能仕様にリンクする3つのエントリを持つ「バージョン履歴」セクションが含まれる

2. **前提条件**: 003でオプションのクエリパラメータを追加するために変更されたAPIエンドポイント/users/{id}、**実行**: ドキュメントが生成される、**期待結果**: エンドポイントドキュメントに変更履歴メモが含まれる:「003で更新:オプションの?include=profile,activityクエリパラメータを追加。」

3. **前提条件**: spec.mdの「根拠」または「前提条件」セクションを参照する機能、**実行**: ドキュメントを統合、**期待結果**: システムがこれらのコンテキストメモを抽出して保持し、関連セクション(例:特定のエンティティ構造が選ばれた理由)に含める

4. **前提条件**: 機能003がTaskStatus列挙値を変更した破壊的変更、**実行**: ドキュメントが生成される、**期待結果**: 破壊的変更が「⚠️ Breaking Change (v003)」バッジと何が変更されたかの説明で明確にフラグ付けされる

---

### ユーザーストーリー7: LLMによるユーザーフレンドリーなドキュメント生成 (優先度: P1) 🎯 MVP

**目的**: エンドユーザー（顧客、プロダクトマネージャー、営業チーム、サポートチーム）にプロジェクトのドキュメントを提供したいspec-kitユーザーが、ユーザー向けコンテンツを優先的に使用し、必要に応じて技術的な仕様書から最小限の情報を抽出して読みやすく親しみやすい形式に変換できるようにすることで、非技術者でもプロジェクトの機能や価値を理解できるドキュメントを作成できるようにします。

**この優先度の理由**: spec.mdは開発者向けの技術仕様書であり、その約80%はエンドユーザーには不要な技術詳細です。README.md/QUICKSTART.mdを優先使用し、存在しない場合のみspec.mdから最小限抽出することで、トークン制限（10,000トークン）を回避し、ユーザー価値に特化したドキュメントを生成します。LLMによる変換は、spec-kit-docsの独自価値を明確化し、単なる「ファイルコピーツール」から「インテリジェントなドキュメント生成ツール」への差別化を実現します。

**独立テスト**: 3つの機能を持つspec-kitプロジェクト（各機能ディレクトリにREADME.mdまたはspec.mdを含む）でClaude Code上で`/speckit.doc-update`を実行します（デフォルトでLLM変換が有効）。生成されたドキュメントを確認し、(1) README.mdが存在する機能はそのコンテンツが優先使用されている、(2) README.mdがない機能はspec.mdから最小限の情報（ユーザーストーリーの「目的」、前提条件、スコープ境界）のみが抽出されている、(3) 抽出されたコンテンツは約4,500トークン（10,000トークン制限内）、(4) 元のspec.mdへのリンクが保持されている、ことを確認します。

**受け入れシナリオ**:

1. **前提条件**: Claude Code環境で、3つの機能（各ディレクトリにspec.mdを含む）を持つspec-kitプロジェクト、**実行**: ユーザーが`/speckit.doc-update`を実行（フラグなし、デフォルトで全機能をLLM変換）、**期待結果**: AIエージェント（Claude Code）が各機能のspec.mdから最小限の情報を抽出し、LLM変換を実行し、変換済みコンテンツをdoc_update.pyスクリプトに渡す。各機能のドキュメントページに変換された「機能概要」セクションが含まれ、技術的な"MUST"表現が自然な文章に変換されている。更新サマリーに「LLM変換: 成功3件、失敗0件」と表示される

2. **前提条件**: 1つの機能のREADME.mdが非常に大きい（10,000トークン超過）プロジェクト、**実行**: `/speckit.doc-update`を実行、**期待結果**: AIエージェントがエラーメッセージ「specs/[BRANCH_NAME]/README.mdが10,000トークンを超過しています（現在: [ACTUAL_SIZE]トークン、上限: 10,000トークン）。README.mdを分割してください」を表示し、プロセス全体が中断される（他の機能の処理も行わない）

3. **前提条件**: 1つの機能のLLM変換処理中にエラーが発生する環境（予期しない例外、API通信エラー等）、**実行**: `/speckit.doc-update`を実行（3機能を含む）、**期待結果**: 最初の機能でエラーが発生した時点でAIエージェントがエラーメッセージ「specs/[BRANCH_NAME]/spec.md のLLM変換中にエラーが発生しました: [エラー詳細]。spec.mdのコンテンツ形式を確認してください」を表示し、プロセス全体が中断される。**フォールバック動作は行わず、他の機能の処理も行わない**（憲章準拠、厳格なエラーハンドリング）

4. **前提条件**: 前回の`/speckit.doc-update`実行後、1つの機能のspec.mdのみが変更されたプロジェクト（3機能）、**実行**: `/ spec kit.doc-update --quick`を実行（`--quick`フラグで変更検出を有効化）、**期待結果**: AIエージェントがGit diffを使用して変更された機能（1件）のみLLM変換を実行し、変更されていない機能（2件）はスキップする。更新サマリーに「LLM変換: 成功1件、スキップ（変更なし）2件、失敗0件」と表示される

5. **前提条件**: LLM変換されたドキュメントページ、**実行**: ユーザーがドキュメントページを確認、**期待結果**: ページに「詳細な技術仕様はspec.mdを参照してください」といった元のファイルへのリンクが含まれており、技術者が正確な情報にアクセスできる

6. **前提条件**: 1つの機能にREADME.md（4,000トークン）とQUICKSTART.md（3,500トークン）が両方存在するプロジェクト（合計7,500トークン、10,000トークン以内）、**実行**: `/speckit.doc-update`を実行、**期待結果**: AIエージェントが不整合検出（FR-038-integ-a）を実行し、不整合がないことを確認後、セクション単位の統合（FR-038-integ-b）により両方のファイルからセクションを抽出し、LLMによる優先順位判定に従って統合する。生成されたドキュメントに両方のファイルからの重要情報が含まれている。更新サマリーに「LLM変換: 成功1件、失敗0件」と表示される

7. **前提条件**: 1つの機能にREADME.md（「Pythonプロジェクト」と記載）とQUICKSTART.md（「Rustプロジェクト」と記載）が両方存在し、技術スタックに矛盾があるプロジェクト、**実行**: `/speckit.doc-update`を実行、**期待結果**: AIエージェントが不整合検出（FR-038-integ-a）で矛盾を検出し、エラーメッセージ「README.mdとQUICKSTART.mdに不整合が検出されました: README.mdは『Pythonプロジェクト』と記述していますが、QUICKSTART.mdは『Rustプロジェクト』と記述しています。ファイルの内容を確認してください」を表示し、プロセス全体が中断される

8. **前提条件**: 1つの機能にREADME.md（6,500トークン）とQUICKSTART.md（5,000トークン）が両方存在するプロジェクト（合計11,500トークン、10,000トークン超過）、**実行**: `/speckit.doc-update`を実行、**期待結果**: AIエージェントが不整合検出後、セクション単位の統合（FR-038-integ-b）によりLLM優先順位判定を実行し、優先順位の高いセクションから順次追加する。合計10,000トークンに達した時点で残りのセクション（低優先度）を除外し、警告メッセージ「以下のセクションはトークン制限により除外されました: README.md『## Advanced Topics』、QUICKSTART.md『### Troubleshooting』」を表示する。LLM変換は成功し、生成されたドキュメントには最重要情報のみが含まれる

---

### エッジケース

- **空の機能ディレクトリ**: 機能フォルダーは存在するがmarkdownファイルがない → 静かにスキップするかユーザーに警告
- **不正なmarkdown**: spec.mdファイルに無効なmarkdown構文がある → 他のファイルの処理を継続し、ファイルパスとともに警告をログ
- **依存関係の欠落**: 機能が以前のどの機能にも存在しないエンティティやAPIを参照している → ドキュメントで潜在的な問題としてフラグ
- **循環依存**: 機能Aが機能Bを参照し、機能Bが機能Aを参照 → サイクルを検出して切断し、関係をドキュメント化
- **非常に大きなプロジェクト**: 数百ページの仕様を持つ50以上の機能 → 段階的に処理し、進行状況を表示し、メモリ使用を最適化
- **非標準のファイル名**: ユーザーがspecs/に追加ファイルを手動で作成 → 予期されるパターンに一致する場合(機能ディレクトリ内の*.md)は含め、それ以外は無視
- **gitブランチの状態**: 機能ブランチが存在するがmainにマージされていない → 実装ステータスを決定し、ドキュメントで適切にマーク
- **複数のコントラクト形式**: 一部の機能はOpenAPI JSONを使用し、他はmarkdownテーブルを使用 → 両方の形式を解析し、統一された表現に正規化
- **部分的な機能仕様**: 機能にspec.mdはあるがplan.mdまたはdata-model.mdがない → 利用可能なファイルからドキュメントを生成し、欠落しているアーティファクトに注意
- **競合するタイムスタンプ**: gitが機能003が002の前にコミットされたことを示す → gitタイムスタンプではなく機能番号を真実の源として使用
- **カスタムテンプレート**: ユーザーがプロジェクト内のspec-template.mdを変更 → 解析時にカスタムセクションを尊重し、フォールバックとして標準セクションを使用

## 要件 *(必須)*

### 機能要件

#### /speckit.doc-init コマンド

- **FR-001**: システムは、プロジェクトルートに `.specify/` ディレクトリが存在することを確認し、spec-kit プロジェクトであることを検証しなければならない
- **FR-002**: システムは、`--type` 引数または対話的プロンプトを通じて、ドキュメントツールの選択（sphinx または mkdocs）をサポートしなければならない
- **FR-003**: AI エージェント（Claude Code）は、Sphinx 初期化の場合、プロジェクト名、著者名、バージョン、言語設定をユーザーから対話的に収集し、コマンドライン引数として doc_init.py に渡さなければならない
- **FR-003a**: doc_init.py は、以下のコマンドライン引数を受け取らなければならない: `--type`, `--project-name`, `--author`, `--version`, `--language`, `--force` (Sphinx の場合)、`--type`, `--project-name`, `--site-name`, `--repo-url`, `--force` (MkDocs の場合)。`--force` フラグが指定された場合、既存の `docs/` ディレクトリを上書きする
- **FR-003b**: doc_init.py は、引数が未指定の場合、合理的なデフォルト値を使用しなければならない。Sphinx の場合：（プロジェクト名：現在のディレクトリ名、著者：Git user.name または "Unknown Author"、バージョン："0.1.0"、言語："ja"）。MkDocs の場合：（プロジェクト名：現在のディレクトリ名、サイト名：プロジェクト名と同じ、リポジトリURL：Git remote origin URL または空文字列）
- **FR-003c**: doc_init.py は、標準入力（stdin）を使用してはならない。すべての設定はコマンドライン引数またはデフォルト値から取得する
- **FR-003d**: doc_init.py は、`docs/` ディレクトリが既に存在し `--force` フラグが指定されていない場合、エラー終了コード 1 とメッセージ "docs/ already exists. Use --force to overwrite." を返さなければならない
- **FR-004**: AI エージェント（Claude Code）は、MkDocs 初期化の場合、プロジェクト名、サイト名、リポジトリURLをユーザーから対話的に収集し、コマンドライン引数として doc_init.py に渡さなければならない
- **FR-005**: システムは、Sphinx の場合、`docs/` ディレクトリに `conf.py`（myst-parser設定を含む）、`index.md`（Markdown形式）、`Makefile`、`make.bat`、および以下のディレクトリ構造を生成しなければならない。すべてのファイルはMarkdown形式（.md）で、MyST Markdown構文をサポート。初期化時に `specs/` ディレクトリ内の機能数をカウントし、構造を決定する：
  - 5機能以下の小規模プロジェクト：フラット構造（`docs/` 直下に機能ページ）
  - 6機能以上のプロジェクト：包括的な構造（`docs/features/`、`docs/guides/`、`docs/api/`、`docs/architecture/`）
- **FR-005a**: システムは、Sphinx初期化時に`conf.py`でmyst-parserを有効化し、Markdown（.md）ファイルを解析できるように設定しなければならない。具体的には：
  - `extensions`に`'myst_parser'`を追加
  - `source_suffix`に`.md`を含める（`.rst`もサポート）
  - MyST Markdownの拡張機能（colon_fence、deflist、tasklist、attrs_inline等）を有効化
- **FR-006**: システムは、MkDocs の場合、`docs/` ディレクトリに `mkdocs.yml`、`docs/index.md`、および以下のディレクトリ構造を生成しなければならない。初期化時に `specs/` ディレクトリ内の機能数をカウントし、構造を決定する：
  - 5機能以下の小規模プロジェクト：フラット構造（`docs/` 直下に機能ページ）
  - 6機能以上のプロジェクト：包括的な構造（`docs/features/`、`docs/guides/`、`docs/api/`、`docs/architecture/`）
- **FR-007**: AI エージェント（Claude Code）は、`docs/` ディレクトリが既に存在する場合、ユーザーに上書き確認を求め、ユーザーが承認した場合のみ `--force` フラグ付きで doc_init.py を呼び出さなければならない。ユーザーが拒否した場合は既存の構造を保持し、処理を中断する
- **FR-008**: doc_init.py は、選択したツールに必要な Python パッケージ（Sphinxの場合：sphinx + myst-parser、MkDocsの場合：mkdocs）を標準出力（stdout）に人間が読みやすい形式で出力しなければならない。形式：「次のパッケージのインストールが必要です: {package_list}」+ 「インストールコマンド: uv add {package_list}」。この出力は、AI エージェント（Claude Code）がユーザーにインストール手順を提示するために使用する
- **FR-008b**: doc_init.py は、以下の**すべての条件**が満たされる場合、ユーザーの承認を得て依存関係を自動的にインストールしなければならない：(1) `pyproject.toml`がプロジェクトルートに存在する、(2) `uv`コマンドが実行環境で利用可能（`shutil.which("uv")`が非None）、(3) `--no-install`フラグが指定されていない、(4) 必要なパッケージが既にインストールされていない（`importlib.util.find_spec()`で検証）
- **FR-008c**: 自動インストールを実行する前に、以下の情報をユーザーに明示しなければならない：(1) インストール予定のパッケージリスト（バージョン制約含む、例：`sphinx>=7.0`, `myst-parser>=2.0`）、(2) 実行されるコマンド（例：`uv add --optional docs sphinx>=7.0 myst-parser>=2.0` または `uv add --group docs sphinx>=7.0 myst-parser>=2.0`、FR-008fで選択された配置先に応じる）、(3) `pyproject.toml`の変更先セクション（`[project.optional-dependencies.docs]` または `[dependency-groups.docs]`）の警告、(4) ユーザーの承認を求める確認プロンプト（`--auto-install`フラグがない場合）。確認プロンプトは`typer.confirm()`を使用し、デフォルト値は`True`とする
- **FR-008d**: 自動インストールの条件が満たされない場合、以下を明確に提示しなければならない：(1) 条件が満たされない理由（`pyproject.toml`不在または`uv`コマンド不在）、(2) **方法1（手動インストール）**: 利用可能なパッケージマネージャーを自動検出（`shutil.which()`で`uv`, `pip`, `poetry`を確認）し、検出されたツールごとのインストールコマンドを表示、(3) **方法2（spec-kitワークフロー）**: 依存関係管理をspec-kitワークフロー（`/speckit.specify` → `/speckit.plan` → `/speckit.tasks` → `/speckit.implement`）で管理する方法を手順と共に説明し、その利点（依存関係がplan.md/tasks.mdに記録され履歴が残る）を明示する
- **FR-008e**: doc_init.py は、以下の2つのコマンドラインフラグをサポートしなければならない：(1) `--auto-install`フラグ指定時は、CI/CD環境での非対話的実行をサポートするため、ユーザー確認をスキップして自動的にインストールを実行する、(2) `--no-install`フラグ指定時は、依存関係チェックとインストールをすべてスキップする（ユーザーが依存関係を手動管理する場合）。`uv add`実行時に失敗した場合（ネットワークエラー、権限エラー、タイムアウト等）は、エラー詳細とFR-008dで定義された代替方法を表示し、終了コード1を返す
- **FR-008f**: AI エージェント（Claude Code）は、`/doc-init` 実行時にユーザーに依存関係の配置先を選択させなければならない。選択肢は：(1) `[project.optional-dependencies.docs]`（推奨、pip/poetry/uv互換、`uv add --optional docs` を使用）、(2) `[dependency-groups.docs]`（uvネイティブ、モダン、`uv add --group docs` を使用）。デフォルトは選択肢(1)とする。選択された配置先はdoc_init.pyに`--dependency-target`引数（値: `optional-dependencies` または `dependency-groups`）として渡され、FR-008cで表示されるコマンド例と実際の`uv add`実行に反映される。この選択により、ドキュメント生成ツール（Sphinx/MkDocs）がメインアプリケーションの依存関係から分離され、アーキテクチャ的に正しい構造が実現される
- **FR-009**: システムは、初期化後すぐにビルド可能な最小限のドキュメント構造を作成しなければならない

#### /speckit.doc-update コマンド

- **FR-010**: システムは、`docs/` ディレクトリが存在し、有効なドキュメントプロジェクト（`conf.py` または `mkdocs.yml`）であることを検証しなければならない
- **FR-011**: システムは、少なくとも spec.md ファイルを含む `specs/` 配下のすべての機能ディレクトリを発見しなければならない
- **FR-012**: システムは、エンドユーザー向けドキュメント生成のため、README.md、QUICKSTART.md、またはspec.mdから抽出されたユーザー向け情報（LLM変換済み）のみを解析し、見出し、リスト、テーブル、コードブロックを含む構造化されたコンテンツを抽出しなければならない。**plan.mdとtasks.mdは開発者向け情報のため、エンドユーザー向けドキュメントから除外される**（Session 2025-10-17 Content Filtering Strategy Q1決定）
- **FR-013**: システムは、Sphinx プロジェクトの場合、各機能の `.md` ファイル（MyST Markdown形式）を生成し、`index.md` の toctree に追加しなければならない。ファイル命名規則：機能ディレクトリ名から番号を除いた説明的な名前（例：`001-user-auth` → `user-auth.md`）。小規模プロジェクト（5機能以下）は `docs/` 直下、大規模プロジェクトは `docs/features/` 内に配置
- **FR-014**: システムは、MkDocs プロジェクトの場合、各機能の `.md` ファイルを生成し、`mkdocs.yml` の nav セクションに追加しなければならない。ファイル命名規則：機能ディレクトリ名から番号を除いた説明的な名前（例：`001-user-auth` → `user-auth.md`）。小規模プロジェクト（5機能以下）は `docs/` 直下、大規模プロジェクトは `docs/features/` 内に配置
- **FR-015**: システムは、LLM変換済みのspec.md情報（ユーザーストーリーの目的、前提条件、スコープ境界）、またはREADME.md/QUICKSTART.mdの内容を含むユーザーフレンドリーなコンテンツを保持しなければならない。元の技術仕様へのリンク（Feature Filesセクション）を含める
- **FR-016 (削除)**: **plan.mdはエンドユーザー向けドキュメントから除外される**（Session 2025-10-17 Content Filtering Strategy Q1決定）。開発者向けには元のplan.mdファイルへのリンクを提供する
- **FR-017 (削除)**: **tasks.mdはエンドユーザー向けドキュメントから除外される**（Session 2025-10-17 Content Filtering Strategy Q1決定）。開発者向けには元のtasks.mdファイルへのリンクを提供する
- **FR-018**: システムは、README.md/QUICKSTART.md/spec.mdからユーザー向けコンテンツを抽出してドキュメントを生成しなければならない。元の仕様書へのリンク（spec.md、plan.md、tasks.md）をFeature Filesセクションに含め、技術者が詳細にアクセスできるようにする
- **FR-019**: システムは、Git の変更履歴（git diff）を使用して前回の更新以降に変更されたファイルのみを検出し、変更されたファイルのみを再処理し、変更されていないファイルは保持しなければならない
- **FR-019a**: システムは、`/speckit.doc-update` 実行時に現在の機能数をカウントし、現在フラット構造（`docs/` 直下に機能ページ）で機能数が6以上になった場合、自動的に包括的構造（`docs/features/`、`docs/guides/`、`docs/api/`、`docs/architecture/`）に移行しなければならない。移行時には既存の機能ページを `docs/features/` に移動し、インデックスとナビゲーションを更新する
- **FR-019b**: システムは、逆方向の移行（包括的構造からフラット構造への移行）を行ってはならない。一度包括的構造に移行したプロジェクトは、機能数が減少しても包括的構造を維持する
- **FR-020**: システムは、更新後に何個の機能が更新され、何個が変更なしだったかを示すサマリーを表示しなければならない。構造移行が発生した場合は「フラット構造から包括的構造に移行しました」というメッセージも含める

#### インストールとプロジェクト構造

- **FR-021**: `speckit-docs`CLIツールは、独立したPythonパッケージとしてGitHubから配布され、**エンドユーザー向けの推奨インストール方法は`uv tool install speckit-docs --from git+https://github.com/drillan/spec-kit-docs.git`とする**。この方法は本家spec-kitの`uv tool install specify-cli`パターンと一貫性を保ち、グローバルCLIツールとしてプロジェクト環境を汚染せずに管理される。開発者向けのコントリビューション時には`uv pip install -e .`（編集可能インストール）も引き続きサポートするが、README.mdなどのエンドユーザー向けドキュメントでは`uv tool install`方式を唯一の推奨方法として記載する。PyPI公開は将来のフェーズで検討する
- **FR-021a**: `speckit-docs install`コマンドは、カレントディレクトリがspec-kitプロジェクトであることを確認し（`.specify/`ディレクトリと`.claude/`ディレクトリの存在確認）、そうでない場合は明確なエラーメッセージを表示しなければならない
- **FR-021b**: `speckit-docs install`コマンドは、カレントディレクトリに自動的にインストールし、明示的なディレクトリ指定引数を要求してはならない（`cd my-project && speckit-docs install`パターン）
- **FR-022**: `speckit-docs install`コマンドは、インストール時に `.claude/commands/speckit.doc-init.md` と `.claude/commands/speckit.doc-update.md` の2つのコマンド定義を作成しなければならない（Claude Codeが `/speckit.doc-init` と `/speckit.doc-update` として認識し、spec-kitの他のコマンドとの命名規則の一貫性を保つ）
- **FR-022a**: `.claude/commands/speckit.doc-init.md` は、以下のワークフローを実行するプロンプトを記述しなければならない：(1) ユーザーに対話的に質問（ドキュメントツール選択、プロジェクト名、著者名、バージョン、言語等）、(2) 収集した情報をコマンドライン引数に構築、(3) `uv run python .specify/scripts/docs/doc_init.py` を適切な引数で呼び出し、(4) スクリプトの結果をユーザーにフィードバック、(5) エラーが発生した場合は明確なメッセージと次のステップを提示
- **FR-022b**: `.claude/commands/speckit.doc-update.md` は、以下のワークフローを実行するプロンプトを記述しなければならない：(1) `docs/` ディレクトリの存在確認、(2) **各機能に対してLLM変換を実行**（FR-038のロジックに従い、README.md/QUICKSTART.md/spec.mdからコンテンツを選択・抽出し、Claude APIで変換）、(3) **変換済みコンテンツを一時ファイルまたはコマンドライン引数として準備**、(4) `uv run python .specify/scripts/docs/doc_update.py --transformed-content <path>` の呼び出し、(5) 更新されたファイルのサマリー表示、(6) エラーハンドリングとユーザーフィードバック
- **FR-023**: `speckit-docs install`コマンドは、インストール時に必要なスクリプト（`doc_init.py`、`doc_update.py`）を `.specify/scripts/docs/` にコピーしなければならない
- **FR-023a**: コマンドテンプレートファイル（`speckit.doc-init.md`、`speckit.doc-update.md`）とスクリプトファイル（`doc_init.py`、`doc_update.py`）は `src/speckit_docs/commands/` および `src/speckit_docs/scripts/` ディレクトリに配置され、`importlib.resources`を使用してアクセスされなければならない。これにより、Pythonパッケージに含まれ、オフライン環境でも動作する
- **FR-023b**: `speckit-docs install` コマンドは、既存のコマンド定義ファイル（`.claude/commands/speckit.doc-*.md`）または スクリプトファイル（`.specify/scripts/docs/`）が存在する場合、ユーザーに上書き確認を求めなければならない。`--force` フラグが指定された場合は、確認をスキップして上書きする（spec-kitの`specify init --here`パターンと一貫）
- **FR-023c**: インストール中にエラーが発生した場合、システムはベストエフォート方式で動作し、エラー発生時点までにコピーされたファイルは残す。ユーザーは手動で修正するか、問題を解決してから再実行できる（spec-kitの既存ディレクトリへの追加パターンと一貫）
- **FR-024**: システムは、コンテンツを統合する際に時間的順序を決定するために、機能ディレクトリの番号付け（001、002、003）を使用しなければならない

#### 高度な機能（将来のフェーズ）

- **FR-025**: システムは、複数の data-model.md ファイルからエンティティ定義を統合し、現在の状態と進化を示す統一されたデータモデルを生成しなければならない（P2）。「進化を示す」とは、以下の情報を含むことを意味する：(a) 各フィールドを導入した機能番号（例：`profile_picture` (added in 003)）、(b) フィールドが変更された場合の変更履歴（例：`status: string → TaskStatus enum` (changed in 005)）、(c) 削除されたフィールドの記録（例：`~~old_field~~` (removed in 007)）。詳細な出力形式は、Phase 2実装時にdata-model.mdまたは専用の設計ドキュメントで定義される
- **FR-026**: システムは、複数の機能の contracts/ ディレクトリから API 仕様をマージし、統一された API リファレンスを生成しなければならない（P2）
- **FR-027**: システムは、競合する情報（例：同じエンティティの異なる定義）を検出し、最新優先戦略を使用して解決しなければならない（P2）
- **FR-028**: システムは、各要素を導入または変更した機能を示すために、統合されたコンテンツに注釈を付けなければならない（P2）
- **FR-029**: システムは、対象者パラメータに基づいてコンテンツをフィルタリングしなければならない：enduser（機能と使用法のみ）、developer（API とアーキテクチャ）、contributor（すべて）（P3）
- **FR-030**: システムは、機能の実装ステータスを決定するために git リポジトリの状態を確認しなければならない（main にマージ済み=実装済み、ブランチとして存在=進行中、ブランチなし=計画済み）（P3）
- **FR-031**: システムは、機能間での進化を示すエンティティと API のバージョン履歴セクションを生成しなければならない（P3）
- **FR-032**: システムは、破壊的変更（タイプの変更、削除されたフィールド、変更された列挙型）を警告バッジでフラグ付けしなければならない（P3）

#### エラーハンドリングと品質

- **FR-033**: システムは、一般的な問題に対して明確なエラーメッセージを提供しなければならない：spec-kit プロジェクトではない、ドキュメントプロジェクトが初期化されていない、機能が見つからない、不正なファイル
- **FR-034**: システムは、オフラインで表示でき、任意の Web サーバーでホストできる静的 HTML ファイルとしてドキュメントを生成しなければならない
- **FR-035**: システムは、不正な markdown を適切に処理し、他のファイルの処理を継続し、特定のエラーを報告しなければならない。すべてのエラーは `SpecKitDocsError` 例外として発生させ、エラーメッセージには「ファイルパス」「エラーの種類」「ユーザーへの推奨アクション」を含める。AI エージェント（Claude Code）は、この構造化されたエラーメッセージをユーザーにわかりやすく提示する
- **FR-036**: システムは、コードリント・フォーマットに**ruff**を使用しなければならない（blackは禁止）。`pyproject.toml`で以下の設定を指定する：`select = ["E", "F", "W", "I"]`（エラー、致命的エラー、警告、import順序）、`line-length = 100`、`target-version = "py311"`。開発者は`uv run ruff check .`でローカル実行する（CI/CDパイプラインは構築しない）
- **FR-037**: システムは、Pythonの標準logging模块を使用した構造化ログを実装しなければならない。デフォルトでINFOレベル以上を標準出力に出力し、`--verbose`フラグでDEBUGレベル、`--quiet`フラグでERRORレベルのみを出力する。ログメッセージは進捗情報（「3機能を処理中...」等）とエラー詳細を含む

#### LLMドキュメント変換機能（Phase 1 - MVP）

- **FR-038**: AIエージェント（Claude Code）は、`/speckit.doc-update`実行時、以下のロジックでコンテンツソースを選択し、LLM変換を使用してユーザーフレンドリーなドキュメントに変換しなければならない：**(1) README.md/QUICKSTART.md統合（両方存在）** - README.mdとQUICKSTART.mdが両方存在する場合、**不整合検出**（FR-038-integ-a）を実行後、**セクション単位の統合**（FR-038-integ-b）により両方の内容を統合する、**(2) README.mdのみ** - README.mdのみ存在する場合、そのコンテンツを使用、**(3) QUICKSTART.mdのみ** - QUICKSTART.mdのみ存在する場合、そのコンテンツを使用、**(4) spec.md最小限抽出** - README.md/QUICKSTART.mdが両方存在しない場合、**構造化マークダウン解析**を使用してspec.mdから最小限の情報のみ抽出する。**spec.md抽出実装**（markdown-it-pyまたは正規表現を使用）：(i) **ユーザーストーリーの目的** - すべての`### ユーザーストーリーN:`（Nは数字）セクションを検出し、その下の`**目的**:`から次の`**`（または`###`、`##`）までのテキストを抽出、(ii) **前提条件** - `## 前提条件`（または`## Prerequisites`）セクション見出しから次の`##`セクションまでの全テキストを抽出（サブセクション`###`を含む）、(iii) **スコープ境界** - `## スコープ境界`セクション内の`**スコープ外（フェーズ1 - MVP）**:`（または`**Out of Scope (Phase 1 - MVP)**:`）から次の`**`（または`##`）までのリストを抽出。抽出されたテキストを結合し、トークン数を計測（約4,500トークン、最大10,000トークン制限内を保証）。**抽出失敗時のエラーハンドリング**: 必須セクション（ユーザーストーリーの目的、前提条件、スコープ境界）が見つからない場合、明確なエラーメッセージを表示し、プロセスを中断する（例：「specs/[BRANCH_NAME]/spec.mdが推奨構造に従っていません。『## 前提条件』セクションが見つかりません。spec.mdの構造を確認してください」）。変換では、技術的な表現を自然な文章に変換する（例：「FR-001: System MUST allow users to...」→「ユーザーは...できます」）。変換済みコンテンツは一時ファイルまたはコマンドライン引数としてバックエンドスクリプト（doc_update.py）に渡される。元の技術仕様へのリンクを必ず含める（例：「詳細な技術仕様はspec.mdを参照してください」）
- **FR-038a**: AIエージェント（Claude Code）は、LLM変換対象のコンテンツサイズが設定された上限（デフォルト: 1機能あたり10,000トークン）を超える場合、明確なエラーメッセージを返してプロセスを中断しなければならない。エラーメッセージには「ファイルパス」「現在のトークン数」「上限」「推奨アクション」を含める。例：README.mdの場合「specs/[BRANCH_NAME]/README.mdが10,000トークンを超過しています（現在: [ACTUAL_SIZE]トークン、上限: 10,000トークン）。README.mdを分割してください」、QUICKSTART.mdの場合「specs/[BRANCH_NAME]/QUICKSTART.mdが10,000トークンを超過しています（現在: [ACTUAL_SIZE]トークン、上限: 10,000トークン）。QUICKSTART.mdを分割してください」、spec.md最小限抽出の場合（理論上発生しないが）「specs/[BRANCH_NAME]/spec.mdから抽出されたコンテンツが10,000トークンを超過しています（現在: [ACTUAL_SIZE]トークン、上限: 10,000トークン）。spec.mdのユーザーストーリー、前提条件、スコープ境界セクションを簡潔化してください」
- **FR-038b**: AIエージェント（Claude Code）は、LLM変換処理中にエラーが発生した場合（予期しない例外、コンテンツ形式エラー、API通信エラー等）、明確なエラーメッセージを返してプロセスを中断しなければならない。エラーメッセージには「ファイルパス」「エラー種類」「推奨アクション」を含める（例：「specs/[BRANCH_NAME]/spec.md のLLM変換中にエラーが発生しました: [エラー詳細]。spec.mdのコンテンツ形式を確認してください」）。**フォールバック動作は行わない**（憲章準拠）
- **FR-038c**: AIエージェント（Claude Code）は、LLM生成コンテンツに対して以下の4つの品質チェックを実行し、いずれか1つでも不合格の場合は明確なエラーメッセージを返してプロセスを中断しなければならない：(1) **空文字列チェック** - 変換結果が空文字列または空白のみの場合エラー、(2) **最小文字数チェック** - 変換結果が50文字未満の場合エラー（LLMが正常に動作していない可能性）、(3) **エラーパターンマッチング** - 以下のパターンを大文字小文字を区別しない正規表現で検出し、含まれる場合エラー：英語（`\berror\b`, `\bfailed\b`, `\binvalid\b`, `\bcannot\b`, `\bunable\b`）、日本語（`申し訳`, `すみません`）、(4) **Markdownリンター** - markdown-it-py（既存依存関係）を使用してMarkdown構文をパースし、構文エラー（例外）が発生した場合エラー。エラーメッセージには「ファイルパス」「エラー種類」「推奨アクション」を含める。例：空文字列の場合「specs/[BRANCH_NAME]/spec.md のLLM変換結果が空です。spec.mdのコンテンツを確認してください」、エラーパターンの場合「specs/[BRANCH_NAME]/spec.md のLLM変換結果にエラーパターン 'error' が含まれます。spec.mdのコンテンツを確認してください」、Markdown構文エラーの場合「specs/[BRANCH_NAME]/spec.md のLLM変換結果のMarkdown形式が不正です（理由: [構文エラー詳細]）。spec.mdのコンテンツを確認してください」。**フォールバック動作は行わない**（憲章準拠）
- **FR-038d**: コマンド定義（`.claude/commands/speckit.doc-update.md`）は、生成されるドキュメントページに元のspec.mdファイルへのリンク（例：「詳細な技術仕様はspec.mdを参照してください」）を必ず含めるようスクリプトに指示しなければならない。これにより、技術者が元の正確な情報にアクセスできることを保証する
- **FR-038e**: バックエンドスクリプト（`.specify/scripts/docs/doc_update.py`）の`transformed_content`パラメータは、必須パラメータ（`typer.Option(...)`）として定義されなければならない。Session 2025-10-17決定（LLM変換は常に実行される）との整合性を保ち、コマンド定義がLLM変換を実行し忘れた場合に即座にエラーで検知できるようにする。パラメータが提供されない場合、スクリプトは明確なエラーメッセージ「--transformed-contentパラメータは必須です。LLM変換を実行してから.specify/scripts/docs/doc_update.pyを呼び出してください」を表示して終了する
- **FR-038-integ-a**: AIエージェント（Claude Code）は、README.mdとQUICKSTART.mdが両方存在する場合、**LLMによる不整合検出**を実行しなければならない。両方のファイルの内容をLLMに渡し、「これら2つのファイルは同じプロジェクトを説明していますか？重大な矛盾（技術スタック、主要機能、目的の食い違い）がありますか？」と判定を依頼する。**許容される差異**: 表記揺れ、詳細度の違い、補完的な情報。**不整合とみなす**: 異なる技術スタック（例: 「Pythonプロジェクト」vs「Rustプロジェクト」）、矛盾する機能説明、異なるプロジェクト目的。不整合が検出された場合、明確なエラーメッセージを表示してプロセス全体を中断する（例：「README.mdとQUICKSTART.mdに不整合が検出されました: README.mdは『Pythonプロジェクト』と記述していますが、QUICKSTART.mdは『Rustプロジェクト』と記述しています。ファイルの内容を確認してください」）。LLM呼び出しが失敗した場合、明確なエラーメッセージを表示してプロセス全体を中断する（例：「README.mdとQUICKSTART.mdの不整合検出処理中にLLMエラーが発生しました: [エラー詳細]。再実行するか、README.mdまたはQUICKSTART.mdのいずれか一方のみを残してください」）
- **FR-038-integ-b**: AIエージェント（Claude Code）は、README.mdとQUICKSTART.mdの不整合検出が成功した場合（矛盾なし）、**セクション単位の統合**を実行しなければならない。処理手順：(1) markdown-it-pyを使用して両方のファイルをセクション（見出し`##`, `###`）単位でパースする、(2) 抽出した全ての見出しリスト（ファイル名と見出しテキストのペア）をLLMに渡し、「これらはドキュメント生成用のセクション見出しです。エンドユーザー（非技術者を含む）にとって重要度が高い順に並び替えてください」と依頼し、優先順位リストを取得する、(3) LLMが返した優先順位に従ってセクションを順次追加し、合計トークン数が10,000以内に収まるまで追加する、(4) 10,000トークン超過によりセクションが除外された場合、警告メッセージで除外されたセクションのリスト（ファイル名と見出し）を表示する（例：「以下のセクションはトークン制限により除外されました: README.md『## Advanced Topics』、QUICKSTART.md『### Troubleshooting』」）。LLM呼び出し（優先順位判定）が失敗した場合、明確なエラーメッセージを表示してプロセス全体を中断する（例：「README.mdとQUICKSTART.mdのセクション優先順位判定中にLLMエラーが発生しました: [エラー詳細]。再実行するか、README.mdまたはQUICKSTART.mdのいずれか一方のみを残してください」）
- **FR-038f**: AIエージェント（Claude Code）は、更新サマリー（FR-020）にLLM変換の統計情報をモード別に追加しなければならない。**デフォルトモード**（全機能変換）: 「LLM変換: 成功X件、失敗Y件」。**`--quick`モード**（変更検出）: 「LLM変換: 成功X件、スキップ（変更なし）Y件、失敗Z件」。エラーが発生した場合はプロセスが中断されるため、統計情報には処理前の時点での情報のみを表示する
- **FR-038g**: システムは、`--quick`フラグをサポートし、ユーザーがGit diffベースの変更検出を有効化できるようにしなければならない。このフラグが指定された場合、AIエージェントはGit diff（FR-019）を使用して前回のコミットから変更された機能のみLLM変換を実行し、変更されていない機能はスキップする。デフォルト（フラグなし）では、すべての機能に対してLLM変換を実行する（確実性優先）

### 主要エンティティ *(機能がデータを含む場合に含める)*

- **SpecKitProject**: spec-kitプロジェクトを表し、ルートディレクトリ、.specify/設定、specs/ディレクトリを含む
- **Feature**: 単一の機能仕様(例:001-user-auth)で、markdownファイルのコレクション、コントラクト、実装ステータスを含む
- **Entity**: data-model.mdファイルから抽出されたデータモデルエンティティ(例:User、Task)で、フィールド、タイプ、バージョン履歴を含む
- **APIEndpoint**: contracts/からのAPIエンドポイント定義で、メソッド、パス、パラメータ、バージョン履歴を含む
- **DocumentationSite**: ページ、ナビゲーション、アセットを含む生成された出力構造
- **Audience**: 関連するコンテンツフィルタリングルールを持つターゲットオーディエンス(enduser、developer、contributor)の列挙型
- **SynthesisResult**: 機能間でマージした後のエンティティとAPIの統合ビュー
- **FeatureStatus**: gitブランチステータスから派生した実装状態(implemented、in_progress、planned)の列挙型
- **BaseGenerator**: ドキュメントジェネレーターの抽象ベースクラス。以下の4つの必須メソッドを定義：(1) `initialize()` - ドキュメントプロジェクトの初期化と設定ファイル生成、(2) `generate_feature_page(feature: Feature) -> None` - 単一機能のページ生成、(3) `update_navigation() -> None` - 目次（toctree/nav）の更新、(4) `validate() -> bool` - ビルド前検証。SphinxGeneratorとMkDocsGeneratorがこのインターフェースを実装する

## 成功基準 *(必須)*

### 測定可能な成果

#### /speckit.doc-init コマンド

- **SC-001**: ユーザーは `/speckit.doc-init` を実行してから完了まで30秒以内にドキュメントプロジェクトを初期化できる（対話的な入力時間を除く）
- **SC-002**: 必要な依存関係がインストールされている環境、または自動インストールが成功した環境で、初期化されたドキュメントプロジェクトは、追加設定なしでビルドコマンド（`make html` または `mkdocs build`）が成功する。依存関係が`[project.optional-dependencies.docs]`に配置された場合は、`uv sync --all-extras`または`pip install -e ".[docs]"`を実行後にビルドが成功する
- **SC-002b**: `pyproject.toml`と`uv`コマンドが利用可能な環境で、ユーザーが依存関係のインストールを承認した場合、90%以上のケースで`uv add`（`--optional docs`または`--group docs`、FR-008fで選択された配置先に応じる）が成功し、その後のビルドコマンド（`make html`または`mkdocs build`）が成功する。残り10%はネットワークエラー、権限エラー、パッケージリポジトリの一時的な問題等の外部要因による失敗を許容する
- **SC-002c**: FR-008fで選択された依存関係の配置先（`optional-dependencies`または`dependency-groups`）に応じて、100%のケースでユーザーのプロジェクトの`pyproject.toml`の正しいセクション（`[project.optional-dependencies.docs]`または`[dependency-groups.docs]`）に依存関係が追加される。依存関係はメイン依存関係（`[project.dependencies]`）と分離され、アーキテクチャ的に正しい構造が維持される
- **SC-003**: Sphinx と MkDocs の両方のドキュメントツールが正しくサポートされ、それぞれの標準的なプロジェクト構造が生成される
- **SC-004**: 既存の `docs/` ディレクトリを持つプロジェクトで初期化を試みた場合、100% のケースで上書き確認が表示される
- **SC-005**: インタラクティブプロンプトで収集された設定（プロジェクト名、著者名など）が生成された設定ファイルに正確に反映される

#### /speckit.doc-update コマンド

- **SC-006**: ユーザーは5機能のプロジェクトで `/speckit.doc-update` を実行してから45秒以内にドキュメントを更新できる（AI統合時間を除く）
- **SC-007**: 生成されたドキュメントサイトは、Web サーバーを必要とせずに任意のモダン Web ブラウザでナビゲート可能で読みやすい
- **SC-008**: spec.md からのすべてのセクション（ユーザーシナリオ、要件、成功基準、エッジケース）の95%以上が、生成されたドキュメントに正しく含まれる
- **SC-009**: plan.md と tasks.md が存在する機能について、それらのコンテンツの90%以上がドキュメントに統合される
- **SC-010**: 機能に欠落しているファイル（例：plan.md がない）がある場合でも、ドキュメント更新が成功し、利用可能なコンテンツを含み、欠落セクションに適切な注記が表示される
- **SC-011**: 前回の更新以降に変更されていない機能について、システムが再処理をスキップし、更新サマリーに正確な変更/未変更の件数が表示される
- **SC-008b**: 自動インストールの条件（`pyproject.toml`存在かつ`uv`コマンド利用可能）が満たされない場合、100%のケースで利用可能な代替方法（方法1: 手動インストール、方法2: spec-kitワークフロー）が明確に提示される。代替方法には、それぞれの手順と利点（spec-kitワークフローの場合は「依存関係の履歴がplan.md/tasks.mdに記録される」等）が含まれる
- **SC-008c**: `uv add`が失敗した場合（ネットワークエラー、権限エラー、タイムアウト等）、100%のケースで失敗理由と代替方法（FR-008dで定義された方法1と方法2）が明確に提示され、ユーザーが次のアクションを判断できる

#### LLMドキュメント変換機能（Phase 1 - MVP）

- **SC-022**: LLM変換実行時、100%のケースでコンテンツソース選択ロジック（FR-038）が正しく動作する：(1) README.mdとQUICKSTART.mdが両方存在する場合、不整合検出（FR-038-integ-a）とセクション単位の統合（FR-038-integ-b）が実行される、(2) README.mdのみ存在する場合、README.mdのみ使用、(3) QUICKSTART.mdのみ存在する場合、QUICKSTART.mdのみ使用、(4) 両方存在しない場合、構造化マークダウン解析を使用してspec.mdから最小限抽出（すべてのユーザーストーリーの「**目的**:」段落、「## 前提条件」セクション全体、「## スコープ境界」内の「**スコープ外（フェーズ1 - MVP）**:」リスト）。抽出されたコンテンツは95%以上のケースで4,500トークン以内（10,000トークン制限内を保証）。Claude Code環境でAIエージェントによるLLM変換が成功し、コンテンツが自然な文章に変換される（エラー発生時はプロセス全体が中断される）
- **SC-022-integ-a**: README.mdとQUICKSTART.mdが両方存在し、LLMによる不整合検出（FR-038-integ-a）を実行した場合、100%のケースで以下の動作が保証される：(1) 重大な矛盾（異なる技術スタック、矛盾する機能説明、異なるプロジェクト目的）が検出された場合、明確なエラーメッセージが表示されプロセス全体が中断される、(2) 表記揺れ、詳細度の違い、補完的な情報は許容され、不整合とみなされない、(3) LLM呼び出しが失敗した場合、明確なエラーメッセージが表示されプロセス全体が中断される（フォールバックなし、憲章準拠）
- **SC-022-integ-b**: README.mdとQUICKSTART.mdが両方存在し、不整合検出が成功した場合、セクション単位の統合（FR-038-integ-b）により、100%のケースで以下の動作が保証される：(1) 両方のファイルがセクション（見出し`##`, `###`）単位でパースされる、(2) LLMによるセクション優先順位判定により、エンドユーザーにとって重要度の高い順にセクションが並び替えられる、(3) 優先順位順にセクションが追加され、合計トークン数が10,000以内に収まる、(4) 10,000トークン超過によりセクションが除外された場合、除外されたセクションのリスト（ファイル名と見出し）が警告メッセージで表示される、(5) LLM呼び出し（優先順位判定）が失敗した場合、明確なエラーメッセージが表示されプロセス全体が中断される（フォールバックなし、憲章準拠）
- **SC-022c**: spec.mdから最小限抽出を行う際、spec.mdが推奨構造に従っていない場合（必須セクション「## 前提条件」「## スコープ境界」「### ユーザーストーリーN:」のいずれかが存在しない）、100%のケースで明確なエラーメッセージが表示され、プロセス全体が中断される。エラーメッセージには「ファイルパス」「見つからないセクション名」「推奨アクション（spec.mdの構造を確認）」が含まれる
- **SC-022b**: README.md/QUICKSTART.mdが10,000トークンを超える場合、100%のケースで明確なエラーメッセージが表示され、プロセス全体が中断される。エラーメッセージには「ファイルパス」「現在のトークン数」「上限: 10,000トークン」「推奨アクション（ファイルを分割）」が含まれる
- **SC-023**: LLM変換失敗時（コンテンツサイズ超過、変換処理エラー、品質チェック不合格）、100%のケースで明確なエラーメッセージ（「ファイルパス」「エラー種類」「推奨アクション」を含む）が表示され、プロセスが中断される。**フォールバック動作は行わない**（憲章準拠）
- **SC-023b**: LLM生成コンテンツの品質チェック（FR-038c）により、100%のケースで以下の不正コンテンツが検出され、プロセスが中断される：(1) 空文字列または空白のみ、(2) 50文字未満の短すぎるコンテンツ、(3) エラーパターン（`error`, `failed`, `invalid`, `cannot`, `unable`, `申し訳`, `すみません`）を含むコンテンツ、(4) Markdown構文エラー（markdown-it-pyのパース例外）を含むコンテンツ。エラーメッセージには具体的なエラー理由（「空文字列」「短すぎる（X文字）」「エラーパターン: error」「Markdown構文エラー: [詳細]」）が含まれる
- **SC-024**: LLM変換されたドキュメントページの100%に、元のspec.mdファイルへのリンクが含まれ、技術者が詳細な情報にアクセスできる
- **SC-025**: `--quick`フラグ指定時、Git diffベースの変更検出により、変更されていない機能が95%以上のケースで正しくスキップされ、変更された機能のみLLM変換が実行される。更新サマリーに「LLM変換: 成功X件、スキップ（変更なし）Y件、失敗Z件」と正確に表示される
- **SC-026**: 更新サマリーの統計情報が実行モードに応じて正しく表示される：**デフォルトモード**（フラグなし）では「LLM変換: 成功X件、失敗Y件」、**`--quick`モード**では「LLM変換: 成功X件、スキップ（変更なし）Y件、失敗Z件」。エラー発生時はプロセス全体が中断されるため、統計には処理前の時点での情報のみが含まれる
- **SC-027**: LLM変換されたドキュメントは、非技術者（プロダクトマネージャー、営業チーム、サポートチーム等）にとって、技術的な仕様書よりも理解しやすい（主観的評価：ユーザーテストで80%以上の非技術者が「理解しやすい」と回答）

#### インストールと統合

- **SC-013**: 新しい spec-kit プロジェクトでのインストールが10秒以内に正常に完了する
- **SC-014**: ユーザーはインストール直後に追加設定なしで Claude Code で `/speckit.doc-init` と `/speckit.doc-update` を実行できる
- **SC-015**: インストールされた2つのコマンド定義が Claude Code のコマンドリストに正しく表示される

#### 高度な機能（将来のフェーズ）

- **SC-016**: すべての機能からのエンティティフィールドと API エンドポイントの95%が、統合されたドキュメントに正しく含まれる（P2）
- **SC-017**: エンティティの進化が少なくとも3つの機能にわたって正確に追跡され、何がいつ変更されたかを示す変更履歴が表示される（P2）
- **SC-018**: enduser ドキュメントは、技術的実装の詳細（plan.md のアーキテクチャセクション、tasks.md）を100%除外する（P3）
- **SC-019**: developer ドキュメントは、実装ステータスに関係なく、API エンドポイントとデータモデルエンティティを100%含む（P3）
- **SC-020**: 破壊的変更は、エンティティまたは API 定義が互換性のない方法で変更された場合の少なくとも90%で正しく識別され、フラグ付けされる（P3）
- **SC-021**: システムは、標準的なケース（マージ済み、ブランチが存在、ブランチなし）の100%で、git ブランチ状態から機能の実装ステータスを正しく決定する（P3）

## スコープ境界 *(オプション)*

**スコープ内（フェーズ1 - MVP）**:
- `/speckit.doc-init` コマンド：ドキュメントプロジェクトの初期化
  - Sphinx および MkDocs のサポート（`--type` 引数で選択）
  - インタラクティブな設定収集（プロジェクト名、著者、バージョン）
  - 標準的なディレクトリ構造とビルド可能な設定ファイルの生成
  - 既存 `docs/` ディレクトリの上書き確認
- `/speckit.doc-update` コマンド：spec-kit 仕様からのドキュメント更新
  - markdown ファイル解析（spec.md、plan.md、tasks.md）
  - Sphinx（.md with MyST）および MkDocs（.md）形式でのドキュメントページ生成
  - 機能ページの自動生成と目次への追加
  - インクリメンタル更新（変更されたファイルのみを再処理）
  - 欠落ファイルの適切な処理と注記
- 既存の spec-kit プロジェクトへの拡張機能としてのインストール
- Claude Code AI エージェントのサポート
- 機能ディレクトリの番号付け（001、002、003）による時系列順序の維持

**スコープ内（フェーズ2 - 高度な統合）**:
- エンティティ統合と競合解決のための LLM API を使用した AI 駆動の統合
- 複数の data-model.md ファイルからのエンティティ定義の統合
- 複数の機能の contracts/ ディレクトリからの API 仕様のマージ
- 統合されたコンテンツへの機能トレーサビリティ注釈
- 競合する情報の検出と解決（最新優先戦略）

**スコープ内（フェーズ3 - 高度な機能）**:
- 対象者別フィルタリング（enduser、developer、contributor）
- git ブランチステータスからの実装ステータス検出
- 機能間のバージョン履歴追跡
- 破壊的変更の自動検出とフラグ付け

**スコープ外（将来のフェーズ）**:
- アンインストールコマンド（`speckit-docs uninstall`） - MVP範囲外。少数のファイルなので手動削除で十分。本家spec-kitも提供していない
- 専用アップグレードコマンド - `speckit-docs install --force`で代替可能（本家spec-kitの`specify init --here --force`パターン）
- 他のドキュメントジェネレータ（Docusaurus、VitePress）のサポート - 将来検討
- 他の AI エージェント（GitHub Copilot、Gemini、Cursor）のサポート - 将来検討
- インタラクティブなドキュメント機能（検索、フィルタリング、ライブ例） - 将来検討
- 多言語ドキュメント生成（i18n） - 将来検討
- ホスティングとデプロイの自動化（GitHub Pages、Netlify） - 将来検討
- カスタムテーマとブランディング - 将来検討
- PDF と ePub エクスポート - 将来検討
- API ドキュメントテスト（実行中の API に対するコントラクトの検証） - 将来検討
- ドキュメントのバージョン管理（複数のプロダクトバージョンのドキュメントの維持） - 将来検討

## 前提条件 *(オプション)*

### フェーズ1（MVP）の前提条件

1. **spec-kit プロジェクト**: ユーザーは有効な spec-kit プロジェクト（`.specify/` と `.claude/` ディレクトリを持つ）を持っている
2. **仕様フォーマット**: ユーザーは、期待されるセクション見出しを持つ spec.md、plan.md、tasks.md の標準 spec-kit テンプレートに従う
3. **機能番号付け**: 機能は順番に番号付けされ（001、002、003）、番号は時系列順を反映する
4. **AI エージェントのコンテキスト**: Claude Code はコマンド定義の scripts: frontmatter 経由でシェルスクリプトを実行できる
5. **markdown 規則**: markdown ファイルは GitHub Flavored Markdown 拡張を含む標準 CommonMark 構文を使用する
6. **プロジェクト構造**: spec-kit プロジェクトは、機能ディレクトリを含む `specs/` を持つ標準構造に従う
7. **コマンドの可用性**: ユーザーは環境で必要な依存関係（Python 3.11+、Sphinxの場合：sphinx + myst-parser、MkDocsの場合：mkdocs）を利用可能、またはインストールできる
7a. **specify-cli依存関係**: spec-kit-docsは`specify-cli`に依存し、pyproject.tomlでGit URL直接指定（`specify-cli @ git+https://github.com/github/spec-kit.git`）を使用する。specify-cliは公開リポジトリであり、通常のpip/uvインストールで取得可能
8. **ファイルシステムアクセス**: ツールは `.specify/` ディレクトリへの読み取りアクセスと `docs/` ディレクトリへの書き込みアクセスを持つ
9. **ネットワークアクセス**: インストールは PyPI からパッケージをダウンロードできる
10. **合理的な規模**: ほとんどのプロジェクトは1-20機能を持つ；50以上の機能の最適化は便利な追加機能
11. **言語**: 仕様は主に日本語または英語で書かれる；多言語サポートは将来の作業
12. **Git 使用**: プロジェクトは git リポジトリである必要がある（インクリメンタル更新での変更検出に git diff を使用）

### フェーズ2以降の追加前提条件

13. **Git ブランチング**: プロジェクトは標準ブランチング（機能ブランチが main にマージ）で git を使用する（実装ステータス検出に必要）
14. **LLM アクセス**: ユーザーは、十分なレート制限を持つ統合機能用の LLM API（Claude、GPT-4）へのアクセスを持つ（AI 駆動の統合に必要）
15. **data-model.md と contracts/**: 高度な統合機能を使用する場合、機能は data-model.md や contracts/ ディレクトリを含む
16. **一貫したエンティティ命名**: 機能間で統合されるエンティティは一貫した命名を使用する（例：User、user_entity ではなく User）

## 非機能要件 *(オプション)*

### フェーズ1（MVP）

- **パフォーマンス**:
  - `/speckit.doc-init` は30秒以内に完了する（対話的入力時間を除く）
  - `/speckit.doc-update` は、最大10機能のプロジェクトで45秒以内に完了する（フル更新時）
  - インクリメンタル更新により、変更されていない機能の再処理を回避し、以下の基準を満たす：
    - 1機能のみ変更された場合、更新時間は5秒以内（フル更新比で約90%削減、SC-008）
    - 変更されていない機能のファイル読み取り・解析をスキップ
    - Git diff検出のオーバーヘッドは1秒以内
- **信頼性**:
  - システムは不正な markdown を適切に処理し、他のファイルの処理を継続し、特定のエラーを報告する
  - 欠落しているファイル（plan.md、tasks.md）がある場合でも処理を継続
  - `speckit-docs install` コマンドはベストエフォート方式で動作し、エラー発生時もそれまでにコピーされたファイルは残す（spec-kitの`specify init --here`パターンと一貫）。ユーザーは手動で修正するか、問題解決後に再実行可能
  - **依存関係自動インストール成功率**: pyproject.toml + uv環境が整っている場合、90%以上のケースで依存関係インストールが成功する（SC-002b、ネットワークエラー・権限エラー・タイムアウト等の10%許容）
  - **タイムアウト制限**: `uv add`コマンドの実行は300秒（5分）でタイムアウトし、明確なエラーメッセージと代替手段を提示する（FR-008e）
  - **エラー伝播**: すべてのエラーは`SpecKitDocsError`例外として明示的に伝播され、隠蔽されない。エラーメッセージには「ファイルパス」「エラー種類」「推奨アクション」を含む（Constitution C002準拠）
- **セキュリティ**:
  - **依存関係バリデーション**: `importlib.util.find_spec()`を使用してパッケージのインストール状態を検証し、不正なパッケージ名や存在しないパッケージの誤インストールを防ぐ（FR-008b）
  - **コマンドインジェクション防止**: `subprocess.run()`に渡す引数はリスト形式で指定し、シェルインジェクションを防止する（`shell=False`を明示）
  - **権限管理**: pyproject.tomlへの書き込み権限がない場合、適切なエラーメッセージと推奨アクション（手動インストール方法）を提示する（FR-008d）
- **使いやすさ**:
  - インストールは手動設定なしで単一コマンドを必要とする
  - `/speckit.doc-init` はインタラクティブプロンプトで設定を収集し、手動での設定ファイル編集を不要にする
  - `/speckit.doc-update` は単一のコマンドですべての機能を更新する
  - 明確なエラーメッセージと次のステップの提案を提供
- **互換性**:
  - spec-kit 0.0.19+ および Python 3.11+ で動作する
  - Sphinx 7.0+ および myst-parser 2.0+（Sphinx使用時）
  - MkDocs 1.5+（MkDocs使用時）をサポート
- **保守性**:
  - プラグインアーキテクチャにより、spec-kit コアの変更を必要とせずに更新が可能
  - 2つの独立したコマンド（`doc-init` と `doc-update`）により、各機能を個別に保守可能
  - **テストカバレッジ**: 主要なコードパス（初期化、更新、エラーハンドリング、依存関係管理）で90%以上のカバレッジを維持する（Constitution V準拠）
  - **TDD必須**: すべての新機能はRed-Green-Refactorサイクルに従って実装される（Constitution C010準拠）
  - **コード品質**: ruff（linter）、mypy --strict（型チェック）がすべて通過しなければコミットしない（Constitution C006準拠）
  - **DRY原則**: コードの重複を排除し、共通ロジックは抽象化する（Constitution C012準拠）
- **拡張性**:
  - アーキテクチャは、将来のリリースで新しいドキュメントジェネレータ（Docusaurus、VitePress）の追加をサポート
  - 各ドキュメントツール（Sphinx、MkDocs）は独立したモジュールとして実装され、新しいツールの追加が容易

### フェーズ2以降

- **パフォーマンス（高度な統合）**:
  - LLM API を使用したエンティティ統合は、5機能あたり追加30秒以内
  - 並列処理により複数機能の API 統合を高速化
- **拡張性（AI エージェント）**:
  - 他の AI エージェント（GitHub Copilot、Gemini、Cursor）のサポート追加が可能
